
tesUSART.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002c9a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000034  00802000  00002c9a  00002d2e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000027e  00802034  00802034  00002d62  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002d62  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000044  00000000  00000000  00002d94  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000540  00000000  00000000  00002dd8  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00010baf  00000000  00000000  00003318  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000052a7  00000000  00000000  00013ec7  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00007991  00000000  00000000  0001916e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000f2c  00000000  00000000  00020b00  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00035a44  00000000  00000000  00021a2c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00007a47  00000000  00000000  00057470  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000006b0  00000000  00000000  0005eeb7  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  0000b76f  00000000  00000000  0005f567  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	07 c1       	rjmp	.+526    	; 0x210 <__ctors_end>
       2:	00 00       	nop
       4:	26 c1       	rjmp	.+588    	; 0x252 <__bad_interrupt>
       6:	00 00       	nop
       8:	24 c1       	rjmp	.+584    	; 0x252 <__bad_interrupt>
       a:	00 00       	nop
       c:	22 c1       	rjmp	.+580    	; 0x252 <__bad_interrupt>
       e:	00 00       	nop
      10:	20 c1       	rjmp	.+576    	; 0x252 <__bad_interrupt>
      12:	00 00       	nop
      14:	1e c1       	rjmp	.+572    	; 0x252 <__bad_interrupt>
      16:	00 00       	nop
      18:	1c c1       	rjmp	.+568    	; 0x252 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	1a c1       	rjmp	.+564    	; 0x252 <__bad_interrupt>
      1e:	00 00       	nop
      20:	18 c1       	rjmp	.+560    	; 0x252 <__bad_interrupt>
      22:	00 00       	nop
      24:	16 c1       	rjmp	.+556    	; 0x252 <__bad_interrupt>
      26:	00 00       	nop
      28:	14 c1       	rjmp	.+552    	; 0x252 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	12 c1       	rjmp	.+548    	; 0x252 <__bad_interrupt>
      2e:	00 00       	nop
      30:	10 c1       	rjmp	.+544    	; 0x252 <__bad_interrupt>
      32:	00 00       	nop
      34:	0e c1       	rjmp	.+540    	; 0x252 <__bad_interrupt>
      36:	00 00       	nop
      38:	0c 94 fb 0a 	jmp	0x15f6	; 0x15f6 <__vector_14>
      3c:	0a c1       	rjmp	.+532    	; 0x252 <__bad_interrupt>
      3e:	00 00       	nop
      40:	08 c1       	rjmp	.+528    	; 0x252 <__bad_interrupt>
      42:	00 00       	nop
      44:	06 c1       	rjmp	.+524    	; 0x252 <__bad_interrupt>
      46:	00 00       	nop
      48:	04 c1       	rjmp	.+520    	; 0x252 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	02 c1       	rjmp	.+516    	; 0x252 <__bad_interrupt>
      4e:	00 00       	nop
      50:	00 c1       	rjmp	.+512    	; 0x252 <__bad_interrupt>
      52:	00 00       	nop
      54:	fe c0       	rjmp	.+508    	; 0x252 <__bad_interrupt>
      56:	00 00       	nop
      58:	fc c0       	rjmp	.+504    	; 0x252 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	fa c0       	rjmp	.+500    	; 0x252 <__bad_interrupt>
      5e:	00 00       	nop
      60:	f8 c0       	rjmp	.+496    	; 0x252 <__bad_interrupt>
      62:	00 00       	nop
      64:	f6 c0       	rjmp	.+492    	; 0x252 <__bad_interrupt>
      66:	00 00       	nop
      68:	f4 c0       	rjmp	.+488    	; 0x252 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	f2 c0       	rjmp	.+484    	; 0x252 <__bad_interrupt>
      6e:	00 00       	nop
      70:	f0 c0       	rjmp	.+480    	; 0x252 <__bad_interrupt>
      72:	00 00       	nop
      74:	ee c0       	rjmp	.+476    	; 0x252 <__bad_interrupt>
      76:	00 00       	nop
      78:	ec c0       	rjmp	.+472    	; 0x252 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	ea c0       	rjmp	.+468    	; 0x252 <__bad_interrupt>
      7e:	00 00       	nop
      80:	e8 c0       	rjmp	.+464    	; 0x252 <__bad_interrupt>
      82:	00 00       	nop
      84:	e6 c0       	rjmp	.+460    	; 0x252 <__bad_interrupt>
      86:	00 00       	nop
      88:	e4 c0       	rjmp	.+456    	; 0x252 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	e2 c0       	rjmp	.+452    	; 0x252 <__bad_interrupt>
      8e:	00 00       	nop
      90:	e0 c0       	rjmp	.+448    	; 0x252 <__bad_interrupt>
      92:	00 00       	nop
      94:	de c0       	rjmp	.+444    	; 0x252 <__bad_interrupt>
      96:	00 00       	nop
      98:	dc c0       	rjmp	.+440    	; 0x252 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	da c0       	rjmp	.+436    	; 0x252 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	d8 c0       	rjmp	.+432    	; 0x252 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	d6 c0       	rjmp	.+428    	; 0x252 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	d4 c0       	rjmp	.+424    	; 0x252 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	d2 c0       	rjmp	.+420    	; 0x252 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	d0 c0       	rjmp	.+416    	; 0x252 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	ce c0       	rjmp	.+412    	; 0x252 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	cc c0       	rjmp	.+408    	; 0x252 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	ca c0       	rjmp	.+404    	; 0x252 <__bad_interrupt>
      be:	00 00       	nop
      c0:	c8 c0       	rjmp	.+400    	; 0x252 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	c6 c0       	rjmp	.+396    	; 0x252 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	c4 c0       	rjmp	.+392    	; 0x252 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	c2 c0       	rjmp	.+388    	; 0x252 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	c0 c0       	rjmp	.+384    	; 0x252 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	be c0       	rjmp	.+380    	; 0x252 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	bc c0       	rjmp	.+376    	; 0x252 <__bad_interrupt>
      da:	00 00       	nop
      dc:	ba c0       	rjmp	.+372    	; 0x252 <__bad_interrupt>
      de:	00 00       	nop
      e0:	b8 c0       	rjmp	.+368    	; 0x252 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	b6 c0       	rjmp	.+364    	; 0x252 <__bad_interrupt>
      e6:	00 00       	nop
      e8:	b4 c0       	rjmp	.+360    	; 0x252 <__bad_interrupt>
      ea:	00 00       	nop
      ec:	b2 c0       	rjmp	.+356    	; 0x252 <__bad_interrupt>
      ee:	00 00       	nop
      f0:	b0 c0       	rjmp	.+352    	; 0x252 <__bad_interrupt>
      f2:	00 00       	nop
      f4:	ae c0       	rjmp	.+348    	; 0x252 <__bad_interrupt>
      f6:	00 00       	nop
      f8:	ac c0       	rjmp	.+344    	; 0x252 <__bad_interrupt>
      fa:	00 00       	nop
      fc:	aa c0       	rjmp	.+340    	; 0x252 <__bad_interrupt>
      fe:	00 00       	nop
     100:	a8 c0       	rjmp	.+336    	; 0x252 <__bad_interrupt>
     102:	00 00       	nop
     104:	a6 c0       	rjmp	.+332    	; 0x252 <__bad_interrupt>
     106:	00 00       	nop
     108:	a4 c0       	rjmp	.+328    	; 0x252 <__bad_interrupt>
     10a:	00 00       	nop
     10c:	a2 c0       	rjmp	.+324    	; 0x252 <__bad_interrupt>
     10e:	00 00       	nop
     110:	a0 c0       	rjmp	.+320    	; 0x252 <__bad_interrupt>
     112:	00 00       	nop
     114:	9e c0       	rjmp	.+316    	; 0x252 <__bad_interrupt>
     116:	00 00       	nop
     118:	9c c0       	rjmp	.+312    	; 0x252 <__bad_interrupt>
     11a:	00 00       	nop
     11c:	9a c0       	rjmp	.+308    	; 0x252 <__bad_interrupt>
     11e:	00 00       	nop
     120:	98 c0       	rjmp	.+304    	; 0x252 <__bad_interrupt>
     122:	00 00       	nop
     124:	96 c0       	rjmp	.+300    	; 0x252 <__bad_interrupt>
     126:	00 00       	nop
     128:	94 c0       	rjmp	.+296    	; 0x252 <__bad_interrupt>
     12a:	00 00       	nop
     12c:	92 c0       	rjmp	.+292    	; 0x252 <__bad_interrupt>
     12e:	00 00       	nop
     130:	90 c0       	rjmp	.+288    	; 0x252 <__bad_interrupt>
     132:	00 00       	nop
     134:	8e c0       	rjmp	.+284    	; 0x252 <__bad_interrupt>
     136:	00 00       	nop
     138:	8c c0       	rjmp	.+280    	; 0x252 <__bad_interrupt>
     13a:	00 00       	nop
     13c:	8a c0       	rjmp	.+276    	; 0x252 <__bad_interrupt>
     13e:	00 00       	nop
     140:	88 c0       	rjmp	.+272    	; 0x252 <__bad_interrupt>
     142:	00 00       	nop
     144:	86 c0       	rjmp	.+268    	; 0x252 <__bad_interrupt>
     146:	00 00       	nop
     148:	84 c0       	rjmp	.+264    	; 0x252 <__bad_interrupt>
     14a:	00 00       	nop
     14c:	82 c0       	rjmp	.+260    	; 0x252 <__bad_interrupt>
     14e:	00 00       	nop
     150:	80 c0       	rjmp	.+256    	; 0x252 <__bad_interrupt>
     152:	00 00       	nop
     154:	7e c0       	rjmp	.+252    	; 0x252 <__bad_interrupt>
     156:	00 00       	nop
     158:	7c c0       	rjmp	.+248    	; 0x252 <__bad_interrupt>
     15a:	00 00       	nop
     15c:	7a c0       	rjmp	.+244    	; 0x252 <__bad_interrupt>
     15e:	00 00       	nop
     160:	78 c0       	rjmp	.+240    	; 0x252 <__bad_interrupt>
     162:	00 00       	nop
     164:	76 c0       	rjmp	.+236    	; 0x252 <__bad_interrupt>
     166:	00 00       	nop
     168:	74 c0       	rjmp	.+232    	; 0x252 <__bad_interrupt>
     16a:	00 00       	nop
     16c:	72 c0       	rjmp	.+228    	; 0x252 <__bad_interrupt>
     16e:	00 00       	nop
     170:	70 c0       	rjmp	.+224    	; 0x252 <__bad_interrupt>
     172:	00 00       	nop
     174:	6e c0       	rjmp	.+220    	; 0x252 <__bad_interrupt>
     176:	00 00       	nop
     178:	6c c0       	rjmp	.+216    	; 0x252 <__bad_interrupt>
     17a:	00 00       	nop
     17c:	6a c0       	rjmp	.+212    	; 0x252 <__bad_interrupt>
     17e:	00 00       	nop
     180:	68 c0       	rjmp	.+208    	; 0x252 <__bad_interrupt>
     182:	00 00       	nop
     184:	66 c0       	rjmp	.+204    	; 0x252 <__bad_interrupt>
     186:	00 00       	nop
     188:	64 c0       	rjmp	.+200    	; 0x252 <__bad_interrupt>
     18a:	00 00       	nop
     18c:	62 c0       	rjmp	.+196    	; 0x252 <__bad_interrupt>
     18e:	00 00       	nop
     190:	60 c0       	rjmp	.+192    	; 0x252 <__bad_interrupt>
     192:	00 00       	nop
     194:	5e c0       	rjmp	.+188    	; 0x252 <__bad_interrupt>
     196:	00 00       	nop
     198:	5c c0       	rjmp	.+184    	; 0x252 <__bad_interrupt>
     19a:	00 00       	nop
     19c:	5a c0       	rjmp	.+180    	; 0x252 <__bad_interrupt>
     19e:	00 00       	nop
     1a0:	58 c0       	rjmp	.+176    	; 0x252 <__bad_interrupt>
     1a2:	00 00       	nop
     1a4:	56 c0       	rjmp	.+172    	; 0x252 <__bad_interrupt>
     1a6:	00 00       	nop
     1a8:	54 c0       	rjmp	.+168    	; 0x252 <__bad_interrupt>
     1aa:	00 00       	nop
     1ac:	52 c0       	rjmp	.+164    	; 0x252 <__bad_interrupt>
     1ae:	00 00       	nop
     1b0:	50 c0       	rjmp	.+160    	; 0x252 <__bad_interrupt>
     1b2:	00 00       	nop
     1b4:	4e c0       	rjmp	.+156    	; 0x252 <__bad_interrupt>
     1b6:	00 00       	nop
     1b8:	4c c0       	rjmp	.+152    	; 0x252 <__bad_interrupt>
     1ba:	00 00       	nop
     1bc:	4a c0       	rjmp	.+148    	; 0x252 <__bad_interrupt>
     1be:	00 00       	nop
     1c0:	48 c0       	rjmp	.+144    	; 0x252 <__bad_interrupt>
     1c2:	00 00       	nop
     1c4:	46 c0       	rjmp	.+140    	; 0x252 <__bad_interrupt>
     1c6:	00 00       	nop
     1c8:	44 c0       	rjmp	.+136    	; 0x252 <__bad_interrupt>
     1ca:	00 00       	nop
     1cc:	42 c0       	rjmp	.+132    	; 0x252 <__bad_interrupt>
     1ce:	00 00       	nop
     1d0:	40 c0       	rjmp	.+128    	; 0x252 <__bad_interrupt>
     1d2:	00 00       	nop
     1d4:	3e c0       	rjmp	.+124    	; 0x252 <__bad_interrupt>
     1d6:	00 00       	nop
     1d8:	3c c0       	rjmp	.+120    	; 0x252 <__bad_interrupt>
     1da:	00 00       	nop
     1dc:	3a c0       	rjmp	.+116    	; 0x252 <__bad_interrupt>
     1de:	00 00       	nop
     1e0:	38 c0       	rjmp	.+112    	; 0x252 <__bad_interrupt>
     1e2:	00 00       	nop
     1e4:	36 c0       	rjmp	.+108    	; 0x252 <__bad_interrupt>
     1e6:	00 00       	nop
     1e8:	34 c0       	rjmp	.+104    	; 0x252 <__bad_interrupt>
     1ea:	00 00       	nop
     1ec:	32 c0       	rjmp	.+100    	; 0x252 <__bad_interrupt>
     1ee:	00 00       	nop
     1f0:	30 c0       	rjmp	.+96     	; 0x252 <__bad_interrupt>
     1f2:	00 00       	nop
     1f4:	2e c0       	rjmp	.+92     	; 0x252 <__bad_interrupt>
     1f6:	00 00       	nop
     1f8:	2c c0       	rjmp	.+88     	; 0x252 <__bad_interrupt>
     1fa:	00 00       	nop
     1fc:	fe 13       	cpse	r31, r30
     1fe:	fe 13       	cpse	r31, r30
     200:	fe 13       	cpse	r31, r30
     202:	34 14       	cp	r3, r4
     204:	24 14       	cp	r2, r4
     206:	31 14       	cp	r3, r1
     208:	fe 13       	cpse	r31, r30
     20a:	fe 13       	cpse	r31, r30
     20c:	34 14       	cp	r3, r4
     20e:	24 14       	cp	r2, r4

00000210 <__ctors_end>:
     210:	11 24       	eor	r1, r1
     212:	1f be       	out	0x3f, r1	; 63
     214:	cf ef       	ldi	r28, 0xFF	; 255
     216:	cd bf       	out	0x3d, r28	; 61
     218:	df e5       	ldi	r29, 0x5F	; 95
     21a:	de bf       	out	0x3e, r29	; 62
     21c:	00 e0       	ldi	r16, 0x00	; 0
     21e:	0c bf       	out	0x3c, r16	; 60

00000220 <__do_copy_data>:
     220:	10 e2       	ldi	r17, 0x20	; 32
     222:	a0 e0       	ldi	r26, 0x00	; 0
     224:	b0 e2       	ldi	r27, 0x20	; 32
     226:	ea e9       	ldi	r30, 0x9A	; 154
     228:	fc e2       	ldi	r31, 0x2C	; 44
     22a:	00 e0       	ldi	r16, 0x00	; 0
     22c:	0b bf       	out	0x3b, r16	; 59
     22e:	02 c0       	rjmp	.+4      	; 0x234 <__do_copy_data+0x14>
     230:	07 90       	elpm	r0, Z+
     232:	0d 92       	st	X+, r0
     234:	a4 33       	cpi	r26, 0x34	; 52
     236:	b1 07       	cpc	r27, r17
     238:	d9 f7       	brne	.-10     	; 0x230 <__do_copy_data+0x10>

0000023a <__do_clear_bss>:
     23a:	22 e2       	ldi	r18, 0x22	; 34
     23c:	a4 e3       	ldi	r26, 0x34	; 52
     23e:	b0 e2       	ldi	r27, 0x20	; 32
     240:	01 c0       	rjmp	.+2      	; 0x244 <.do_clear_bss_start>

00000242 <.do_clear_bss_loop>:
     242:	1d 92       	st	X+, r1

00000244 <.do_clear_bss_start>:
     244:	a2 3b       	cpi	r26, 0xB2	; 178
     246:	b2 07       	cpc	r27, r18
     248:	e1 f7       	brne	.-8      	; 0x242 <.do_clear_bss_loop>
     24a:	0e 94 95 14 	call	0x292a	; 0x292a <main>
     24e:	0c 94 4b 16 	jmp	0x2c96	; 0x2c96 <_exit>

00000252 <__bad_interrupt>:
     252:	d6 ce       	rjmp	.-596    	; 0x0 <__vectors>

00000254 <__portable_avr_delay_cycles>:
 * @{
 */
__always_optimize
static inline void __portable_avr_delay_cycles(unsigned long n)
{
	do { barrier(); } while (--n);
     254:	61 50       	subi	r22, 0x01	; 1
     256:	71 09       	sbc	r23, r1
     258:	81 09       	sbc	r24, r1
     25a:	91 09       	sbc	r25, r1
     25c:	d9 f7       	brne	.-10     	; 0x254 <__portable_avr_delay_cycles>
}
     25e:	08 95       	ret

00000260 <st7565r_init>:
 * Call this function to initialize the hardware interface and the LCD
 * controller. When initialization is done the display is turned on and ready
 * to receive data.
 */
void st7565r_init(void)
{
     260:	bf 92       	push	r11
     262:	cf 92       	push	r12
     264:	df 92       	push	r13
     266:	ef 92       	push	r14
     268:	ff 92       	push	r15
     26a:	0f 93       	push	r16
     26c:	1f 93       	push	r17
     26e:	cf 93       	push	r28
     270:	df 93       	push	r29
     272:	1f 92       	push	r1
     274:	cd b7       	in	r28, 0x3d	; 61
     276:	de b7       	in	r29, 0x3e	; 62
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     278:	00 e0       	ldi	r16, 0x00	; 0
     27a:	16 e0       	ldi	r17, 0x06	; 6
     27c:	68 94       	set
     27e:	ff 24       	eor	r15, r15
     280:	f3 f8       	bld	r15, 3
     282:	f8 01       	movw	r30, r16
     284:	f6 82       	std	Z+6, r15	; 0x06
 * function, this command will control the RST pin.
 */
static inline void st7565r_hard_reset(void)
{
	ioport_set_pin_low(ST7565R_RESET_PIN);
	delay_us(10);
     286:	65 e3       	ldi	r22, 0x35	; 53
     288:	70 e0       	ldi	r23, 0x00	; 0
     28a:	80 e0       	ldi	r24, 0x00	; 0
     28c:	90 e0       	ldi	r25, 0x00	; 0
     28e:	e2 df       	rcall	.-60     	; 0x254 <__portable_avr_delay_cycles>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
     290:	f8 01       	movw	r30, r16
     292:	f5 82       	std	Z+5, r15	; 0x05
	ioport_set_pin_high(ST7565R_RESET_PIN);
	delay_us(10);
     294:	65 e3       	ldi	r22, 0x35	; 53
     296:	70 e0       	ldi	r23, 0x00	; 0
     298:	80 e0       	ldi	r24, 0x00	; 0
     29a:	90 e0       	ldi	r25, 0x00	; 0
     29c:	db df       	rcall	.-74     	; 0x254 <__portable_avr_delay_cycles>
	spi_flags_t spi_flags = SPI_MODE_3;
	board_spi_select_id_t spi_select_id = 0;
#endif

#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {
     29e:	0f 2e       	mov	r0, r31
     2a0:	fb e2       	ldi	r31, 0x2B	; 43
     2a2:	bf 2e       	mov	r11, r31
     2a4:	f0 2d       	mov	r31, r0
		.id = ST7565R_CS_PIN,
	};
	usart_spi_init(ST7565R_USART_SPI);
     2a6:	b9 82       	std	Y+1, r11	; 0x01
     2a8:	80 ea       	ldi	r24, 0xA0	; 160
     2aa:	99 e0       	ldi	r25, 0x09	; 9
	usart_spi_setup_device(ST7565R_USART_SPI, &device, spi_flags,
     2ac:	81 d6       	rcall	.+3330   	; 0xfb0 <usart_spi_init>
     2ae:	c1 2c       	mov	r12, r1
     2b0:	d1 2c       	mov	r13, r1
     2b2:	76 01       	movw	r14, r12
     2b4:	00 e4       	ldi	r16, 0x40	; 64
     2b6:	12 e4       	ldi	r17, 0x42	; 66
     2b8:	2f e0       	ldi	r18, 0x0F	; 15
     2ba:	30 e0       	ldi	r19, 0x00	; 0
     2bc:	43 e0       	ldi	r20, 0x03	; 3
     2be:	be 01       	movw	r22, r28
     2c0:	6f 5f       	subi	r22, 0xFF	; 255
     2c2:	7f 4f       	sbci	r23, 0xFF	; 255
     2c4:	80 ea       	ldi	r24, 0xA0	; 160
     2c6:	99 e0       	ldi	r25, 0x09	; 9
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     2c8:	a2 d6       	rcall	.+3396   	; 0x100e <usart_spi_setup_device>
     2ca:	00 e6       	ldi	r16, 0x60	; 96
     2cc:	16 e0       	ldi	r17, 0x06	; 6
     2ce:	ff 24       	eor	r15, r15
     2d0:	f3 94       	inc	r15
     2d2:	f8 01       	movw	r30, r16
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     2d4:	f6 82       	std	Z+6, r15	; 0x06
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     2d6:	b9 82       	std	Y+1, r11	; 0x01
     2d8:	be 01       	movw	r22, r28
     2da:	6f 5f       	subi	r22, 0xFF	; 255
     2dc:	7f 4f       	sbci	r23, 0xFF	; 255
     2de:	80 ea       	ldi	r24, 0xA0	; 160
     2e0:	99 e0       	ldi	r25, 0x09	; 9
     2e2:	af d6       	rcall	.+3422   	; 0x1042 <usart_spi_select_device>
     2e4:	f8 01       	movw	r30, r16
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     2e6:	f6 82       	std	Z+6, r15	; 0x06
     2e8:	e0 ea       	ldi	r30, 0xA0	; 160
     2ea:	f9 e0       	ldi	r31, 0x09	; 9
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     2ec:	81 81       	ldd	r24, Z+1	; 0x01
     2ee:	85 ff       	sbrs	r24, 5
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     2f0:	fd cf       	rjmp	.-6      	; 0x2ec <st7565r_init+0x8c>
     2f2:	80 ea       	ldi	r24, 0xA0	; 160
     2f4:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     2f8:	e0 ea       	ldi	r30, 0xA0	; 160
     2fa:	f9 e0       	ldi	r31, 0x09	; 9
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     2fc:	81 81       	ldd	r24, Z+1	; 0x01
     2fe:	86 ff       	sbrs	r24, 6
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     300:	fd cf       	rjmp	.-6      	; 0x2fc <st7565r_init+0x9c>
     302:	e0 ea       	ldi	r30, 0xA0	; 160
     304:	f9 e0       	ldi	r31, 0x09	; 9
     306:	80 e4       	ldi	r24, 0x40	; 64
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     308:	81 83       	std	Z+1, r24	; 0x01
     30a:	80 81       	ld	r24, Z
     30c:	be 01       	movw	r22, r28
     30e:	6f 5f       	subi	r22, 0xFF	; 255
     310:	7f 4f       	sbci	r23, 0xFF	; 255
     312:	80 ea       	ldi	r24, 0xA0	; 160
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     314:	99 e0       	ldi	r25, 0x09	; 9
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     316:	ab d6       	rcall	.+3414   	; 0x106e <usart_spi_deselect_device>
     318:	8b e2       	ldi	r24, 0x2B	; 43
     31a:	89 83       	std	Y+1, r24	; 0x01
     31c:	be 01       	movw	r22, r28
     31e:	6f 5f       	subi	r22, 0xFF	; 255
     320:	7f 4f       	sbci	r23, 0xFF	; 255
     322:	80 ea       	ldi	r24, 0xA0	; 160
     324:	99 e0       	ldi	r25, 0x09	; 9
     326:	8d d6       	rcall	.+3354   	; 0x1042 <usart_spi_select_device>
     328:	81 e0       	ldi	r24, 0x01	; 1
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     32a:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
     32e:	e0 ea       	ldi	r30, 0xA0	; 160
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     330:	f9 e0       	ldi	r31, 0x09	; 9
     332:	81 81       	ldd	r24, Z+1	; 0x01
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     334:	85 ff       	sbrs	r24, 5
     336:	fd cf       	rjmp	.-6      	; 0x332 <st7565r_init+0xd2>
     338:	86 ea       	ldi	r24, 0xA6	; 166
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     33a:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
     33e:	e0 ea       	ldi	r30, 0xA0	; 160
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     340:	f9 e0       	ldi	r31, 0x09	; 9
     342:	81 81       	ldd	r24, Z+1	; 0x01
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     344:	86 ff       	sbrs	r24, 6
     346:	fd cf       	rjmp	.-6      	; 0x342 <st7565r_init+0xe2>
     348:	e0 ea       	ldi	r30, 0xA0	; 160
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     34a:	f9 e0       	ldi	r31, 0x09	; 9
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     34c:	80 e4       	ldi	r24, 0x40	; 64
     34e:	81 83       	std	Z+1, r24	; 0x01
     350:	80 81       	ld	r24, Z
     352:	be 01       	movw	r22, r28
     354:	6f 5f       	subi	r22, 0xFF	; 255
     356:	7f 4f       	sbci	r23, 0xFF	; 255
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     358:	80 ea       	ldi	r24, 0xA0	; 160
     35a:	99 e0       	ldi	r25, 0x09	; 9
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     35c:	88 d6       	rcall	.+3344   	; 0x106e <usart_spi_deselect_device>
     35e:	8b e2       	ldi	r24, 0x2B	; 43
     360:	89 83       	std	Y+1, r24	; 0x01
     362:	be 01       	movw	r22, r28
     364:	6f 5f       	subi	r22, 0xFF	; 255
     366:	7f 4f       	sbci	r23, 0xFF	; 255
     368:	80 ea       	ldi	r24, 0xA0	; 160
     36a:	99 e0       	ldi	r25, 0x09	; 9
     36c:	6a d6       	rcall	.+3284   	; 0x1042 <usart_spi_select_device>
     36e:	81 e0       	ldi	r24, 0x01	; 1
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     370:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
     374:	e0 ea       	ldi	r30, 0xA0	; 160
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     376:	f9 e0       	ldi	r31, 0x09	; 9
     378:	81 81       	ldd	r24, Z+1	; 0x01
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     37a:	85 ff       	sbrs	r24, 5
     37c:	fd cf       	rjmp	.-6      	; 0x378 <st7565r_init+0x118>
     37e:	88 ec       	ldi	r24, 0xC8	; 200
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     380:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
     384:	e0 ea       	ldi	r30, 0xA0	; 160
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     386:	f9 e0       	ldi	r31, 0x09	; 9
     388:	81 81       	ldd	r24, Z+1	; 0x01
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     38a:	86 ff       	sbrs	r24, 6
     38c:	fd cf       	rjmp	.-6      	; 0x388 <st7565r_init+0x128>
     38e:	e0 ea       	ldi	r30, 0xA0	; 160
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     390:	f9 e0       	ldi	r31, 0x09	; 9
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     392:	80 e4       	ldi	r24, 0x40	; 64
     394:	81 83       	std	Z+1, r24	; 0x01
     396:	80 81       	ld	r24, Z
     398:	be 01       	movw	r22, r28
     39a:	6f 5f       	subi	r22, 0xFF	; 255
     39c:	7f 4f       	sbci	r23, 0xFF	; 255
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     39e:	80 ea       	ldi	r24, 0xA0	; 160
     3a0:	99 e0       	ldi	r25, 0x09	; 9
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     3a2:	65 d6       	rcall	.+3274   	; 0x106e <usart_spi_deselect_device>
     3a4:	8b e2       	ldi	r24, 0x2B	; 43
     3a6:	89 83       	std	Y+1, r24	; 0x01
     3a8:	be 01       	movw	r22, r28
     3aa:	6f 5f       	subi	r22, 0xFF	; 255
     3ac:	7f 4f       	sbci	r23, 0xFF	; 255
     3ae:	80 ea       	ldi	r24, 0xA0	; 160
     3b0:	99 e0       	ldi	r25, 0x09	; 9
     3b2:	47 d6       	rcall	.+3214   	; 0x1042 <usart_spi_select_device>
     3b4:	81 e0       	ldi	r24, 0x01	; 1
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     3b6:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
     3ba:	e0 ea       	ldi	r30, 0xA0	; 160
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     3bc:	f9 e0       	ldi	r31, 0x09	; 9
     3be:	81 81       	ldd	r24, Z+1	; 0x01
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     3c0:	85 ff       	sbrs	r24, 5
     3c2:	fd cf       	rjmp	.-6      	; 0x3be <st7565r_init+0x15e>
     3c4:	82 ea       	ldi	r24, 0xA2	; 162
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     3c6:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
     3ca:	e0 ea       	ldi	r30, 0xA0	; 160
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     3cc:	f9 e0       	ldi	r31, 0x09	; 9
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     3ce:	81 81       	ldd	r24, Z+1	; 0x01
     3d0:	86 ff       	sbrs	r24, 6
     3d2:	fd cf       	rjmp	.-6      	; 0x3ce <st7565r_init+0x16e>
     3d4:	e0 ea       	ldi	r30, 0xA0	; 160
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     3d6:	f9 e0       	ldi	r31, 0x09	; 9
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     3d8:	80 e4       	ldi	r24, 0x40	; 64
     3da:	81 83       	std	Z+1, r24	; 0x01
     3dc:	80 81       	ld	r24, Z
     3de:	be 01       	movw	r22, r28
     3e0:	6f 5f       	subi	r22, 0xFF	; 255
     3e2:	7f 4f       	sbci	r23, 0xFF	; 255
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     3e4:	80 ea       	ldi	r24, 0xA0	; 160
     3e6:	99 e0       	ldi	r25, 0x09	; 9
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     3e8:	42 d6       	rcall	.+3204   	; 0x106e <usart_spi_deselect_device>
     3ea:	8b e2       	ldi	r24, 0x2B	; 43
     3ec:	89 83       	std	Y+1, r24	; 0x01
     3ee:	be 01       	movw	r22, r28
     3f0:	6f 5f       	subi	r22, 0xFF	; 255
     3f2:	7f 4f       	sbci	r23, 0xFF	; 255
     3f4:	80 ea       	ldi	r24, 0xA0	; 160
     3f6:	99 e0       	ldi	r25, 0x09	; 9
     3f8:	24 d6       	rcall	.+3144   	; 0x1042 <usart_spi_select_device>
     3fa:	81 e0       	ldi	r24, 0x01	; 1
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     3fc:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
     400:	e0 ea       	ldi	r30, 0xA0	; 160
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     402:	f9 e0       	ldi	r31, 0x09	; 9
     404:	81 81       	ldd	r24, Z+1	; 0x01
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     406:	85 ff       	sbrs	r24, 5
     408:	fd cf       	rjmp	.-6      	; 0x404 <__LOCK_REGION_LENGTH__+0x4>
     40a:	8f e2       	ldi	r24, 0x2F	; 47
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     40c:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     410:	e0 ea       	ldi	r30, 0xA0	; 160
     412:	f9 e0       	ldi	r31, 0x09	; 9
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     414:	81 81       	ldd	r24, Z+1	; 0x01
     416:	86 ff       	sbrs	r24, 6
     418:	fd cf       	rjmp	.-6      	; 0x414 <__LOCK_REGION_LENGTH__+0x14>
     41a:	e0 ea       	ldi	r30, 0xA0	; 160
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     41c:	f9 e0       	ldi	r31, 0x09	; 9
     41e:	80 e4       	ldi	r24, 0x40	; 64
     420:	81 83       	std	Z+1, r24	; 0x01
     422:	80 81       	ld	r24, Z
     424:	be 01       	movw	r22, r28
     426:	6f 5f       	subi	r22, 0xFF	; 255
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     428:	7f 4f       	sbci	r23, 0xFF	; 255
     42a:	80 ea       	ldi	r24, 0xA0	; 160
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     42c:	99 e0       	ldi	r25, 0x09	; 9
     42e:	1f d6       	rcall	.+3134   	; 0x106e <usart_spi_deselect_device>
     430:	8b e2       	ldi	r24, 0x2B	; 43
     432:	89 83       	std	Y+1, r24	; 0x01
     434:	be 01       	movw	r22, r28
     436:	6f 5f       	subi	r22, 0xFF	; 255
     438:	7f 4f       	sbci	r23, 0xFF	; 255
     43a:	80 ea       	ldi	r24, 0xA0	; 160
     43c:	99 e0       	ldi	r25, 0x09	; 9
     43e:	01 d6       	rcall	.+3074   	; 0x1042 <usart_spi_select_device>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     440:	81 e0       	ldi	r24, 0x01	; 1
     442:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     446:	e0 ea       	ldi	r30, 0xA0	; 160
     448:	f9 e0       	ldi	r31, 0x09	; 9
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     44a:	81 81       	ldd	r24, Z+1	; 0x01
     44c:	85 ff       	sbrs	r24, 5
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     44e:	fd cf       	rjmp	.-6      	; 0x44a <__LOCK_REGION_LENGTH__+0x4a>
     450:	88 ef       	ldi	r24, 0xF8	; 248
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     452:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     456:	e0 ea       	ldi	r30, 0xA0	; 160
     458:	f9 e0       	ldi	r31, 0x09	; 9
     45a:	81 81       	ldd	r24, Z+1	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     45c:	86 ff       	sbrs	r24, 6
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     45e:	fd cf       	rjmp	.-6      	; 0x45a <__LOCK_REGION_LENGTH__+0x5a>
     460:	e0 ea       	ldi	r30, 0xA0	; 160
     462:	f9 e0       	ldi	r31, 0x09	; 9
     464:	80 e4       	ldi	r24, 0x40	; 64
     466:	81 83       	std	Z+1, r24	; 0x01
     468:	80 81       	ld	r24, Z
     46a:	be 01       	movw	r22, r28
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     46c:	6f 5f       	subi	r22, 0xFF	; 255
     46e:	7f 4f       	sbci	r23, 0xFF	; 255
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     470:	80 ea       	ldi	r24, 0xA0	; 160
     472:	99 e0       	ldi	r25, 0x09	; 9
     474:	fc d5       	rcall	.+3064   	; 0x106e <usart_spi_deselect_device>
     476:	8b e2       	ldi	r24, 0x2B	; 43
     478:	89 83       	std	Y+1, r24	; 0x01
     47a:	be 01       	movw	r22, r28
     47c:	6f 5f       	subi	r22, 0xFF	; 255
     47e:	7f 4f       	sbci	r23, 0xFF	; 255
     480:	80 ea       	ldi	r24, 0xA0	; 160
     482:	99 e0       	ldi	r25, 0x09	; 9
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     484:	de d5       	rcall	.+3004   	; 0x1042 <usart_spi_select_device>
     486:	81 e0       	ldi	r24, 0x01	; 1
     488:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     48c:	e0 ea       	ldi	r30, 0xA0	; 160
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     48e:	f9 e0       	ldi	r31, 0x09	; 9
     490:	81 81       	ldd	r24, Z+1	; 0x01
     492:	85 ff       	sbrs	r24, 5
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     494:	fd cf       	rjmp	.-6      	; 0x490 <__LOCK_REGION_LENGTH__+0x90>
     496:	10 92 a0 09 	sts	0x09A0, r1	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     49a:	e0 ea       	ldi	r30, 0xA0	; 160
     49c:	f9 e0       	ldi	r31, 0x09	; 9
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     49e:	81 81       	ldd	r24, Z+1	; 0x01
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     4a0:	86 ff       	sbrs	r24, 6
     4a2:	fd cf       	rjmp	.-6      	; 0x49e <__LOCK_REGION_LENGTH__+0x9e>
     4a4:	e0 ea       	ldi	r30, 0xA0	; 160
     4a6:	f9 e0       	ldi	r31, 0x09	; 9
     4a8:	80 e4       	ldi	r24, 0x40	; 64
     4aa:	81 83       	std	Z+1, r24	; 0x01
     4ac:	80 81       	ld	r24, Z
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     4ae:	be 01       	movw	r22, r28
     4b0:	6f 5f       	subi	r22, 0xFF	; 255
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     4b2:	7f 4f       	sbci	r23, 0xFF	; 255
     4b4:	80 ea       	ldi	r24, 0xA0	; 160
     4b6:	99 e0       	ldi	r25, 0x09	; 9
     4b8:	da d5       	rcall	.+2996   	; 0x106e <usart_spi_deselect_device>
     4ba:	8b e2       	ldi	r24, 0x2B	; 43
     4bc:	89 83       	std	Y+1, r24	; 0x01
     4be:	be 01       	movw	r22, r28
     4c0:	6f 5f       	subi	r22, 0xFF	; 255
     4c2:	7f 4f       	sbci	r23, 0xFF	; 255
     4c4:	80 ea       	ldi	r24, 0xA0	; 160
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     4c6:	99 e0       	ldi	r25, 0x09	; 9
     4c8:	bc d5       	rcall	.+2936   	; 0x1042 <usart_spi_select_device>
     4ca:	81 e0       	ldi	r24, 0x01	; 1
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     4cc:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     4d0:	e0 ea       	ldi	r30, 0xA0	; 160
     4d2:	f9 e0       	ldi	r31, 0x09	; 9
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     4d4:	81 81       	ldd	r24, Z+1	; 0x01
     4d6:	85 ff       	sbrs	r24, 5
     4d8:	fd cf       	rjmp	.-6      	; 0x4d4 <__LOCK_REGION_LENGTH__+0xd4>
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     4da:	81 e2       	ldi	r24, 0x21	; 33
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     4dc:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
     4e0:	e0 ea       	ldi	r30, 0xA0	; 160
     4e2:	f9 e0       	ldi	r31, 0x09	; 9
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     4e4:	81 81       	ldd	r24, Z+1	; 0x01
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     4e6:	86 ff       	sbrs	r24, 6
     4e8:	fd cf       	rjmp	.-6      	; 0x4e4 <__LOCK_REGION_LENGTH__+0xe4>
     4ea:	e0 ea       	ldi	r30, 0xA0	; 160
     4ec:	f9 e0       	ldi	r31, 0x09	; 9
     4ee:	80 e4       	ldi	r24, 0x40	; 64
     4f0:	81 83       	std	Z+1, r24	; 0x01
     4f2:	80 81       	ld	r24, Z
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     4f4:	be 01       	movw	r22, r28
     4f6:	6f 5f       	subi	r22, 0xFF	; 255
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     4f8:	7f 4f       	sbci	r23, 0xFF	; 255
     4fa:	80 ea       	ldi	r24, 0xA0	; 160
     4fc:	99 e0       	ldi	r25, 0x09	; 9
     4fe:	b7 d5       	rcall	.+2926   	; 0x106e <usart_spi_deselect_device>
     500:	8b e2       	ldi	r24, 0x2B	; 43
     502:	89 83       	std	Y+1, r24	; 0x01
     504:	be 01       	movw	r22, r28
     506:	6f 5f       	subi	r22, 0xFF	; 255
     508:	7f 4f       	sbci	r23, 0xFF	; 255
     50a:	80 ea       	ldi	r24, 0xA0	; 160
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     50c:	99 e0       	ldi	r25, 0x09	; 9
     50e:	99 d5       	rcall	.+2866   	; 0x1042 <usart_spi_select_device>
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     510:	81 e0       	ldi	r24, 0x01	; 1
     512:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     516:	e0 ea       	ldi	r30, 0xA0	; 160
     518:	f9 e0       	ldi	r31, 0x09	; 9
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     51a:	81 81       	ldd	r24, Z+1	; 0x01
     51c:	85 ff       	sbrs	r24, 5
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     51e:	fd cf       	rjmp	.-6      	; 0x51a <__LOCK_REGION_LENGTH__+0x11a>
     520:	81 e8       	ldi	r24, 0x81	; 129
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     522:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
     526:	e0 ea       	ldi	r30, 0xA0	; 160
     528:	f9 e0       	ldi	r31, 0x09	; 9
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     52a:	81 81       	ldd	r24, Z+1	; 0x01
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     52c:	86 ff       	sbrs	r24, 6
     52e:	fd cf       	rjmp	.-6      	; 0x52a <__LOCK_REGION_LENGTH__+0x12a>
     530:	e0 ea       	ldi	r30, 0xA0	; 160
     532:	f9 e0       	ldi	r31, 0x09	; 9
     534:	80 e4       	ldi	r24, 0x40	; 64
     536:	81 83       	std	Z+1, r24	; 0x01
     538:	80 81       	ld	r24, Z
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     53a:	be 01       	movw	r22, r28
     53c:	6f 5f       	subi	r22, 0xFF	; 255
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     53e:	7f 4f       	sbci	r23, 0xFF	; 255
     540:	80 ea       	ldi	r24, 0xA0	; 160
     542:	99 e0       	ldi	r25, 0x09	; 9
     544:	94 d5       	rcall	.+2856   	; 0x106e <usart_spi_deselect_device>
     546:	8b e2       	ldi	r24, 0x2B	; 43
     548:	89 83       	std	Y+1, r24	; 0x01
     54a:	be 01       	movw	r22, r28
     54c:	6f 5f       	subi	r22, 0xFF	; 255
     54e:	7f 4f       	sbci	r23, 0xFF	; 255
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     550:	80 ea       	ldi	r24, 0xA0	; 160
     552:	99 e0       	ldi	r25, 0x09	; 9
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     554:	76 d5       	rcall	.+2796   	; 0x1042 <usart_spi_select_device>
     556:	81 e0       	ldi	r24, 0x01	; 1
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     558:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     55c:	e0 ea       	ldi	r30, 0xA0	; 160
     55e:	f9 e0       	ldi	r31, 0x09	; 9
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     560:	81 81       	ldd	r24, Z+1	; 0x01
     562:	85 ff       	sbrs	r24, 5
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     564:	fd cf       	rjmp	.-6      	; 0x560 <__LOCK_REGION_LENGTH__+0x160>
     566:	81 e2       	ldi	r24, 0x21	; 33
     568:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     56c:	e0 ea       	ldi	r30, 0xA0	; 160
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     56e:	f9 e0       	ldi	r31, 0x09	; 9
     570:	81 81       	ldd	r24, Z+1	; 0x01
     572:	86 ff       	sbrs	r24, 6
     574:	fd cf       	rjmp	.-6      	; 0x570 <__LOCK_REGION_LENGTH__+0x170>
     576:	e0 ea       	ldi	r30, 0xA0	; 160
     578:	f9 e0       	ldi	r31, 0x09	; 9
     57a:	80 e4       	ldi	r24, 0x40	; 64
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     57c:	81 83       	std	Z+1, r24	; 0x01
     57e:	80 81       	ld	r24, Z
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     580:	be 01       	movw	r22, r28
     582:	6f 5f       	subi	r22, 0xFF	; 255
     584:	7f 4f       	sbci	r23, 0xFF	; 255
     586:	80 ea       	ldi	r24, 0xA0	; 160
     588:	99 e0       	ldi	r25, 0x09	; 9
     58a:	71 d5       	rcall	.+2786   	; 0x106e <usart_spi_deselect_device>
     58c:	8b e2       	ldi	r24, 0x2B	; 43
     58e:	89 83       	std	Y+1, r24	; 0x01
     590:	be 01       	movw	r22, r28
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     592:	6f 5f       	subi	r22, 0xFF	; 255
     594:	7f 4f       	sbci	r23, 0xFF	; 255
     596:	80 ea       	ldi	r24, 0xA0	; 160
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     598:	99 e0       	ldi	r25, 0x09	; 9
     59a:	53 d5       	rcall	.+2726   	; 0x1042 <usart_spi_select_device>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     59c:	81 e0       	ldi	r24, 0x01	; 1
     59e:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     5a2:	e0 ea       	ldi	r30, 0xA0	; 160
     5a4:	f9 e0       	ldi	r31, 0x09	; 9
     5a6:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     5a8:	85 ff       	sbrs	r24, 5
     5aa:	fd cf       	rjmp	.-6      	; 0x5a6 <__LOCK_REGION_LENGTH__+0x1a6>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     5ac:	8f ea       	ldi	r24, 0xAF	; 175
     5ae:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
     5b2:	e0 ea       	ldi	r30, 0xA0	; 160
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     5b4:	f9 e0       	ldi	r31, 0x09	; 9
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     5b6:	81 81       	ldd	r24, Z+1	; 0x01
     5b8:	86 ff       	sbrs	r24, 6
     5ba:	fd cf       	rjmp	.-6      	; 0x5b6 <__LOCK_REGION_LENGTH__+0x1b6>
     5bc:	e0 ea       	ldi	r30, 0xA0	; 160
     5be:	f9 e0       	ldi	r31, 0x09	; 9
     5c0:	80 e4       	ldi	r24, 0x40	; 64
     5c2:	81 83       	std	Z+1, r24	; 0x01
	is set to the defined min*/
	st7565r_set_contrast(ST7565R_DISPLAY_CONTRAST_MIN);

	// Turn on the display
	st7565r_display_on();
}
     5c4:	80 81       	ld	r24, Z
     5c6:	be 01       	movw	r22, r28
     5c8:	6f 5f       	subi	r22, 0xFF	; 255
     5ca:	7f 4f       	sbci	r23, 0xFF	; 255
     5cc:	80 ea       	ldi	r24, 0xA0	; 160
     5ce:	99 e0       	ldi	r25, 0x09	; 9
     5d0:	4e d5       	rcall	.+2716   	; 0x106e <usart_spi_deselect_device>
     5d2:	0f 90       	pop	r0
     5d4:	df 91       	pop	r29
     5d6:	cf 91       	pop	r28
     5d8:	1f 91       	pop	r17
     5da:	0f 91       	pop	r16
     5dc:	ff 90       	pop	r15
     5de:	ef 90       	pop	r14
     5e0:	df 90       	pop	r13
     5e2:	cf 90       	pop	r12
     5e4:	bf 90       	pop	r11
     5e6:	08 95       	ret

000005e8 <gfx_mono_st7565r_put_byte>:
	gfx_mono_st7565r_put_byte(0, 0, 0xFF);
\endcode
 */
void gfx_mono_st7565r_put_byte(gfx_coord_t page, gfx_coord_t column,
		uint8_t data)
{
     5e8:	ff 92       	push	r15
     5ea:	0f 93       	push	r16
     5ec:	1f 93       	push	r17
     5ee:	cf 93       	push	r28
     5f0:	df 93       	push	r29
     5f2:	1f 92       	push	r1
     5f4:	cd b7       	in	r28, 0x3d	; 61
     5f6:	de b7       	in	r29, 0x3e	; 62
     5f8:	08 2f       	mov	r16, r24
     5fa:	f6 2e       	mov	r15, r22
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	gfx_mono_framebuffer_put_byte(page, column, data);
     5fc:	14 2f       	mov	r17, r20
 */
static inline void st7565r_set_page_address(uint8_t address)
{
	// Make sure that the address is 4 bits (only 8 pages)
	address &= 0x0F;
	st7565r_write_command(ST7565R_CMD_PAGE_ADDRESS_SET(address));
     5fe:	52 d5       	rcall	.+2724   	; 0x10a4 <gfx_mono_framebuffer_put_byte>
     600:	0f 70       	andi	r16, 0x0F	; 15
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     602:	00 6b       	ori	r16, 0xB0	; 176
     604:	8b e2       	ldi	r24, 0x2B	; 43
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     606:	89 83       	std	Y+1, r24	; 0x01
     608:	be 01       	movw	r22, r28
     60a:	6f 5f       	subi	r22, 0xFF	; 255
     60c:	7f 4f       	sbci	r23, 0xFF	; 255
     60e:	80 ea       	ldi	r24, 0xA0	; 160
     610:	99 e0       	ldi	r25, 0x09	; 9
     612:	17 d5       	rcall	.+2606   	; 0x1042 <usart_spi_select_device>
     614:	81 e0       	ldi	r24, 0x01	; 1
     616:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     61a:	e0 ea       	ldi	r30, 0xA0	; 160
     61c:	f9 e0       	ldi	r31, 0x09	; 9
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     61e:	91 81       	ldd	r25, Z+1	; 0x01
     620:	95 ff       	sbrs	r25, 5
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     622:	fd cf       	rjmp	.-6      	; 0x61e <gfx_mono_st7565r_put_byte+0x36>
     624:	00 93 a0 09 	sts	0x09A0, r16	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     628:	e0 ea       	ldi	r30, 0xA0	; 160
     62a:	f9 e0       	ldi	r31, 0x09	; 9
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     62c:	81 81       	ldd	r24, Z+1	; 0x01
     62e:	86 ff       	sbrs	r24, 6
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     630:	fd cf       	rjmp	.-6      	; 0x62c <gfx_mono_st7565r_put_byte+0x44>
     632:	e0 ea       	ldi	r30, 0xA0	; 160
     634:	f9 e0       	ldi	r31, 0x09	; 9
     636:	80 e4       	ldi	r24, 0x40	; 64
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     638:	81 83       	std	Z+1, r24	; 0x01
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     63a:	80 81       	ld	r24, Z
     63c:	be 01       	movw	r22, r28
     63e:	6f 5f       	subi	r22, 0xFF	; 255
     640:	7f 4f       	sbci	r23, 0xFF	; 255
     642:	80 ea       	ldi	r24, 0xA0	; 160
     644:	99 e0       	ldi	r25, 0x09	; 9
 */
static inline void st7565r_set_column_address(uint8_t address)
{
	// Make sure the address is 7 bits
	address &= 0x7F;
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_MSB(address >> 4));
     646:	13 d5       	rcall	.+2598   	; 0x106e <usart_spi_deselect_device>
     648:	0f 2d       	mov	r16, r15
     64a:	0f 77       	andi	r16, 0x7F	; 127
     64c:	02 95       	swap	r16
     64e:	0f 70       	andi	r16, 0x0F	; 15
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     650:	00 61       	ori	r16, 0x10	; 16
     652:	8b e2       	ldi	r24, 0x2B	; 43
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     654:	89 83       	std	Y+1, r24	; 0x01
     656:	be 01       	movw	r22, r28
     658:	6f 5f       	subi	r22, 0xFF	; 255
     65a:	7f 4f       	sbci	r23, 0xFF	; 255
     65c:	80 ea       	ldi	r24, 0xA0	; 160
     65e:	99 e0       	ldi	r25, 0x09	; 9
     660:	f0 d4       	rcall	.+2528   	; 0x1042 <usart_spi_select_device>
     662:	81 e0       	ldi	r24, 0x01	; 1
     664:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     668:	e0 ea       	ldi	r30, 0xA0	; 160
     66a:	f9 e0       	ldi	r31, 0x09	; 9
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     66c:	81 81       	ldd	r24, Z+1	; 0x01
     66e:	85 ff       	sbrs	r24, 5
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     670:	fd cf       	rjmp	.-6      	; 0x66c <gfx_mono_st7565r_put_byte+0x84>
     672:	00 93 a0 09 	sts	0x09A0, r16	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     676:	e0 ea       	ldi	r30, 0xA0	; 160
     678:	f9 e0       	ldi	r31, 0x09	; 9
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     67a:	81 81       	ldd	r24, Z+1	; 0x01
     67c:	86 ff       	sbrs	r24, 6
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     67e:	fd cf       	rjmp	.-6      	; 0x67a <gfx_mono_st7565r_put_byte+0x92>
     680:	e0 ea       	ldi	r30, 0xA0	; 160
     682:	f9 e0       	ldi	r31, 0x09	; 9
     684:	80 e4       	ldi	r24, 0x40	; 64
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     686:	81 83       	std	Z+1, r24	; 0x01
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     688:	80 81       	ld	r24, Z
     68a:	be 01       	movw	r22, r28
     68c:	6f 5f       	subi	r22, 0xFF	; 255
     68e:	7f 4f       	sbci	r23, 0xFF	; 255
     690:	80 ea       	ldi	r24, 0xA0	; 160
     692:	99 e0       	ldi	r25, 0x09	; 9
static inline void st7565r_set_column_address(uint8_t address)
{
	// Make sure the address is 7 bits
	address &= 0x7F;
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_MSB(address >> 4));
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_LSB(address & 0x0F));
     694:	ec d4       	rcall	.+2520   	; 0x106e <usart_spi_deselect_device>
     696:	0f 2d       	mov	r16, r15
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     698:	0f 70       	andi	r16, 0x0F	; 15
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     69a:	8b e2       	ldi	r24, 0x2B	; 43
     69c:	89 83       	std	Y+1, r24	; 0x01
     69e:	be 01       	movw	r22, r28
     6a0:	6f 5f       	subi	r22, 0xFF	; 255
     6a2:	7f 4f       	sbci	r23, 0xFF	; 255
     6a4:	80 ea       	ldi	r24, 0xA0	; 160
     6a6:	99 e0       	ldi	r25, 0x09	; 9
     6a8:	cc d4       	rcall	.+2456   	; 0x1042 <usart_spi_select_device>
     6aa:	81 e0       	ldi	r24, 0x01	; 1
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     6ac:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
     6b0:	e0 ea       	ldi	r30, 0xA0	; 160
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     6b2:	f9 e0       	ldi	r31, 0x09	; 9
     6b4:	81 81       	ldd	r24, Z+1	; 0x01
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     6b6:	85 ff       	sbrs	r24, 5
     6b8:	fd cf       	rjmp	.-6      	; 0x6b4 <gfx_mono_st7565r_put_byte+0xcc>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     6ba:	00 93 a0 09 	sts	0x09A0, r16	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
     6be:	e0 ea       	ldi	r30, 0xA0	; 160
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     6c0:	f9 e0       	ldi	r31, 0x09	; 9
     6c2:	81 81       	ldd	r24, Z+1	; 0x01
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     6c4:	86 ff       	sbrs	r24, 6
     6c6:	fd cf       	rjmp	.-6      	; 0x6c2 <gfx_mono_st7565r_put_byte+0xda>
     6c8:	e0 ea       	ldi	r30, 0xA0	; 160
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     6ca:	f9 e0       	ldi	r31, 0x09	; 9
     6cc:	80 e4       	ldi	r24, 0x40	; 64
     6ce:	81 83       	std	Z+1, r24	; 0x01
     6d0:	80 81       	ld	r24, Z
     6d2:	be 01       	movw	r22, r28
     6d4:	6f 5f       	subi	r22, 0xFF	; 255
 * \param data the data to write
 */
static inline void st7565r_write_data(uint8_t data)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     6d6:	7f 4f       	sbci	r23, 0xFF	; 255
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     6d8:	80 ea       	ldi	r24, 0xA0	; 160
     6da:	99 e0       	ldi	r25, 0x09	; 9
     6dc:	c8 d4       	rcall	.+2448   	; 0x106e <usart_spi_deselect_device>
     6de:	8b e2       	ldi	r24, 0x2B	; 43
     6e0:	89 83       	std	Y+1, r24	; 0x01
     6e2:	be 01       	movw	r22, r28
     6e4:	6f 5f       	subi	r22, 0xFF	; 255
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
     6e6:	7f 4f       	sbci	r23, 0xFF	; 255
     6e8:	80 ea       	ldi	r24, 0xA0	; 160
     6ea:	99 e0       	ldi	r25, 0x09	; 9
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     6ec:	aa d4       	rcall	.+2388   	; 0x1042 <usart_spi_select_device>
     6ee:	81 e0       	ldi	r24, 0x01	; 1
     6f0:	80 93 65 06 	sts	0x0665, r24	; 0x800665 <__TEXT_REGION_LENGTH__+0x700665>
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     6f4:	e0 ea       	ldi	r30, 0xA0	; 160
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     6f6:	f9 e0       	ldi	r31, 0x09	; 9
     6f8:	81 81       	ldd	r24, Z+1	; 0x01
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     6fa:	85 ff       	sbrs	r24, 5
     6fc:	fd cf       	rjmp	.-6      	; 0x6f8 <gfx_mono_st7565r_put_byte+0x110>
     6fe:	10 93 a0 09 	sts	0x09A0, r17	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     702:	e0 ea       	ldi	r30, 0xA0	; 160
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     704:	f9 e0       	ldi	r31, 0x09	; 9
     706:	81 81       	ldd	r24, Z+1	; 0x01
     708:	86 ff       	sbrs	r24, 6
     70a:	fd cf       	rjmp	.-6      	; 0x706 <gfx_mono_st7565r_put_byte+0x11e>
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     70c:	e0 ea       	ldi	r30, 0xA0	; 160
     70e:	f9 e0       	ldi	r31, 0x09	; 9
	ioport_set_pin_high(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, data);
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     710:	80 e4       	ldi	r24, 0x40	; 64
     712:	81 83       	std	Z+1, r24	; 0x01
     714:	80 81       	ld	r24, Z
     716:	81 e0       	ldi	r24, 0x01	; 1
     718:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
     71c:	be 01       	movw	r22, r28

	st7565r_set_page_address(page);
	st7565r_set_column_address(column);

	st7565r_write_data(data);
}
     71e:	6f 5f       	subi	r22, 0xFF	; 255
     720:	7f 4f       	sbci	r23, 0xFF	; 255
     722:	80 ea       	ldi	r24, 0xA0	; 160
     724:	99 e0       	ldi	r25, 0x09	; 9
     726:	a3 d4       	rcall	.+2374   	; 0x106e <usart_spi_deselect_device>
     728:	0f 90       	pop	r0
     72a:	df 91       	pop	r29
     72c:	cf 91       	pop	r28
     72e:	1f 91       	pop	r17
     730:	0f 91       	pop	r16
     732:	ff 90       	pop	r15
     734:	08 95       	ret

00000736 <gfx_mono_st7565r_init>:
 * It will also write the graphic controller RAM to all zeroes.
 *
 * \note This function will clear the contents of the display.
 */
void gfx_mono_st7565r_init(void)
{
     736:	0f 93       	push	r16
     738:	1f 93       	push	r17
     73a:	cf 93       	push	r28
     73c:	df 93       	push	r29
     73e:	1f 92       	push	r1
     740:	cd b7       	in	r28, 0x3d	; 61
     742:	de b7       	in	r29, 0x3e	; 62
	uint8_t page;
	uint8_t column;

#ifdef CONFIG_ST7565R_FRAMEBUFFER
	gfx_mono_set_framebuffer(framebuffer);
     744:	84 e3       	ldi	r24, 0x34	; 52
     746:	90 e2       	ldi	r25, 0x20	; 32
#endif

	/* Initialize the low-level display controller. */
	st7565r_init();
     748:	a8 d4       	rcall	.+2384   	; 0x109a <gfx_mono_set_framebuffer>
     74a:	8a dd       	rcall	.-1260   	; 0x260 <st7565r_init>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     74c:	8b e2       	ldi	r24, 0x2B	; 43
     74e:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     750:	be 01       	movw	r22, r28
     752:	6f 5f       	subi	r22, 0xFF	; 255
     754:	7f 4f       	sbci	r23, 0xFF	; 255
     756:	80 ea       	ldi	r24, 0xA0	; 160
     758:	99 e0       	ldi	r25, 0x09	; 9
     75a:	73 d4       	rcall	.+2278   	; 0x1042 <usart_spi_select_device>
     75c:	81 e0       	ldi	r24, 0x01	; 1
     75e:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     762:	e0 ea       	ldi	r30, 0xA0	; 160
     764:	f9 e0       	ldi	r31, 0x09	; 9
     766:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     768:	85 ff       	sbrs	r24, 5
     76a:	fd cf       	rjmp	.-6      	; 0x766 <gfx_mono_st7565r_init+0x30>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     76c:	80 e4       	ldi	r24, 0x40	; 64
     76e:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     772:	e0 ea       	ldi	r30, 0xA0	; 160
     774:	f9 e0       	ldi	r31, 0x09	; 9
     776:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     778:	86 ff       	sbrs	r24, 6
     77a:	fd cf       	rjmp	.-6      	; 0x776 <gfx_mono_st7565r_init+0x40>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     77c:	e0 ea       	ldi	r30, 0xA0	; 160
     77e:	f9 e0       	ldi	r31, 0x09	; 9
     780:	80 e4       	ldi	r24, 0x40	; 64
     782:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     784:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     786:	be 01       	movw	r22, r28
     788:	6f 5f       	subi	r22, 0xFF	; 255
     78a:	7f 4f       	sbci	r23, 0xFF	; 255
     78c:	80 ea       	ldi	r24, 0xA0	; 160
     78e:	99 e0       	ldi	r25, 0x09	; 9
     790:	6e d4       	rcall	.+2268   	; 0x106e <usart_spi_deselect_device>

	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
     792:	00 e0       	ldi	r16, 0x00	; 0
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_put_byte(page, column, 0x00);
     794:	0a c0       	rjmp	.+20     	; 0x7aa <gfx_mono_st7565r_init+0x74>
     796:	40 e0       	ldi	r20, 0x00	; 0
     798:	61 2f       	mov	r22, r17
     79a:	80 2f       	mov	r24, r16
     79c:	25 df       	rcall	.-438    	; 0x5e8 <gfx_mono_st7565r_put_byte>
	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
     79e:	1f 5f       	subi	r17, 0xFF	; 255
     7a0:	10 38       	cpi	r17, 0x80	; 128
     7a2:	c9 f7       	brne	.-14     	; 0x796 <gfx_mono_st7565r_init+0x60>

	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
     7a4:	0f 5f       	subi	r16, 0xFF	; 255
     7a6:	04 30       	cpi	r16, 0x04	; 4
     7a8:	11 f0       	breq	.+4      	; 0x7ae <gfx_mono_st7565r_init+0x78>
 * It will also write the graphic controller RAM to all zeroes.
 *
 * \note This function will clear the contents of the display.
 */
void gfx_mono_st7565r_init(void)
{
     7aa:	10 e0       	ldi	r17, 0x00	; 0
     7ac:	f4 cf       	rjmp	.-24     	; 0x796 <gfx_mono_st7565r_init+0x60>
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_put_byte(page, column, 0x00);
		}
	}
}
     7ae:	0f 90       	pop	r0
     7b0:	df 91       	pop	r29
     7b2:	cf 91       	pop	r28
     7b4:	1f 91       	pop	r17
     7b6:	0f 91       	pop	r16
     7b8:	08 95       	ret

000007ba <usart_putchar>:

	if (baud_offset != USART_BAUD_UNDEFINED) {
		(usart)->BAUDCTRLB = (uint8_t)((uint16_t)baudctrl);
		(usart)->BAUDCTRLA = (uint8_t)((uint16_t)baudctrl >> 8);
	}
}
     7ba:	fc 01       	movw	r30, r24
     7bc:	91 81       	ldd	r25, Z+1	; 0x01
     7be:	95 ff       	sbrs	r25, 5
     7c0:	fd cf       	rjmp	.-6      	; 0x7bc <usart_putchar+0x2>
     7c2:	60 83       	st	Z, r22
     7c4:	80 e0       	ldi	r24, 0x00	; 0
     7c6:	90 e0       	ldi	r25, 0x00	; 0
     7c8:	08 95       	ret

000007ca <usart_set_baudrate>:
 * \retval true if the hardware supports the baud rate
 * \retval false if the hardware does not support the baud rate (i.e. it's
 *               either too high or too low.)
 */
bool usart_set_baudrate(USART_t *usart, uint32_t baud, uint32_t cpu_hz)
{
     7ca:	4f 92       	push	r4
     7cc:	5f 92       	push	r5
     7ce:	6f 92       	push	r6
     7d0:	7f 92       	push	r7
     7d2:	8f 92       	push	r8
     7d4:	9f 92       	push	r9
     7d6:	af 92       	push	r10
     7d8:	bf 92       	push	r11
     7da:	ef 92       	push	r14
     7dc:	ff 92       	push	r15
     7de:	0f 93       	push	r16
     7e0:	1f 93       	push	r17
     7e2:	cf 93       	push	r28
     7e4:	7c 01       	movw	r14, r24
     7e6:	4a 01       	movw	r8, r20
     7e8:	5b 01       	movw	r10, r22
     7ea:	28 01       	movw	r4, r16
     7ec:	39 01       	movw	r6, r18
	/* 8 = (2^0) * 8 * (2^0) = (2^BSCALE_MIN) * 8 * (BSEL_MIN) */
	max_rate = cpu_hz / 8;
	/* 4194304 = (2^7) * 8 * (2^12) = (2^BSCALE_MAX) * 8 * (BSEL_MAX+1) */
	min_rate = cpu_hz / 4194304;

	if (!((usart)->CTRLB & USART_CLK2X_bm)) {
     7ee:	fc 01       	movw	r30, r24
     7f0:	84 81       	ldd	r24, Z+4	; 0x04
     7f2:	82 ff       	sbrs	r24, 2
     7f4:	16 c0       	rjmp	.+44     	; 0x822 <usart_set_baudrate+0x58>

	/*
	 * Check if the hardware supports the given baud rate
	 */
	/* 8 = (2^0) * 8 * (2^0) = (2^BSCALE_MIN) * 8 * (BSEL_MIN) */
	max_rate = cpu_hz / 8;
     7f6:	d9 01       	movw	r26, r18
     7f8:	c8 01       	movw	r24, r16
     7fa:	68 94       	set
     7fc:	12 f8       	bld	r1, 2
     7fe:	b6 95       	lsr	r27
     800:	a7 95       	ror	r26
     802:	97 95       	ror	r25
     804:	87 95       	ror	r24
     806:	16 94       	lsr	r1
     808:	d1 f7       	brne	.-12     	; 0x7fe <usart_set_baudrate+0x34>
	/* 4194304 = (2^7) * 8 * (2^12) = (2^BSCALE_MAX) * 8 * (BSEL_MAX+1) */
	min_rate = cpu_hz / 4194304;
     80a:	b9 01       	movw	r22, r18
     80c:	a8 01       	movw	r20, r16
     80e:	03 2e       	mov	r0, r19
     810:	36 e1       	ldi	r19, 0x16	; 22
     812:	76 95       	lsr	r23
     814:	67 95       	ror	r22
     816:	57 95       	ror	r21
     818:	47 95       	ror	r20
     81a:	3a 95       	dec	r19
     81c:	d1 f7       	brne	.-12     	; 0x812 <usart_set_baudrate+0x48>
     81e:	30 2d       	mov	r19, r0
     820:	15 c0       	rjmp	.+42     	; 0x84c <usart_set_baudrate+0x82>

	if (!((usart)->CTRLB & USART_CLK2X_bm)) {
		max_rate /= 2;
     822:	d9 01       	movw	r26, r18
     824:	c8 01       	movw	r24, r16
     826:	68 94       	set
     828:	13 f8       	bld	r1, 3
     82a:	b6 95       	lsr	r27
     82c:	a7 95       	ror	r26
     82e:	97 95       	ror	r25
     830:	87 95       	ror	r24
     832:	16 94       	lsr	r1
     834:	d1 f7       	brne	.-12     	; 0x82a <usart_set_baudrate+0x60>
		min_rate /= 2;
     836:	b9 01       	movw	r22, r18
     838:	a8 01       	movw	r20, r16
     83a:	03 2e       	mov	r0, r19
     83c:	37 e1       	ldi	r19, 0x17	; 23
     83e:	76 95       	lsr	r23
     840:	67 95       	ror	r22
     842:	57 95       	ror	r21
     844:	47 95       	ror	r20
     846:	3a 95       	dec	r19
     848:	d1 f7       	brne	.-12     	; 0x83e <usart_set_baudrate+0x74>
     84a:	30 2d       	mov	r19, r0
	}

	if ((baud > max_rate) || (baud < min_rate)) {
     84c:	88 15       	cp	r24, r8
     84e:	99 05       	cpc	r25, r9
     850:	aa 05       	cpc	r26, r10
     852:	bb 05       	cpc	r27, r11
     854:	08 f4       	brcc	.+2      	; 0x858 <usart_set_baudrate+0x8e>
     856:	a6 c0       	rjmp	.+332    	; 0x9a4 <usart_set_baudrate+0x1da>
     858:	84 16       	cp	r8, r20
     85a:	95 06       	cpc	r9, r21
     85c:	a6 06       	cpc	r10, r22
     85e:	b7 06       	cpc	r11, r23
     860:	08 f4       	brcc	.+2      	; 0x864 <usart_set_baudrate+0x9a>
     862:	a2 c0       	rjmp	.+324    	; 0x9a8 <usart_set_baudrate+0x1de>
		return false;
	}

	/* Check if double speed is enabled. */
	if (!((usart)->CTRLB & USART_CLK2X_bm)) {
     864:	f7 01       	movw	r30, r14
     866:	84 81       	ldd	r24, Z+4	; 0x04
     868:	82 fd       	sbrc	r24, 2
     86a:	04 c0       	rjmp	.+8      	; 0x874 <usart_set_baudrate+0xaa>
		baud *= 2;
     86c:	88 0c       	add	r8, r8
     86e:	99 1c       	adc	r9, r9
     870:	aa 1c       	adc	r10, r10
     872:	bb 1c       	adc	r11, r11
	}

	/* Find the lowest possible exponent. */
	limit = 0xfffU >> 4;
	ratio = cpu_hz / baud;
     874:	c3 01       	movw	r24, r6
     876:	b2 01       	movw	r22, r4
     878:	a5 01       	movw	r20, r10
     87a:	94 01       	movw	r18, r8
     87c:	0e 94 f7 14 	call	0x29ee	; 0x29ee <__udivmodsi4>

	for (exp = -7; exp < 7; exp++) {
		if (ratio < limit) {
     880:	2f 3f       	cpi	r18, 0xFF	; 255
     882:	31 05       	cpc	r19, r1
     884:	41 05       	cpc	r20, r1
     886:	51 05       	cpc	r21, r1
     888:	08 f4       	brcc	.+2      	; 0x88c <usart_set_baudrate+0xc2>
     88a:	90 c0       	rjmp	.+288    	; 0x9ac <usart_set_baudrate+0x1e2>
     88c:	8f ef       	ldi	r24, 0xFF	; 255
     88e:	90 e0       	ldi	r25, 0x00	; 0
     890:	a0 e0       	ldi	r26, 0x00	; 0
     892:	b0 e0       	ldi	r27, 0x00	; 0
     894:	c9 ef       	ldi	r28, 0xF9	; 249
     896:	05 c0       	rjmp	.+10     	; 0x8a2 <usart_set_baudrate+0xd8>
     898:	28 17       	cp	r18, r24
     89a:	39 07       	cpc	r19, r25
     89c:	4a 07       	cpc	r20, r26
     89e:	5b 07       	cpc	r21, r27
     8a0:	58 f0       	brcs	.+22     	; 0x8b8 <usart_set_baudrate+0xee>
			break;
		}

		limit <<= 1;
     8a2:	88 0f       	add	r24, r24
     8a4:	99 1f       	adc	r25, r25
     8a6:	aa 1f       	adc	r26, r26
     8a8:	bb 1f       	adc	r27, r27

		if (exp < -3) {
     8aa:	cd 3f       	cpi	r28, 0xFD	; 253
     8ac:	0c f4       	brge	.+2      	; 0x8b0 <usart_set_baudrate+0xe6>
			limit |= 1;
     8ae:	81 60       	ori	r24, 0x01	; 1
     8b0:	cf 5f       	subi	r28, 0xFF	; 255

	/* Find the lowest possible exponent. */
	limit = 0xfffU >> 4;
	ratio = cpu_hz / baud;

	for (exp = -7; exp < 7; exp++) {
     8b2:	c7 30       	cpi	r28, 0x07	; 7
     8b4:	89 f7       	brne	.-30     	; 0x898 <usart_set_baudrate+0xce>
     8b6:	4f c0       	rjmp	.+158    	; 0x956 <usart_set_baudrate+0x18c>
	 * point.
	 *
	 * The formula for calculating BSEL is slightly different when exp is
	 * negative than it is when exp is positive.
	 */
	if (exp < 0) {
     8b8:	cc 23       	and	r28, r28
     8ba:	0c f0       	brlt	.+2      	; 0x8be <usart_set_baudrate+0xf4>
     8bc:	4c c0       	rjmp	.+152    	; 0x956 <usart_set_baudrate+0x18c>
		/* We are supposed to subtract 1, then apply BSCALE. We want to
		 * apply BSCALE first, so we need to turn everything inside the
		 * parenthesis into a single fractional expression.
		 */
		cpu_hz -= 8 * baud;
     8be:	d5 01       	movw	r26, r10
     8c0:	c4 01       	movw	r24, r8
     8c2:	88 0f       	add	r24, r24
     8c4:	99 1f       	adc	r25, r25
     8c6:	aa 1f       	adc	r26, r26
     8c8:	bb 1f       	adc	r27, r27
     8ca:	88 0f       	add	r24, r24
     8cc:	99 1f       	adc	r25, r25
     8ce:	aa 1f       	adc	r26, r26
     8d0:	bb 1f       	adc	r27, r27
     8d2:	88 0f       	add	r24, r24
     8d4:	99 1f       	adc	r25, r25
     8d6:	aa 1f       	adc	r26, r26
     8d8:	bb 1f       	adc	r27, r27
     8da:	48 1a       	sub	r4, r24
     8dc:	59 0a       	sbc	r5, r25
     8de:	6a 0a       	sbc	r6, r26
     8e0:	7b 0a       	sbc	r7, r27
		/* If we end up with a left-shift after taking the final
		 * divide-by-8 into account, do the shift before the divide.
		 * Otherwise, left-shift the denominator instead (effectively
		 * resulting in an overall right shift.)
		 */
		if (exp <= -3) {
     8e2:	ce 3f       	cpi	r28, 0xFE	; 254
     8e4:	f4 f4       	brge	.+60     	; 0x922 <usart_set_baudrate+0x158>
			div = ((cpu_hz << (-exp - 3)) + baud / 2) / baud;
     8e6:	8d ef       	ldi	r24, 0xFD	; 253
     8e8:	9f ef       	ldi	r25, 0xFF	; 255
     8ea:	8c 1b       	sub	r24, r28
     8ec:	91 09       	sbc	r25, r1
     8ee:	c7 fd       	sbrc	r28, 7
     8f0:	93 95       	inc	r25
     8f2:	04 c0       	rjmp	.+8      	; 0x8fc <usart_set_baudrate+0x132>
     8f4:	44 0c       	add	r4, r4
     8f6:	55 1c       	adc	r5, r5
     8f8:	66 1c       	adc	r6, r6
     8fa:	77 1c       	adc	r7, r7
     8fc:	8a 95       	dec	r24
     8fe:	d2 f7       	brpl	.-12     	; 0x8f4 <usart_set_baudrate+0x12a>
     900:	d5 01       	movw	r26, r10
     902:	c4 01       	movw	r24, r8
     904:	b6 95       	lsr	r27
     906:	a7 95       	ror	r26
     908:	97 95       	ror	r25
     90a:	87 95       	ror	r24
     90c:	bc 01       	movw	r22, r24
     90e:	cd 01       	movw	r24, r26
     910:	64 0d       	add	r22, r4
     912:	75 1d       	adc	r23, r5
     914:	86 1d       	adc	r24, r6
     916:	97 1d       	adc	r25, r7
     918:	a5 01       	movw	r20, r10
     91a:	94 01       	movw	r18, r8
     91c:	0e 94 f7 14 	call	0x29ee	; 0x29ee <__udivmodsi4>
     920:	37 c0       	rjmp	.+110    	; 0x990 <usart_set_baudrate+0x1c6>
		} else {
			baud <<= exp + 3;
     922:	83 e0       	ldi	r24, 0x03	; 3
     924:	8c 0f       	add	r24, r28
     926:	a5 01       	movw	r20, r10
     928:	94 01       	movw	r18, r8
     92a:	04 c0       	rjmp	.+8      	; 0x934 <usart_set_baudrate+0x16a>
     92c:	22 0f       	add	r18, r18
     92e:	33 1f       	adc	r19, r19
     930:	44 1f       	adc	r20, r20
     932:	55 1f       	adc	r21, r21
     934:	8a 95       	dec	r24
     936:	d2 f7       	brpl	.-12     	; 0x92c <usart_set_baudrate+0x162>
			div = (cpu_hz + baud / 2) / baud;
     938:	da 01       	movw	r26, r20
     93a:	c9 01       	movw	r24, r18
     93c:	b6 95       	lsr	r27
     93e:	a7 95       	ror	r26
     940:	97 95       	ror	r25
     942:	87 95       	ror	r24
     944:	bc 01       	movw	r22, r24
     946:	cd 01       	movw	r24, r26
     948:	64 0d       	add	r22, r4
     94a:	75 1d       	adc	r23, r5
     94c:	86 1d       	adc	r24, r6
     94e:	97 1d       	adc	r25, r7
     950:	0e 94 f7 14 	call	0x29ee	; 0x29ee <__udivmodsi4>
     954:	1d c0       	rjmp	.+58     	; 0x990 <usart_set_baudrate+0x1c6>
		}
	} else {
		/* We will always do a right shift in this case, but we need to
		 * shift three extra positions because of the divide-by-8.
		 */
		baud <<= exp + 3;
     956:	83 e0       	ldi	r24, 0x03	; 3
     958:	8c 0f       	add	r24, r28
     95a:	a5 01       	movw	r20, r10
     95c:	94 01       	movw	r18, r8
     95e:	04 c0       	rjmp	.+8      	; 0x968 <usart_set_baudrate+0x19e>
     960:	22 0f       	add	r18, r18
     962:	33 1f       	adc	r19, r19
     964:	44 1f       	adc	r20, r20
     966:	55 1f       	adc	r21, r21
     968:	8a 95       	dec	r24
     96a:	d2 f7       	brpl	.-12     	; 0x960 <usart_set_baudrate+0x196>
		div = (cpu_hz + baud / 2) / baud - 1;
     96c:	da 01       	movw	r26, r20
     96e:	c9 01       	movw	r24, r18
     970:	b6 95       	lsr	r27
     972:	a7 95       	ror	r26
     974:	97 95       	ror	r25
     976:	87 95       	ror	r24
     978:	bc 01       	movw	r22, r24
     97a:	cd 01       	movw	r24, r26
     97c:	64 0d       	add	r22, r4
     97e:	75 1d       	adc	r23, r5
     980:	86 1d       	adc	r24, r6
     982:	97 1d       	adc	r25, r7
     984:	0e 94 f7 14 	call	0x29ee	; 0x29ee <__udivmodsi4>
     988:	21 50       	subi	r18, 0x01	; 1
     98a:	31 09       	sbc	r19, r1
     98c:	41 09       	sbc	r20, r1
     98e:	51 09       	sbc	r21, r1
	}

	(usart)->BAUDCTRLB = (uint8_t)(((div >> 8) & 0X0F) | (exp << 4));
     990:	83 2f       	mov	r24, r19
     992:	8f 70       	andi	r24, 0x0F	; 15
     994:	c2 95       	swap	r28
     996:	c0 7f       	andi	r28, 0xF0	; 240
     998:	c8 2b       	or	r28, r24
     99a:	f7 01       	movw	r30, r14
     99c:	c7 83       	std	Z+7, r28	; 0x07
	(usart)->BAUDCTRLA = (uint8_t)div;
     99e:	26 83       	std	Z+6, r18	; 0x06

	return true;
     9a0:	81 e0       	ldi	r24, 0x01	; 1
     9a2:	18 c0       	rjmp	.+48     	; 0x9d4 <usart_set_baudrate+0x20a>
		max_rate /= 2;
		min_rate /= 2;
	}

	if ((baud > max_rate) || (baud < min_rate)) {
		return false;
     9a4:	80 e0       	ldi	r24, 0x00	; 0
     9a6:	16 c0       	rjmp	.+44     	; 0x9d4 <usart_set_baudrate+0x20a>
     9a8:	80 e0       	ldi	r24, 0x00	; 0
     9aa:	14 c0       	rjmp	.+40     	; 0x9d4 <usart_set_baudrate+0x20a>
	if (exp < 0) {
		/* We are supposed to subtract 1, then apply BSCALE. We want to
		 * apply BSCALE first, so we need to turn everything inside the
		 * parenthesis into a single fractional expression.
		 */
		cpu_hz -= 8 * baud;
     9ac:	d5 01       	movw	r26, r10
     9ae:	c4 01       	movw	r24, r8
     9b0:	88 0f       	add	r24, r24
     9b2:	99 1f       	adc	r25, r25
     9b4:	aa 1f       	adc	r26, r26
     9b6:	bb 1f       	adc	r27, r27
     9b8:	88 0f       	add	r24, r24
     9ba:	99 1f       	adc	r25, r25
     9bc:	aa 1f       	adc	r26, r26
     9be:	bb 1f       	adc	r27, r27
     9c0:	88 0f       	add	r24, r24
     9c2:	99 1f       	adc	r25, r25
     9c4:	aa 1f       	adc	r26, r26
     9c6:	bb 1f       	adc	r27, r27
     9c8:	48 1a       	sub	r4, r24
     9ca:	59 0a       	sbc	r5, r25
     9cc:	6a 0a       	sbc	r6, r26
     9ce:	7b 0a       	sbc	r7, r27

	/* Find the lowest possible exponent. */
	limit = 0xfffU >> 4;
	ratio = cpu_hz / baud;

	for (exp = -7; exp < 7; exp++) {
     9d0:	c9 ef       	ldi	r28, 0xF9	; 249
     9d2:	89 cf       	rjmp	.-238    	; 0x8e6 <usart_set_baudrate+0x11c>

	(usart)->BAUDCTRLB = (uint8_t)(((div >> 8) & 0X0F) | (exp << 4));
	(usart)->BAUDCTRLA = (uint8_t)div;

	return true;
}
     9d4:	cf 91       	pop	r28
     9d6:	1f 91       	pop	r17
     9d8:	0f 91       	pop	r16
     9da:	ff 90       	pop	r15
     9dc:	ef 90       	pop	r14
     9de:	bf 90       	pop	r11
     9e0:	af 90       	pop	r10
     9e2:	9f 90       	pop	r9
     9e4:	8f 90       	pop	r8
     9e6:	7f 90       	pop	r7
     9e8:	6f 90       	pop	r6
     9ea:	5f 90       	pop	r5
     9ec:	4f 90       	pop	r4
     9ee:	08 95       	ret

000009f0 <usart_init_rs232>:
 *
 * \retval true if the initialization was successfull
 * \retval false if the initialization failed (error in baud rate calculation)
 */
bool usart_init_rs232(USART_t *usart, const usart_rs232_options_t *opt)
{
     9f0:	0f 93       	push	r16
     9f2:	1f 93       	push	r17
     9f4:	cf 93       	push	r28
     9f6:	df 93       	push	r29
     9f8:	ec 01       	movw	r28, r24
     9fa:	8b 01       	movw	r16, r22
 *
 * \param module Pointer to the module's base address.
 */
static inline void sysclk_enable_peripheral_clock(const volatile void *module)
{
	if (module == NULL) {
     9fc:	00 97       	sbiw	r24, 0x00	; 0
     9fe:	09 f4       	brne	.+2      	; 0xa02 <usart_init_rs232+0x12>
     a00:	e6 c0       	rjmp	.+460    	; 0xbce <usart_init_rs232+0x1de>
		Assert(false);
	}
#ifdef AES
	else if (module == &AES) {
     a02:	80 3c       	cpi	r24, 0xC0	; 192
     a04:	91 05       	cpc	r25, r1
     a06:	21 f4       	brne	.+8      	; 0xa10 <usart_init_rs232+0x20>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_AES);
     a08:	60 e1       	ldi	r22, 0x10	; 16
     a0a:	80 e0       	ldi	r24, 0x00	; 0
     a0c:	80 d3       	rcall	.+1792   	; 0x110e <sysclk_enable_module>
     a0e:	df c0       	rjmp	.+446    	; 0xbce <usart_init_rs232+0x1de>
	else if (module == &RTC) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_RTC);
	}
#endif
#ifdef EVSYS
	else if (module == &EVSYS) {
     a10:	c0 38       	cpi	r28, 0x80	; 128
     a12:	81 e0       	ldi	r24, 0x01	; 1
     a14:	d8 07       	cpc	r29, r24
     a16:	21 f4       	brne	.+8      	; 0xa20 <usart_init_rs232+0x30>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EVSYS);
     a18:	62 e0       	ldi	r22, 0x02	; 2
     a1a:	80 e0       	ldi	r24, 0x00	; 0
     a1c:	78 d3       	rcall	.+1776   	; 0x110e <sysclk_enable_module>
     a1e:	d7 c0       	rjmp	.+430    	; 0xbce <usart_init_rs232+0x1de>
	}
#endif
#ifdef DMA
	else if (module == &DMA) {
     a20:	c1 15       	cp	r28, r1
     a22:	e1 e0       	ldi	r30, 0x01	; 1
     a24:	de 07       	cpc	r29, r30
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_DMA);
     a26:	21 f4       	brne	.+8      	; 0xa30 <usart_init_rs232+0x40>
     a28:	61 e0       	ldi	r22, 0x01	; 1
     a2a:	80 e0       	ldi	r24, 0x00	; 0
     a2c:	70 d3       	rcall	.+1760   	; 0x110e <sysclk_enable_module>
	else if (module == &EDMA) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EDMA);
	}
#endif
#ifdef ACA
	else if (module == &ACA) {
     a2e:	cf c0       	rjmp	.+414    	; 0xbce <usart_init_rs232+0x1de>
     a30:	c0 38       	cpi	r28, 0x80	; 128
     a32:	f3 e0       	ldi	r31, 0x03	; 3
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_AC);
     a34:	df 07       	cpc	r29, r31
     a36:	21 f4       	brne	.+8      	; 0xa40 <usart_init_rs232+0x50>
     a38:	61 e0       	ldi	r22, 0x01	; 1
     a3a:	81 e0       	ldi	r24, 0x01	; 1
     a3c:	68 d3       	rcall	.+1744   	; 0x110e <sysclk_enable_module>
	}
#endif
#ifdef ACB
	else if (module == &ACB) {
     a3e:	c7 c0       	rjmp	.+398    	; 0xbce <usart_init_rs232+0x1de>
     a40:	c0 39       	cpi	r28, 0x90	; 144
     a42:	83 e0       	ldi	r24, 0x03	; 3
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_AC);
     a44:	d8 07       	cpc	r29, r24
     a46:	21 f4       	brne	.+8      	; 0xa50 <usart_init_rs232+0x60>
     a48:	61 e0       	ldi	r22, 0x01	; 1
     a4a:	82 e0       	ldi	r24, 0x02	; 2
     a4c:	60 d3       	rcall	.+1728   	; 0x110e <sysclk_enable_module>
	}
#endif
#ifdef ADCA
	else if (module == &ADCA) {
     a4e:	bf c0       	rjmp	.+382    	; 0xbce <usart_init_rs232+0x1de>
     a50:	c1 15       	cp	r28, r1
     a52:	e2 e0       	ldi	r30, 0x02	; 2
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_ADC);
     a54:	de 07       	cpc	r29, r30
     a56:	21 f4       	brne	.+8      	; 0xa60 <usart_init_rs232+0x70>
     a58:	62 e0       	ldi	r22, 0x02	; 2
     a5a:	81 e0       	ldi	r24, 0x01	; 1
	}
#endif
#ifdef ADCB
	else if (module == &ADCB) {
     a5c:	58 d3       	rcall	.+1712   	; 0x110e <sysclk_enable_module>
     a5e:	b7 c0       	rjmp	.+366    	; 0xbce <usart_init_rs232+0x1de>
     a60:	c0 34       	cpi	r28, 0x40	; 64
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_ADC);
     a62:	f2 e0       	ldi	r31, 0x02	; 2
     a64:	df 07       	cpc	r29, r31
     a66:	21 f4       	brne	.+8      	; 0xa70 <usart_init_rs232+0x80>
     a68:	62 e0       	ldi	r22, 0x02	; 2
	}
#endif
// Workaround for bad XMEGA D header file
#if !XMEGA_D
#ifdef DACB
	else if (module == &DACB) {
     a6a:	82 e0       	ldi	r24, 0x02	; 2
     a6c:	50 d3       	rcall	.+1696   	; 0x110e <sysclk_enable_module>
     a6e:	af c0       	rjmp	.+350    	; 0xbce <usart_init_rs232+0x1de>
     a70:	c0 32       	cpi	r28, 0x20	; 32
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_DAC);
     a72:	83 e0       	ldi	r24, 0x03	; 3
     a74:	d8 07       	cpc	r29, r24
     a76:	21 f4       	brne	.+8      	; 0xa80 <usart_init_rs232+0x90>
     a78:	64 e0       	ldi	r22, 0x04	; 4
	}
#endif
#endif // Workaround end
#ifdef TCC0
	else if (module == &TCC0) {
     a7a:	82 e0       	ldi	r24, 0x02	; 2
     a7c:	48 d3       	rcall	.+1680   	; 0x110e <sysclk_enable_module>
     a7e:	a7 c0       	rjmp	.+334    	; 0xbce <usart_init_rs232+0x1de>
     a80:	c1 15       	cp	r28, r1
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC0);
     a82:	e8 e0       	ldi	r30, 0x08	; 8
     a84:	de 07       	cpc	r29, r30
     a86:	21 f4       	brne	.+8      	; 0xa90 <usart_init_rs232+0xa0>
     a88:	61 e0       	ldi	r22, 0x01	; 1
	}
#endif
#ifdef TCD0
	else if (module == &TCD0) {
     a8a:	83 e0       	ldi	r24, 0x03	; 3
     a8c:	40 d3       	rcall	.+1664   	; 0x110e <sysclk_enable_module>
     a8e:	9f c0       	rjmp	.+318    	; 0xbce <usart_init_rs232+0x1de>
     a90:	c1 15       	cp	r28, r1
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC0);
     a92:	f9 e0       	ldi	r31, 0x09	; 9
     a94:	df 07       	cpc	r29, r31
     a96:	21 f4       	brne	.+8      	; 0xaa0 <usart_init_rs232+0xb0>
     a98:	61 e0       	ldi	r22, 0x01	; 1
	}
#endif
#ifdef TCE0
	else if (module == &TCE0) {
     a9a:	84 e0       	ldi	r24, 0x04	; 4
     a9c:	38 d3       	rcall	.+1648   	; 0x110e <sysclk_enable_module>
     a9e:	97 c0       	rjmp	.+302    	; 0xbce <usart_init_rs232+0x1de>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC0);
     aa0:	c1 15       	cp	r28, r1
     aa2:	8a e0       	ldi	r24, 0x0A	; 10
     aa4:	d8 07       	cpc	r29, r24
     aa6:	21 f4       	brne	.+8      	; 0xab0 <usart_init_rs232+0xc0>
	}
#endif
#ifdef TCF0
	else if (module == &TCF0) {
     aa8:	61 e0       	ldi	r22, 0x01	; 1
     aaa:	85 e0       	ldi	r24, 0x05	; 5
     aac:	30 d3       	rcall	.+1632   	; 0x110e <sysclk_enable_module>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_TC0);
     aae:	8f c0       	rjmp	.+286    	; 0xbce <usart_init_rs232+0x1de>
     ab0:	c1 15       	cp	r28, r1
     ab2:	eb e0       	ldi	r30, 0x0B	; 11
     ab4:	de 07       	cpc	r29, r30
     ab6:	21 f4       	brne	.+8      	; 0xac0 <usart_init_rs232+0xd0>
	}
#endif
#ifdef TCC1
	else if (module == &TCC1) {
     ab8:	61 e0       	ldi	r22, 0x01	; 1
     aba:	86 e0       	ldi	r24, 0x06	; 6
     abc:	28 d3       	rcall	.+1616   	; 0x110e <sysclk_enable_module>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC1);
     abe:	87 c0       	rjmp	.+270    	; 0xbce <usart_init_rs232+0x1de>
     ac0:	c0 34       	cpi	r28, 0x40	; 64
     ac2:	f8 e0       	ldi	r31, 0x08	; 8
     ac4:	df 07       	cpc	r29, r31
     ac6:	21 f4       	brne	.+8      	; 0xad0 <usart_init_rs232+0xe0>
	}
#endif
#ifdef TCD1
	else if (module == &TCD1) {
     ac8:	62 e0       	ldi	r22, 0x02	; 2
     aca:	83 e0       	ldi	r24, 0x03	; 3
     acc:	20 d3       	rcall	.+1600   	; 0x110e <sysclk_enable_module>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC1);
     ace:	7f c0       	rjmp	.+254    	; 0xbce <usart_init_rs232+0x1de>
     ad0:	c0 34       	cpi	r28, 0x40	; 64
     ad2:	89 e0       	ldi	r24, 0x09	; 9
     ad4:	d8 07       	cpc	r29, r24
	}
#endif
#ifdef TCE1
	else if (module == &TCE1) {
     ad6:	21 f4       	brne	.+8      	; 0xae0 <usart_init_rs232+0xf0>
     ad8:	62 e0       	ldi	r22, 0x02	; 2
     ada:	84 e0       	ldi	r24, 0x04	; 4
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC1);
     adc:	18 d3       	rcall	.+1584   	; 0x110e <sysclk_enable_module>
     ade:	77 c0       	rjmp	.+238    	; 0xbce <usart_init_rs232+0x1de>
     ae0:	c0 34       	cpi	r28, 0x40	; 64
     ae2:	ea e0       	ldi	r30, 0x0A	; 10
	else if (module == &TCD5) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC5);
	}
#endif
#ifdef HIRESC
	else if (module == &HIRESC) {
     ae4:	de 07       	cpc	r29, r30
     ae6:	21 f4       	brne	.+8      	; 0xaf0 <usart_init_rs232+0x100>
     ae8:	62 e0       	ldi	r22, 0x02	; 2
     aea:	85 e0       	ldi	r24, 0x05	; 5
			sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_HIRES);
     aec:	10 d3       	rcall	.+1568   	; 0x110e <sysclk_enable_module>
     aee:	6f c0       	rjmp	.+222    	; 0xbce <usart_init_rs232+0x1de>
     af0:	c0 39       	cpi	r28, 0x90	; 144
     af2:	f8 e0       	ldi	r31, 0x08	; 8
	}
#endif
#ifdef HIRESD
	else if (module == &HIRESD) {
     af4:	df 07       	cpc	r29, r31
     af6:	21 f4       	brne	.+8      	; 0xb00 <usart_init_rs232+0x110>
     af8:	64 e0       	ldi	r22, 0x04	; 4
     afa:	83 e0       	ldi	r24, 0x03	; 3
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_HIRES);
     afc:	08 d3       	rcall	.+1552   	; 0x110e <sysclk_enable_module>
     afe:	67 c0       	rjmp	.+206    	; 0xbce <usart_init_rs232+0x1de>
     b00:	c0 39       	cpi	r28, 0x90	; 144
     b02:	89 e0       	ldi	r24, 0x09	; 9
	}
#endif
#ifdef HIRESE
	else if (module == &HIRESE) {
     b04:	d8 07       	cpc	r29, r24
     b06:	21 f4       	brne	.+8      	; 0xb10 <usart_init_rs232+0x120>
     b08:	64 e0       	ldi	r22, 0x04	; 4
     b0a:	84 e0       	ldi	r24, 0x04	; 4
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_HIRES);
     b0c:	00 d3       	rcall	.+1536   	; 0x110e <sysclk_enable_module>
     b0e:	5f c0       	rjmp	.+190    	; 0xbce <usart_init_rs232+0x1de>
     b10:	c0 39       	cpi	r28, 0x90	; 144
     b12:	ea e0       	ldi	r30, 0x0A	; 10
	}
#endif
#ifdef HIRESF
	else if (module == &HIRESF) {
     b14:	de 07       	cpc	r29, r30
     b16:	21 f4       	brne	.+8      	; 0xb20 <usart_init_rs232+0x130>
     b18:	64 e0       	ldi	r22, 0x04	; 4
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_HIRES);
     b1a:	85 e0       	ldi	r24, 0x05	; 5
     b1c:	f8 d2       	rcall	.+1520   	; 0x110e <sysclk_enable_module>
     b1e:	57 c0       	rjmp	.+174    	; 0xbce <usart_init_rs232+0x1de>
     b20:	c0 39       	cpi	r28, 0x90	; 144
	}
#endif
#ifdef SPIC
	else if (module == &SPIC) {
     b22:	fb e0       	ldi	r31, 0x0B	; 11
     b24:	df 07       	cpc	r29, r31
     b26:	21 f4       	brne	.+8      	; 0xb30 <usart_init_rs232+0x140>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_SPI);
     b28:	64 e0       	ldi	r22, 0x04	; 4
     b2a:	86 e0       	ldi	r24, 0x06	; 6
     b2c:	f0 d2       	rcall	.+1504   	; 0x110e <sysclk_enable_module>
     b2e:	4f c0       	rjmp	.+158    	; 0xbce <usart_init_rs232+0x1de>
     b30:	c0 3c       	cpi	r28, 0xC0	; 192
	}
#endif
#ifdef SPID
	else if (module == &SPID) {
     b32:	88 e0       	ldi	r24, 0x08	; 8
     b34:	d8 07       	cpc	r29, r24
     b36:	21 f4       	brne	.+8      	; 0xb40 <usart_init_rs232+0x150>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_SPI);
     b38:	68 e0       	ldi	r22, 0x08	; 8
     b3a:	83 e0       	ldi	r24, 0x03	; 3
     b3c:	e8 d2       	rcall	.+1488   	; 0x110e <sysclk_enable_module>
     b3e:	47 c0       	rjmp	.+142    	; 0xbce <usart_init_rs232+0x1de>
     b40:	c0 3c       	cpi	r28, 0xC0	; 192
	else if (module == &SPIF) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_SPI);
	}
#endif
#ifdef USARTC0
	else if (module == &USARTC0) {
     b42:	e9 e0       	ldi	r30, 0x09	; 9
     b44:	de 07       	cpc	r29, r30
     b46:	21 f4       	brne	.+8      	; 0xb50 <usart_init_rs232+0x160>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART0);
     b48:	68 e0       	ldi	r22, 0x08	; 8
     b4a:	84 e0       	ldi	r24, 0x04	; 4
     b4c:	e0 d2       	rcall	.+1472   	; 0x110e <sysclk_enable_module>
     b4e:	3f c0       	rjmp	.+126    	; 0xbce <usart_init_rs232+0x1de>
	}
#endif
#ifdef USARTD0
	else if (module == &USARTD0) {
     b50:	c0 3a       	cpi	r28, 0xA0	; 160
     b52:	f8 e0       	ldi	r31, 0x08	; 8
     b54:	df 07       	cpc	r29, r31
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART0);
     b56:	21 f4       	brne	.+8      	; 0xb60 <usart_init_rs232+0x170>
     b58:	60 e1       	ldi	r22, 0x10	; 16
     b5a:	83 e0       	ldi	r24, 0x03	; 3
     b5c:	d8 d2       	rcall	.+1456   	; 0x110e <sysclk_enable_module>
	}
#endif
#ifdef USARTE0
	else if (module == &USARTE0) {
     b5e:	37 c0       	rjmp	.+110    	; 0xbce <usart_init_rs232+0x1de>
     b60:	c0 3a       	cpi	r28, 0xA0	; 160
     b62:	89 e0       	ldi	r24, 0x09	; 9
     b64:	d8 07       	cpc	r29, r24
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_USART0);
     b66:	21 f4       	brne	.+8      	; 0xb70 <usart_init_rs232+0x180>
     b68:	60 e1       	ldi	r22, 0x10	; 16
     b6a:	84 e0       	ldi	r24, 0x04	; 4
     b6c:	d0 d2       	rcall	.+1440   	; 0x110e <sysclk_enable_module>
	}
#endif
#ifdef USARTF0
	else if (module == &USARTF0) {
     b6e:	2f c0       	rjmp	.+94     	; 0xbce <usart_init_rs232+0x1de>
     b70:	c0 3a       	cpi	r28, 0xA0	; 160
     b72:	ea e0       	ldi	r30, 0x0A	; 10
     b74:	de 07       	cpc	r29, r30
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART0);
     b76:	21 f4       	brne	.+8      	; 0xb80 <usart_init_rs232+0x190>
     b78:	60 e1       	ldi	r22, 0x10	; 16
     b7a:	85 e0       	ldi	r24, 0x05	; 5
     b7c:	c8 d2       	rcall	.+1424   	; 0x110e <sysclk_enable_module>
	}
#endif
#ifdef USARTC1
	else if (module == &USARTC1) {
     b7e:	27 c0       	rjmp	.+78     	; 0xbce <usart_init_rs232+0x1de>
     b80:	c0 3a       	cpi	r28, 0xA0	; 160
     b82:	fb e0       	ldi	r31, 0x0B	; 11
     b84:	df 07       	cpc	r29, r31
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART1);
     b86:	21 f4       	brne	.+8      	; 0xb90 <usart_init_rs232+0x1a0>
     b88:	60 e1       	ldi	r22, 0x10	; 16
     b8a:	86 e0       	ldi	r24, 0x06	; 6
     b8c:	c0 d2       	rcall	.+1408   	; 0x110e <sysclk_enable_module>
	}
#endif
#ifdef USARTD1
	else if (module == &USARTD1) {
     b8e:	1f c0       	rjmp	.+62     	; 0xbce <usart_init_rs232+0x1de>
     b90:	c0 3b       	cpi	r28, 0xB0	; 176
     b92:	88 e0       	ldi	r24, 0x08	; 8
     b94:	d8 07       	cpc	r29, r24
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART1);
     b96:	21 f4       	brne	.+8      	; 0xba0 <usart_init_rs232+0x1b0>
     b98:	60 e2       	ldi	r22, 0x20	; 32
     b9a:	83 e0       	ldi	r24, 0x03	; 3
     b9c:	b8 d2       	rcall	.+1392   	; 0x110e <sysclk_enable_module>
     b9e:	17 c0       	rjmp	.+46     	; 0xbce <usart_init_rs232+0x1de>
	else if (module == &USARTF1) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART1);
	}
#endif
#ifdef TWIC
	else if (module == &TWIC) {
     ba0:	c0 3b       	cpi	r28, 0xB0	; 176
     ba2:	e9 e0       	ldi	r30, 0x09	; 9
     ba4:	de 07       	cpc	r29, r30
     ba6:	21 f4       	brne	.+8      	; 0xbb0 <usart_init_rs232+0x1c0>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TWI);
     ba8:	60 e2       	ldi	r22, 0x20	; 32
     baa:	84 e0       	ldi	r24, 0x04	; 4
     bac:	b0 d2       	rcall	.+1376   	; 0x110e <sysclk_enable_module>
     bae:	0f c0       	rjmp	.+30     	; 0xbce <usart_init_rs232+0x1de>
     bb0:	c0 38       	cpi	r28, 0x80	; 128
	else if (module == &TWID) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TWI);
	}
#endif
#ifdef TWIE
	else if (module == &TWIE) {
     bb2:	f4 e0       	ldi	r31, 0x04	; 4
     bb4:	df 07       	cpc	r29, r31
     bb6:	21 f4       	brne	.+8      	; 0xbc0 <usart_init_rs232+0x1d0>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TWI);
     bb8:	60 e4       	ldi	r22, 0x40	; 64
     bba:	83 e0       	ldi	r24, 0x03	; 3
     bbc:	a8 d2       	rcall	.+1360   	; 0x110e <sysclk_enable_module>
     bbe:	07 c0       	rjmp	.+14     	; 0xbce <usart_init_rs232+0x1de>
 * - 0x2        : IrDA mode.
 * - 0x3        : Master SPI mode.
 */
static inline void usart_set_mode(USART_t *usart, USART_CMODE_t usartmode)
{
	(usart)->CTRLC = ((usart)->CTRLC & (~USART_CMODE_gm)) | usartmode;
     bc0:	c0 3a       	cpi	r28, 0xA0	; 160
     bc2:	84 e0       	ldi	r24, 0x04	; 4
     bc4:	d8 07       	cpc	r29, r24
 *  \param twoStopBits Enable two stop bit mode. Use bool type.
 */
static inline void usart_format_set(USART_t *usart, USART_CHSIZE_t charSize,
		USART_PMODE_t parityMode, bool twoStopBits)
{
	(usart)->CTRLC = (uint8_t)charSize | parityMode
     bc6:	19 f4       	brne	.+6      	; 0xbce <usart_init_rs232+0x1de>
     bc8:	60 e4       	ldi	r22, 0x40	; 64
     bca:	85 e0       	ldi	r24, 0x05	; 5
     bcc:	a0 d2       	rcall	.+1344   	; 0x110e <sysclk_enable_module>
     bce:	8d 81       	ldd	r24, Y+5	; 0x05
     bd0:	8f 73       	andi	r24, 0x3F	; 63
     bd2:	8d 83       	std	Y+5, r24	; 0x05
     bd4:	f8 01       	movw	r30, r16
     bd6:	95 81       	ldd	r25, Z+5	; 0x05
	bool result;
	sysclk_enable_peripheral_clock(usart);
	usart_set_mode(usart, USART_CMODE_ASYNCHRONOUS_gc);
	usart_format_set(usart, opt->charlength, opt->paritytype,
			opt->stopbits);
	result = usart_set_baudrate(usart, opt->baudrate, sysclk_get_per_hz());
     bd8:	84 81       	ldd	r24, Z+4	; 0x04
     bda:	89 2b       	or	r24, r25
     bdc:	96 81       	ldd	r25, Z+6	; 0x06
     bde:	91 11       	cpse	r25, r1
     be0:	98 e0       	ldi	r25, 0x08	; 8
     be2:	89 2b       	or	r24, r25
     be4:	8d 83       	std	Y+5, r24	; 0x05
     be6:	f8 01       	movw	r30, r16
     be8:	40 81       	ld	r20, Z
     bea:	51 81       	ldd	r21, Z+1	; 0x01
     bec:	62 81       	ldd	r22, Z+2	; 0x02
     bee:	73 81       	ldd	r23, Z+3	; 0x03
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_tx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_TXEN_bm;
     bf0:	00 e0       	ldi	r16, 0x00	; 0
     bf2:	18 e4       	ldi	r17, 0x48	; 72
     bf4:	28 ee       	ldi	r18, 0xE8	; 232
 *
 * \param usart Pointer to the USART module
 */
static inline void usart_rx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_RXEN_bm;
     bf6:	31 e0       	ldi	r19, 0x01	; 1
     bf8:	ce 01       	movw	r24, r28
     bfa:	e7 dd       	rcall	.-1074   	; 0x7ca <usart_set_baudrate>
	usart_tx_enable(usart);
	usart_rx_enable(usart);
	
	return result;
}
     bfc:	9c 81       	ldd	r25, Y+4	; 0x04
     bfe:	98 60       	ori	r25, 0x08	; 8
     c00:	9c 83       	std	Y+4, r25	; 0x04
     c02:	9c 81       	ldd	r25, Y+4	; 0x04
     c04:	90 61       	ori	r25, 0x10	; 16
     c06:	9c 83       	std	Y+4, r25	; 0x04
     c08:	df 91       	pop	r29
     c0a:	cf 91       	pop	r28
     c0c:	1f 91       	pop	r17
     c0e:	0f 91       	pop	r16
     c10:	08 95       	ret

00000c12 <usart_spi_set_baudrate>:
 * \param usart The USART(SPI) module.
 * \param baud The baudrate.
 * \param cpu_hz The CPU frequency.
 */
void usart_spi_set_baudrate(USART_t *usart, uint32_t baud, uint32_t cpu_hz)
{
     c12:	cf 92       	push	r12
     c14:	df 92       	push	r13
     c16:	ef 92       	push	r14
     c18:	ff 92       	push	r15
     c1a:	0f 93       	push	r16
     c1c:	1f 93       	push	r17
     c1e:	cf 93       	push	r28
     c20:	df 93       	push	r29
     c22:	ec 01       	movw	r28, r24
	uint16_t bsel_value;

	/* Check if baudrate is less than the maximim limit specified in
	 * datasheet */
	if (baud < (cpu_hz / 2)) {
     c24:	d9 01       	movw	r26, r18
     c26:	c8 01       	movw	r24, r16
     c28:	b6 95       	lsr	r27
     c2a:	a7 95       	ror	r26
     c2c:	97 95       	ror	r25
     c2e:	87 95       	ror	r24
     c30:	48 17       	cp	r20, r24
     c32:	59 07       	cpc	r21, r25
     c34:	6a 07       	cpc	r22, r26
     c36:	7b 07       	cpc	r23, r27
     c38:	78 f4       	brcc	.+30     	; 0xc58 <usart_spi_set_baudrate+0x46>
		bsel_value = (cpu_hz / (baud * 2)) - 1;
     c3a:	6a 01       	movw	r12, r20
     c3c:	7b 01       	movw	r14, r22
     c3e:	cc 0c       	add	r12, r12
     c40:	dd 1c       	adc	r13, r13
     c42:	ee 1c       	adc	r14, r14
     c44:	ff 1c       	adc	r15, r15
     c46:	c9 01       	movw	r24, r18
     c48:	b8 01       	movw	r22, r16
     c4a:	a7 01       	movw	r20, r14
     c4c:	96 01       	movw	r18, r12
     c4e:	0e 94 f7 14 	call	0x29ee	; 0x29ee <__udivmodsi4>
     c52:	21 50       	subi	r18, 0x01	; 1
     c54:	31 09       	sbc	r19, r1
     c56:	02 c0       	rjmp	.+4      	; 0xc5c <usart_spi_set_baudrate+0x4a>
	} else {
		/* If baudrate is not within the specfication in datasheet,
		 * assign maximum baudrate possible for the current CPU frequency */
		bsel_value = 0;
     c58:	20 e0       	ldi	r18, 0x00	; 0
     c5a:	30 e0       	ldi	r19, 0x00	; 0
	}

	(usart)->BAUDCTRLB = (uint8_t)((~USART_BSCALE_gm) & (bsel_value >> 8));
     c5c:	83 2f       	mov	r24, r19
     c5e:	8f 70       	andi	r24, 0x0F	; 15
     c60:	8f 83       	std	Y+7, r24	; 0x07
	(usart)->BAUDCTRLA = (uint8_t)(bsel_value);
     c62:	2e 83       	std	Y+6, r18	; 0x06
}
     c64:	df 91       	pop	r29
     c66:	cf 91       	pop	r28
     c68:	1f 91       	pop	r17
     c6a:	0f 91       	pop	r16
     c6c:	ff 90       	pop	r15
     c6e:	ef 90       	pop	r14
     c70:	df 90       	pop	r13
     c72:	cf 90       	pop	r12
     c74:	08 95       	ret

00000c76 <usart_init_spi>:
 *
 * \param usart The USART module.
 * \param opt The RS232 configuration option.
 */
void usart_init_spi(USART_t *usart, const usart_spi_options_t *opt)
{
     c76:	ef 92       	push	r14
     c78:	ff 92       	push	r15
     c7a:	0f 93       	push	r16
     c7c:	1f 93       	push	r17
     c7e:	cf 93       	push	r28
     c80:	df 93       	push	r29
     c82:	ec 01       	movw	r28, r24
     c84:	7b 01       	movw	r14, r22
 *
 * \param module Pointer to the module's base address.
 */
static inline void sysclk_enable_peripheral_clock(const volatile void *module)
{
	if (module == NULL) {
     c86:	00 97       	sbiw	r24, 0x00	; 0
     c88:	09 f4       	brne	.+2      	; 0xc8c <usart_init_spi+0x16>
     c8a:	7b c1       	rjmp	.+758    	; 0xf82 <usart_init_spi+0x30c>
		Assert(false);
	}
#ifdef AES
	else if (module == &AES) {
     c8c:	80 3c       	cpi	r24, 0xC0	; 192
     c8e:	91 05       	cpc	r25, r1
     c90:	21 f4       	brne	.+8      	; 0xc9a <usart_init_spi+0x24>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_AES);
     c92:	60 e1       	ldi	r22, 0x10	; 16
     c94:	80 e0       	ldi	r24, 0x00	; 0
     c96:	3b d2       	rcall	.+1142   	; 0x110e <sysclk_enable_module>
     c98:	74 c1       	rjmp	.+744    	; 0xf82 <usart_init_spi+0x30c>
	else if (module == &RTC) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_RTC);
	}
#endif
#ifdef EVSYS
	else if (module == &EVSYS) {
     c9a:	80 38       	cpi	r24, 0x80	; 128
     c9c:	91 40       	sbci	r25, 0x01	; 1
     c9e:	21 f4       	brne	.+8      	; 0xca8 <usart_init_spi+0x32>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EVSYS);
     ca0:	62 e0       	ldi	r22, 0x02	; 2
     ca2:	80 e0       	ldi	r24, 0x00	; 0
     ca4:	34 d2       	rcall	.+1128   	; 0x110e <sysclk_enable_module>
     ca6:	6d c1       	rjmp	.+730    	; 0xf82 <usart_init_spi+0x30c>
	}
#endif
#ifdef DMA
	else if (module == &DMA) {
     ca8:	c1 15       	cp	r28, r1
     caa:	81 e0       	ldi	r24, 0x01	; 1
     cac:	d8 07       	cpc	r29, r24
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_DMA);
     cae:	21 f4       	brne	.+8      	; 0xcb8 <usart_init_spi+0x42>
     cb0:	61 e0       	ldi	r22, 0x01	; 1
     cb2:	80 e0       	ldi	r24, 0x00	; 0
     cb4:	2c d2       	rcall	.+1112   	; 0x110e <sysclk_enable_module>
	else if (module == &EDMA) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EDMA);
	}
#endif
#ifdef ACA
	else if (module == &ACA) {
     cb6:	65 c1       	rjmp	.+714    	; 0xf82 <usart_init_spi+0x30c>
     cb8:	c0 38       	cpi	r28, 0x80	; 128
     cba:	e3 e0       	ldi	r30, 0x03	; 3
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_AC);
     cbc:	de 07       	cpc	r29, r30
     cbe:	21 f4       	brne	.+8      	; 0xcc8 <usart_init_spi+0x52>
     cc0:	61 e0       	ldi	r22, 0x01	; 1
     cc2:	81 e0       	ldi	r24, 0x01	; 1
     cc4:	24 d2       	rcall	.+1096   	; 0x110e <sysclk_enable_module>
	}
#endif
#ifdef ACB
	else if (module == &ACB) {
     cc6:	5d c1       	rjmp	.+698    	; 0xf82 <usart_init_spi+0x30c>
     cc8:	c0 39       	cpi	r28, 0x90	; 144
     cca:	f3 e0       	ldi	r31, 0x03	; 3
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_AC);
     ccc:	df 07       	cpc	r29, r31
     cce:	21 f4       	brne	.+8      	; 0xcd8 <usart_init_spi+0x62>
     cd0:	61 e0       	ldi	r22, 0x01	; 1
     cd2:	82 e0       	ldi	r24, 0x02	; 2
     cd4:	1c d2       	rcall	.+1080   	; 0x110e <sysclk_enable_module>
	}
#endif
#ifdef ADCA
	else if (module == &ADCA) {
     cd6:	55 c1       	rjmp	.+682    	; 0xf82 <usart_init_spi+0x30c>
     cd8:	c1 15       	cp	r28, r1
     cda:	32 e0       	ldi	r19, 0x02	; 2
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_ADC);
     cdc:	d3 07       	cpc	r29, r19
     cde:	21 f4       	brne	.+8      	; 0xce8 <usart_init_spi+0x72>
     ce0:	62 e0       	ldi	r22, 0x02	; 2
     ce2:	81 e0       	ldi	r24, 0x01	; 1
	}
#endif
#ifdef ADCB
	else if (module == &ADCB) {
     ce4:	14 d2       	rcall	.+1064   	; 0x110e <sysclk_enable_module>
     ce6:	4d c1       	rjmp	.+666    	; 0xf82 <usart_init_spi+0x30c>
     ce8:	c0 34       	cpi	r28, 0x40	; 64
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_ADC);
     cea:	82 e0       	ldi	r24, 0x02	; 2
     cec:	d8 07       	cpc	r29, r24
     cee:	21 f4       	brne	.+8      	; 0xcf8 <usart_init_spi+0x82>
     cf0:	62 e0       	ldi	r22, 0x02	; 2
	}
#endif
// Workaround for bad XMEGA D header file
#if !XMEGA_D
#ifdef DACB
	else if (module == &DACB) {
     cf2:	82 e0       	ldi	r24, 0x02	; 2
     cf4:	0c d2       	rcall	.+1048   	; 0x110e <sysclk_enable_module>
     cf6:	45 c1       	rjmp	.+650    	; 0xf82 <usart_init_spi+0x30c>
     cf8:	c0 32       	cpi	r28, 0x20	; 32
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_DAC);
     cfa:	e3 e0       	ldi	r30, 0x03	; 3
     cfc:	de 07       	cpc	r29, r30
     cfe:	21 f4       	brne	.+8      	; 0xd08 <usart_init_spi+0x92>
     d00:	64 e0       	ldi	r22, 0x04	; 4
	}
#endif
#endif // Workaround end
#ifdef TCC0
	else if (module == &TCC0) {
     d02:	82 e0       	ldi	r24, 0x02	; 2
     d04:	04 d2       	rcall	.+1032   	; 0x110e <sysclk_enable_module>
     d06:	3d c1       	rjmp	.+634    	; 0xf82 <usart_init_spi+0x30c>
     d08:	c1 15       	cp	r28, r1
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC0);
     d0a:	f8 e0       	ldi	r31, 0x08	; 8
     d0c:	df 07       	cpc	r29, r31
     d0e:	21 f4       	brne	.+8      	; 0xd18 <usart_init_spi+0xa2>
     d10:	61 e0       	ldi	r22, 0x01	; 1
	}
#endif
#ifdef TCD0
	else if (module == &TCD0) {
     d12:	83 e0       	ldi	r24, 0x03	; 3
     d14:	fc d1       	rcall	.+1016   	; 0x110e <sysclk_enable_module>
     d16:	35 c1       	rjmp	.+618    	; 0xf82 <usart_init_spi+0x30c>
     d18:	c1 15       	cp	r28, r1
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC0);
     d1a:	39 e0       	ldi	r19, 0x09	; 9
     d1c:	d3 07       	cpc	r29, r19
     d1e:	21 f4       	brne	.+8      	; 0xd28 <usart_init_spi+0xb2>
     d20:	61 e0       	ldi	r22, 0x01	; 1
	}
#endif
#ifdef TCE0
	else if (module == &TCE0) {
     d22:	84 e0       	ldi	r24, 0x04	; 4
     d24:	f4 d1       	rcall	.+1000   	; 0x110e <sysclk_enable_module>
     d26:	2d c1       	rjmp	.+602    	; 0xf82 <usart_init_spi+0x30c>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC0);
     d28:	c1 15       	cp	r28, r1
     d2a:	8a e0       	ldi	r24, 0x0A	; 10
     d2c:	d8 07       	cpc	r29, r24
     d2e:	21 f4       	brne	.+8      	; 0xd38 <usart_init_spi+0xc2>
	}
#endif
#ifdef TCF0
	else if (module == &TCF0) {
     d30:	61 e0       	ldi	r22, 0x01	; 1
     d32:	85 e0       	ldi	r24, 0x05	; 5
     d34:	ec d1       	rcall	.+984    	; 0x110e <sysclk_enable_module>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_TC0);
     d36:	25 c1       	rjmp	.+586    	; 0xf82 <usart_init_spi+0x30c>
     d38:	c1 15       	cp	r28, r1
     d3a:	eb e0       	ldi	r30, 0x0B	; 11
     d3c:	de 07       	cpc	r29, r30
     d3e:	21 f4       	brne	.+8      	; 0xd48 <usart_init_spi+0xd2>
	}
#endif
#ifdef TCC1
	else if (module == &TCC1) {
     d40:	61 e0       	ldi	r22, 0x01	; 1
     d42:	86 e0       	ldi	r24, 0x06	; 6
     d44:	e4 d1       	rcall	.+968    	; 0x110e <sysclk_enable_module>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC1);
     d46:	1d c1       	rjmp	.+570    	; 0xf82 <usart_init_spi+0x30c>
     d48:	c0 34       	cpi	r28, 0x40	; 64
     d4a:	f8 e0       	ldi	r31, 0x08	; 8
     d4c:	df 07       	cpc	r29, r31
     d4e:	21 f4       	brne	.+8      	; 0xd58 <usart_init_spi+0xe2>
	}
#endif
#ifdef TCD1
	else if (module == &TCD1) {
     d50:	62 e0       	ldi	r22, 0x02	; 2
     d52:	83 e0       	ldi	r24, 0x03	; 3
     d54:	dc d1       	rcall	.+952    	; 0x110e <sysclk_enable_module>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC1);
     d56:	15 c1       	rjmp	.+554    	; 0xf82 <usart_init_spi+0x30c>
     d58:	c0 34       	cpi	r28, 0x40	; 64
     d5a:	39 e0       	ldi	r19, 0x09	; 9
     d5c:	d3 07       	cpc	r29, r19
	}
#endif
#ifdef TCE1
	else if (module == &TCE1) {
     d5e:	21 f4       	brne	.+8      	; 0xd68 <usart_init_spi+0xf2>
     d60:	62 e0       	ldi	r22, 0x02	; 2
     d62:	84 e0       	ldi	r24, 0x04	; 4
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC1);
     d64:	d4 d1       	rcall	.+936    	; 0x110e <sysclk_enable_module>
     d66:	0d c1       	rjmp	.+538    	; 0xf82 <usart_init_spi+0x30c>
     d68:	c0 34       	cpi	r28, 0x40	; 64
     d6a:	8a e0       	ldi	r24, 0x0A	; 10
	else if (module == &TCD5) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC5);
	}
#endif
#ifdef HIRESC
	else if (module == &HIRESC) {
     d6c:	d8 07       	cpc	r29, r24
     d6e:	21 f4       	brne	.+8      	; 0xd78 <usart_init_spi+0x102>
     d70:	62 e0       	ldi	r22, 0x02	; 2
     d72:	85 e0       	ldi	r24, 0x05	; 5
			sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_HIRES);
     d74:	cc d1       	rcall	.+920    	; 0x110e <sysclk_enable_module>
     d76:	05 c1       	rjmp	.+522    	; 0xf82 <usart_init_spi+0x30c>
     d78:	c0 39       	cpi	r28, 0x90	; 144
     d7a:	e8 e0       	ldi	r30, 0x08	; 8
	}
#endif
#ifdef HIRESD
	else if (module == &HIRESD) {
     d7c:	de 07       	cpc	r29, r30
     d7e:	21 f4       	brne	.+8      	; 0xd88 <usart_init_spi+0x112>
     d80:	64 e0       	ldi	r22, 0x04	; 4
     d82:	83 e0       	ldi	r24, 0x03	; 3
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_HIRES);
     d84:	c4 d1       	rcall	.+904    	; 0x110e <sysclk_enable_module>
     d86:	fd c0       	rjmp	.+506    	; 0xf82 <usart_init_spi+0x30c>
     d88:	c0 39       	cpi	r28, 0x90	; 144
     d8a:	f9 e0       	ldi	r31, 0x09	; 9
	}
#endif
#ifdef HIRESE
	else if (module == &HIRESE) {
     d8c:	df 07       	cpc	r29, r31
     d8e:	21 f4       	brne	.+8      	; 0xd98 <usart_init_spi+0x122>
     d90:	64 e0       	ldi	r22, 0x04	; 4
     d92:	84 e0       	ldi	r24, 0x04	; 4
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_HIRES);
     d94:	bc d1       	rcall	.+888    	; 0x110e <sysclk_enable_module>
     d96:	f5 c0       	rjmp	.+490    	; 0xf82 <usart_init_spi+0x30c>
     d98:	c0 39       	cpi	r28, 0x90	; 144
     d9a:	3a e0       	ldi	r19, 0x0A	; 10
	}
#endif
#ifdef HIRESF
	else if (module == &HIRESF) {
     d9c:	d3 07       	cpc	r29, r19
     d9e:	21 f4       	brne	.+8      	; 0xda8 <usart_init_spi+0x132>
     da0:	64 e0       	ldi	r22, 0x04	; 4
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_HIRES);
     da2:	85 e0       	ldi	r24, 0x05	; 5
     da4:	b4 d1       	rcall	.+872    	; 0x110e <sysclk_enable_module>
     da6:	ed c0       	rjmp	.+474    	; 0xf82 <usart_init_spi+0x30c>
     da8:	c0 39       	cpi	r28, 0x90	; 144
	}
#endif
#ifdef SPIC
	else if (module == &SPIC) {
     daa:	8b e0       	ldi	r24, 0x0B	; 11
     dac:	d8 07       	cpc	r29, r24
     dae:	21 f4       	brne	.+8      	; 0xdb8 <usart_init_spi+0x142>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_SPI);
     db0:	64 e0       	ldi	r22, 0x04	; 4
     db2:	86 e0       	ldi	r24, 0x06	; 6
     db4:	ac d1       	rcall	.+856    	; 0x110e <sysclk_enable_module>
     db6:	e5 c0       	rjmp	.+458    	; 0xf82 <usart_init_spi+0x30c>
     db8:	c0 3c       	cpi	r28, 0xC0	; 192
	}
#endif
#ifdef SPID
	else if (module == &SPID) {
     dba:	e8 e0       	ldi	r30, 0x08	; 8
     dbc:	de 07       	cpc	r29, r30
     dbe:	21 f4       	brne	.+8      	; 0xdc8 <usart_init_spi+0x152>
     dc0:	68 e0       	ldi	r22, 0x08	; 8
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_SPI);
     dc2:	83 e0       	ldi	r24, 0x03	; 3
     dc4:	a4 d1       	rcall	.+840    	; 0x110e <sysclk_enable_module>
     dc6:	dd c0       	rjmp	.+442    	; 0xf82 <usart_init_spi+0x30c>
     dc8:	c0 3c       	cpi	r28, 0xC0	; 192
     dca:	f9 e0       	ldi	r31, 0x09	; 9
	else if (module == &SPIF) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_SPI);
	}
#endif
#ifdef USARTC0
	else if (module == &USARTC0) {
     dcc:	df 07       	cpc	r29, r31
     dce:	21 f4       	brne	.+8      	; 0xdd8 <usart_init_spi+0x162>
     dd0:	68 e0       	ldi	r22, 0x08	; 8
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART0);
     dd2:	84 e0       	ldi	r24, 0x04	; 4
     dd4:	9c d1       	rcall	.+824    	; 0x110e <sysclk_enable_module>
     dd6:	d5 c0       	rjmp	.+426    	; 0xf82 <usart_init_spi+0x30c>
     dd8:	c0 3a       	cpi	r28, 0xA0	; 160
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_rx_disable(USART_t *usart)
{
	(usart)->CTRLB &= ~USART_RXEN_bm;
     dda:	38 e0       	ldi	r19, 0x08	; 8
     ddc:	d3 07       	cpc	r29, r19
     dde:	61 f4       	brne	.+24     	; 0xdf8 <usart_init_spi+0x182>
     de0:	60 e1       	ldi	r22, 0x10	; 16
	sysclk_enable_peripheral_clock(usart);

	usart_rx_disable(usart);

	/* configure Clock polarity using INVEN bit of the correct SCK I/O port **/
	invert_sck = (opt->spimode == 2) || (opt->spimode == 3);
     de2:	83 e0       	ldi	r24, 0x03	; 3
     de4:	94 d1       	rcall	.+808    	; 0x110e <sysclk_enable_module>
     de6:	e0 ea       	ldi	r30, 0xA0	; 160
	}
#endif
#ifdef USARTD0
	else if (module == &USARTD0) {
     de8:	f8 e0       	ldi	r31, 0x08	; 8
     dea:	84 81       	ldd	r24, Z+4	; 0x04
     dec:	8f 7e       	andi	r24, 0xEF	; 239
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART0);
     dee:	84 83       	std	Z+4, r24	; 0x04
     df0:	f7 01       	movw	r30, r14
     df2:	24 81       	ldd	r18, Z+4	; 0x04
     df4:	22 50       	subi	r18, 0x02	; 2
	}
#endif
#ifdef USARTE0
	else if (module == &USARTE0) {
     df6:	43 c0       	rjmp	.+134    	; 0xe7e <usart_init_spi+0x208>
     df8:	c0 3a       	cpi	r28, 0xA0	; 160
     dfa:	f9 e0       	ldi	r31, 0x09	; 9
     dfc:	df 07       	cpc	r29, r31
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_USART0);
     dfe:	21 f4       	brne	.+8      	; 0xe08 <usart_init_spi+0x192>
     e00:	60 e1       	ldi	r22, 0x10	; 16
     e02:	84 e0       	ldi	r24, 0x04	; 4
     e04:	84 d1       	rcall	.+776    	; 0x110e <sysclk_enable_module>
	}
#endif
#ifdef USARTF0
	else if (module == &USARTF0) {
     e06:	bd c0       	rjmp	.+378    	; 0xf82 <usart_init_spi+0x30c>
     e08:	c0 3a       	cpi	r28, 0xA0	; 160
     e0a:	3a e0       	ldi	r19, 0x0A	; 10
     e0c:	d3 07       	cpc	r29, r19
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART0);
     e0e:	21 f4       	brne	.+8      	; 0xe18 <usart_init_spi+0x1a2>
     e10:	60 e1       	ldi	r22, 0x10	; 16
     e12:	85 e0       	ldi	r24, 0x05	; 5
     e14:	7c d1       	rcall	.+760    	; 0x110e <sysclk_enable_module>
	}
#endif
#ifdef USARTC1
	else if (module == &USARTC1) {
     e16:	b5 c0       	rjmp	.+362    	; 0xf82 <usart_init_spi+0x30c>
     e18:	c0 3a       	cpi	r28, 0xA0	; 160
     e1a:	8b e0       	ldi	r24, 0x0B	; 11
     e1c:	d8 07       	cpc	r29, r24
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART1);
     e1e:	21 f4       	brne	.+8      	; 0xe28 <usart_init_spi+0x1b2>
     e20:	60 e1       	ldi	r22, 0x10	; 16
     e22:	86 e0       	ldi	r24, 0x06	; 6
     e24:	74 d1       	rcall	.+744    	; 0x110e <sysclk_enable_module>
	}
#endif
#ifdef USARTD1
	else if (module == &USARTD1) {
     e26:	ad c0       	rjmp	.+346    	; 0xf82 <usart_init_spi+0x30c>
     e28:	c0 3b       	cpi	r28, 0xB0	; 176
     e2a:	e8 e0       	ldi	r30, 0x08	; 8
     e2c:	de 07       	cpc	r29, r30
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART1);
     e2e:	21 f4       	brne	.+8      	; 0xe38 <usart_init_spi+0x1c2>
     e30:	60 e2       	ldi	r22, 0x20	; 32
     e32:	83 e0       	ldi	r24, 0x03	; 3
     e34:	6c d1       	rcall	.+728    	; 0x110e <sysclk_enable_module>
     e36:	a5 c0       	rjmp	.+330    	; 0xf82 <usart_init_spi+0x30c>
	else if (module == &USARTF1) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART1);
	}
#endif
#ifdef TWIC
	else if (module == &TWIC) {
     e38:	c0 3b       	cpi	r28, 0xB0	; 176
     e3a:	f9 e0       	ldi	r31, 0x09	; 9
     e3c:	df 07       	cpc	r29, r31
     e3e:	21 f4       	brne	.+8      	; 0xe48 <usart_init_spi+0x1d2>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TWI);
     e40:	60 e2       	ldi	r22, 0x20	; 32
     e42:	84 e0       	ldi	r24, 0x04	; 4
     e44:	64 d1       	rcall	.+712    	; 0x110e <sysclk_enable_module>
     e46:	9d c0       	rjmp	.+314    	; 0xf82 <usart_init_spi+0x30c>
     e48:	c0 38       	cpi	r28, 0x80	; 128
	else if (module == &TWID) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TWI);
	}
#endif
#ifdef TWIE
	else if (module == &TWIE) {
     e4a:	34 e0       	ldi	r19, 0x04	; 4
     e4c:	d3 07       	cpc	r29, r19
     e4e:	21 f4       	brne	.+8      	; 0xe58 <usart_init_spi+0x1e2>
     e50:	60 e4       	ldi	r22, 0x40	; 64
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TWI);
     e52:	83 e0       	ldi	r24, 0x03	; 3
     e54:	5c d1       	rcall	.+696    	; 0x110e <sysclk_enable_module>
     e56:	95 c0       	rjmp	.+298    	; 0xf82 <usart_init_spi+0x30c>
     e58:	c0 3a       	cpi	r28, 0xA0	; 160
     e5a:	84 e0       	ldi	r24, 0x04	; 4
     e5c:	d8 07       	cpc	r29, r24
     e5e:	21 f4       	brne	.+8      	; 0xe68 <usart_init_spi+0x1f2>
     e60:	60 e4       	ldi	r22, 0x40	; 64
     e62:	85 e0       	ldi	r24, 0x05	; 5
     e64:	54 d1       	rcall	.+680    	; 0x110e <sysclk_enable_module>
     e66:	8d c0       	rjmp	.+282    	; 0xf82 <usart_init_spi+0x30c>
	UNUSED(invert_sck);

#ifdef USARTC0
	if ((uint16_t)usart == (uint16_t)&USARTC0) {
     e68:	8c 81       	ldd	r24, Y+4	; 0x04
     e6a:	8f 7e       	andi	r24, 0xEF	; 239
     e6c:	8c 83       	std	Y+4, r24	; 0x04
     e6e:	fb 01       	movw	r30, r22
     e70:	24 81       	ldd	r18, Z+4	; 0x04
#  ifdef PORT_USART0_bm
		if (PORTC.REMAP & PORT_USART0_bm) {
     e72:	22 50       	subi	r18, 0x02	; 2
     e74:	ce 01       	movw	r24, r28
     e76:	c0 3a       	cpi	r28, 0xA0	; 160
     e78:	f8 e0       	ldi	r31, 0x08	; 8
			sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTC, 1);
     e7a:	df 07       	cpc	r29, r31
     e7c:	31 f4       	brne	.+12     	; 0xe8a <usart_init_spi+0x214>
		sck_pin = IOPORT_CREATE_PIN(PORTC, 1);
#  endif
	}
#endif
#ifdef USARTC1
	if ((uint16_t)usart == (uint16_t)&USARTC1) {
     e7e:	80 91 4e 06 	lds	r24, 0x064E	; 0x80064e <__TEXT_REGION_LENGTH__+0x70064e>
     e82:	84 fd       	sbrc	r24, 4
     e84:	86 c0       	rjmp	.+268    	; 0xf92 <usart_init_spi+0x31c>
		sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
	}
#endif
#ifdef USARTD0
	if ((uint16_t)usart == (uint16_t)&USARTD0) {
     e86:	11 e1       	ldi	r17, 0x11	; 17
     e88:	85 c0       	rjmp	.+266    	; 0xf94 <usart_init_spi+0x31e>
     e8a:	80 3b       	cpi	r24, 0xB0	; 176
     e8c:	38 e0       	ldi	r19, 0x08	; 8
#  ifdef PORT_USART0_bm
		if (PORTD.REMAP & PORT_USART0_bm) {
     e8e:	93 07       	cpc	r25, r19
     e90:	79 f0       	breq	.+30     	; 0xeb0 <usart_init_spi+0x23a>
     e92:	80 3a       	cpi	r24, 0xA0	; 160
     e94:	e9 e0       	ldi	r30, 0x09	; 9
			sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTD, 1);
     e96:	9e 07       	cpc	r25, r30
     e98:	31 f4       	brne	.+12     	; 0xea6 <usart_init_spi+0x230>
		sck_pin = IOPORT_CREATE_PIN(PORTD, 1);
#  endif
	}
#endif
#ifdef USARTD1
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
     e9a:	30 91 6e 06 	lds	r19, 0x066E	; 0x80066e <__TEXT_REGION_LENGTH__+0x70066e>
     e9e:	34 fd       	sbrc	r19, 4
     ea0:	7c c0       	rjmp	.+248    	; 0xf9a <usart_init_spi+0x324>
     ea2:	19 e1       	ldi	r17, 0x19	; 25
#  endif
	}
#endif
#ifdef USARTC1
	if ((uint16_t)usart == (uint16_t)&USARTC1) {
		sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
     ea4:	10 c0       	rjmp	.+32     	; 0xec6 <usart_init_spi+0x250>
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
		sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
	}
#endif
#ifdef USARTE0
	if ((uint16_t)usart == (uint16_t)&USARTE0) {
     ea6:	80 3b       	cpi	r24, 0xB0	; 176
     ea8:	f9 e0       	ldi	r31, 0x09	; 9
     eaa:	9f 07       	cpc	r25, r31
     eac:	a9 f0       	breq	.+42     	; 0xed8 <usart_init_spi+0x262>
#  ifdef PORT_USART0_bm
		if(PORTE.REMAP & PORT_USART0_bm) {
     eae:	01 c0       	rjmp	.+2      	; 0xeb2 <usart_init_spi+0x23c>
     eb0:	15 e1       	ldi	r17, 0x15	; 21
     eb2:	80 3a       	cpi	r24, 0xA0	; 160
     eb4:	3a e0       	ldi	r19, 0x0A	; 10
			sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTE, 1);
     eb6:	93 07       	cpc	r25, r19
     eb8:	31 f4       	brne	.+12     	; 0xec6 <usart_init_spi+0x250>
	if ((uint16_t)usart == (uint16_t)&USARTE1) {
		sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
	}
#endif
#ifdef USARTF0
	if ((uint16_t)usart == (uint16_t)&USARTF0) {
     eba:	80 91 8e 06 	lds	r24, 0x068E	; 0x80068e <__TEXT_REGION_LENGTH__+0x70068e>
     ebe:	84 fd       	sbrc	r24, 4
#  ifdef PORT_USART0_bm
		if(PORTF.REMAP & PORT_USART0_bm) {
     ec0:	6e c0       	rjmp	.+220    	; 0xf9e <usart_init_spi+0x328>
     ec2:	11 e2       	ldi	r17, 0x21	; 33
     ec4:	0c c0       	rjmp	.+24     	; 0xede <usart_init_spi+0x268>
     ec6:	80 3a       	cpi	r24, 0xA0	; 160
			sck_pin = IOPORT_CREATE_PIN(PORTF, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTF, 1);
     ec8:	9b 40       	sbci	r25, 0x0B	; 11
     eca:	49 f4       	brne	.+18     	; 0xede <usart_init_spi+0x268>
#  endif
	}
#endif
#ifdef USARTD1
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
		sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
     ecc:	80 91 ae 06 	lds	r24, 0x06AE	; 0x8006ae <__TEXT_REGION_LENGTH__+0x7006ae>
#endif
#ifdef USARTF0
	if ((uint16_t)usart == (uint16_t)&USARTF0) {
#  ifdef PORT_USART0_bm
		if(PORTF.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTF, 5);
     ed0:	84 fd       	sbrc	r24, 4
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
     ed2:	04 c0       	rjmp	.+8      	; 0xedc <usart_init_spi+0x266>
     ed4:	19 e2       	ldi	r17, 0x29	; 41
     ed6:	03 c0       	rjmp	.+6      	; 0xede <usart_init_spi+0x268>
     ed8:	1d e1       	ldi	r17, 0x1D	; 29
     eda:	01 c0       	rjmp	.+2      	; 0xede <usart_init_spi+0x268>
     edc:	1d e2       	ldi	r17, 0x2D	; 45
     ede:	e1 2f       	mov	r30, r17
     ee0:	e6 95       	lsr	r30
     ee2:	e6 95       	lsr	r30
     ee4:	e6 95       	lsr	r30
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
     ee6:	30 e2       	ldi	r19, 0x20	; 32
     ee8:	e3 9f       	mul	r30, r19
     eea:	f0 01       	movw	r30, r0
     eec:	11 24       	eor	r1, r1
     eee:	fa 5f       	subi	r31, 0xFA	; 250
     ef0:	17 70       	andi	r17, 0x07	; 7
     ef2:	81 e0       	ldi	r24, 0x01	; 1
     ef4:	90 e0       	ldi	r25, 0x00	; 0
		enum ioport_direction dir)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (dir == IOPORT_DIR_OUTPUT) {
		base->DIRSET = arch_ioport_pin_to_mask(pin);
     ef6:	01 2e       	mov	r0, r17
	}
#endif

	/* Configure the USART output pin */
	ioport_set_pin_dir(sck_pin, IOPORT_DIR_OUTPUT);
	ioport_set_pin_mode(sck_pin,
     ef8:	02 c0       	rjmp	.+4      	; 0xefe <usart_init_spi+0x288>
     efa:	88 0f       	add	r24, r24
     efc:	99 1f       	adc	r25, r25
     efe:	0a 94       	dec	r0
     f00:	e2 f7       	brpl	.-8      	; 0xefa <usart_init_spi+0x284>
__always_inline static void arch_ioport_set_pin_mode(ioport_pin_t pin,
		ioport_mode_t mode)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	volatile uint8_t *pin_ctrl
		= (&base->PIN0CTRL + arch_ioport_pin_to_index(pin));
     f02:	81 83       	std	Z+1, r24	; 0x01
     f04:	22 30       	cpi	r18, 0x02	; 2

__always_inline static void arch_ioport_set_pin_mode(ioport_pin_t pin,
		ioport_mode_t mode)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	volatile uint8_t *pin_ctrl
     f06:	10 f0       	brcs	.+4      	; 0xf0c <usart_init_spi+0x296>
     f08:	40 e0       	ldi	r20, 0x00	; 0

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
     f0a:	01 c0       	rjmp	.+2      	; 0xf0e <usart_init_spi+0x298>
	cpu_irq_disable();
     f0c:	40 e4       	ldi	r20, 0x40	; 64
		= (&base->PIN0CTRL + arch_ioport_pin_to_index(pin));

	uint8_t flags = cpu_irq_save();

	*pin_ctrl &= PORT_ISC_gm;
     f0e:	df 01       	movw	r26, r30
     f10:	50 96       	adiw	r26, 0x10	; 16
     f12:	a1 0f       	add	r26, r17
	*pin_ctrl |= mode;
     f14:	b1 1d       	adc	r27, r1
     f16:	3f b7       	in	r19, 0x3f	; 63
     f18:	f8 94       	cli
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
     f1a:	2c 91       	ld	r18, X
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
     f1c:	27 70       	andi	r18, 0x07	; 7
 * - 0x2        : IrDA mode.
 * - 0x3        : Master SPI mode.
 */
static inline void usart_set_mode(USART_t *usart, USART_CMODE_t usartmode)
{
	(usart)->CTRLC = ((usart)->CTRLC & (~USART_CMODE_gm)) | usartmode;
     f1e:	2c 93       	st	X, r18
     f20:	9c 91       	ld	r25, X
     f22:	94 2b       	or	r25, r20
			IOPORT_MODE_TOTEM | (invert_sck? IOPORT_MODE_INVERT_PIN : 0));
	ioport_set_pin_level(sck_pin, IOPORT_PIN_LEVEL_HIGH);

	usart_set_mode(usart, USART_CMODE_MSPI_gc);

	if (opt->spimode == 1 || opt->spimode == 3) {
     f24:	9c 93       	st	X, r25
     f26:	3f bf       	out	0x3f, r19	; 63
     f28:	85 83       	std	Z+5, r24	; 0x05
     f2a:	8d 81       	ldd	r24, Y+5	; 0x05
		usart->CTRLC |= USART_UCPHA_bm;
     f2c:	80 6c       	ori	r24, 0xC0	; 192
     f2e:	8d 83       	std	Y+5, r24	; 0x05
     f30:	f7 01       	movw	r30, r14
     f32:	84 81       	ldd	r24, Z+4	; 0x04
	} else {
		usart->CTRLC &= ~USART_UCPHA_bm;
     f34:	8d 7f       	andi	r24, 0xFD	; 253
     f36:	81 30       	cpi	r24, 0x01	; 1
     f38:	21 f4       	brne	.+8      	; 0xf42 <usart_init_spi+0x2cc>
	}
	if (opt->data_order) {
     f3a:	8d 81       	ldd	r24, Y+5	; 0x05
     f3c:	82 60       	ori	r24, 0x02	; 2
     f3e:	8d 83       	std	Y+5, r24	; 0x05
     f40:	03 c0       	rjmp	.+6      	; 0xf48 <usart_init_spi+0x2d2>
		(usart)->CTRLC |= USART_DORD_bm;
     f42:	8d 81       	ldd	r24, Y+5	; 0x05
     f44:	8d 7f       	andi	r24, 0xFD	; 253
     f46:	8d 83       	std	Y+5, r24	; 0x05
     f48:	f7 01       	movw	r30, r14
	} else {
		(usart)->CTRLC &= ~USART_DORD_bm;
     f4a:	85 81       	ldd	r24, Z+5	; 0x05
     f4c:	88 23       	and	r24, r24
     f4e:	21 f0       	breq	.+8      	; 0xf58 <usart_init_spi+0x2e2>
	}

	usart_spi_set_baudrate(usart, opt->baudrate, sysclk_get_per_hz());
     f50:	8d 81       	ldd	r24, Y+5	; 0x05
     f52:	84 60       	ori	r24, 0x04	; 4
     f54:	8d 83       	std	Y+5, r24	; 0x05
     f56:	03 c0       	rjmp	.+6      	; 0xf5e <usart_init_spi+0x2e8>
     f58:	8d 81       	ldd	r24, Y+5	; 0x05
     f5a:	8b 7f       	andi	r24, 0xFB	; 251
     f5c:	8d 83       	std	Y+5, r24	; 0x05
     f5e:	f7 01       	movw	r30, r14
     f60:	40 81       	ld	r20, Z
     f62:	51 81       	ldd	r21, Z+1	; 0x01
     f64:	62 81       	ldd	r22, Z+2	; 0x02
     f66:	73 81       	ldd	r23, Z+3	; 0x03
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_tx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_TXEN_bm;
     f68:	00 e0       	ldi	r16, 0x00	; 0
     f6a:	18 e4       	ldi	r17, 0x48	; 72
     f6c:	28 ee       	ldi	r18, 0xE8	; 232
 *
 * \param usart Pointer to the USART module
 */
static inline void usart_rx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_RXEN_bm;
     f6e:	31 e0       	ldi	r19, 0x01	; 1
     f70:	ce 01       	movw	r24, r28
     f72:	4f de       	rcall	.-866    	; 0xc12 <usart_spi_set_baudrate>
	usart_tx_enable(usart);
	usart_rx_enable(usart);
}
     f74:	8c 81       	ldd	r24, Y+4	; 0x04
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_rx_disable(USART_t *usart)
{
	(usart)->CTRLB &= ~USART_RXEN_bm;
     f76:	88 60       	ori	r24, 0x08	; 8
     f78:	8c 83       	std	Y+4, r24	; 0x04
     f7a:	8c 81       	ldd	r24, Y+4	; 0x04
	sysclk_enable_peripheral_clock(usart);

	usart_rx_disable(usart);

	/* configure Clock polarity using INVEN bit of the correct SCK I/O port **/
	invert_sck = (opt->spimode == 2) || (opt->spimode == 3);
     f7c:	80 61       	ori	r24, 0x10	; 16
     f7e:	8c 83       	std	Y+4, r24	; 0x04
     f80:	10 c0       	rjmp	.+32     	; 0xfa2 <usart_init_spi+0x32c>
	UNUSED(invert_sck);

#ifdef USARTC0
	if ((uint16_t)usart == (uint16_t)&USARTC0) {
     f82:	8c 81       	ldd	r24, Y+4	; 0x04
     f84:	8f 7e       	andi	r24, 0xEF	; 239
#  ifdef PORT_USART0_bm
		if (PORTC.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
     f86:	8c 83       	std	Y+4, r24	; 0x04
 *
 * \param usart The USART module.
 * \param opt The RS232 configuration option.
 */
void usart_init_spi(USART_t *usart, const usart_spi_options_t *opt)
{
     f88:	f7 01       	movw	r30, r14
     f8a:	24 81       	ldd	r18, Z+4	; 0x04
     f8c:	22 50       	subi	r18, 0x02	; 2
#endif
#ifdef USARTD0
	if ((uint16_t)usart == (uint16_t)&USARTD0) {
#  ifdef PORT_USART0_bm
		if (PORTD.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
     f8e:	ce 01       	movw	r24, r28
     f90:	7c cf       	rjmp	.-264    	; 0xe8a <usart_init_spi+0x214>
#endif
#ifdef USARTE0
	if ((uint16_t)usart == (uint16_t)&USARTE0) {
#  ifdef PORT_USART0_bm
		if(PORTE.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
     f92:	15 e1       	ldi	r17, 0x15	; 21
     f94:	80 ea       	ldi	r24, 0xA0	; 160
	}

	usart_spi_set_baudrate(usart, opt->baudrate, sysclk_get_per_hz());
	usart_tx_enable(usart);
	usart_rx_enable(usart);
}
     f96:	98 e0       	ldi	r25, 0x08	; 8
     f98:	86 cf       	rjmp	.-244    	; 0xea6 <usart_init_spi+0x230>
     f9a:	1d e1       	ldi	r17, 0x1D	; 29
     f9c:	94 cf       	rjmp	.-216    	; 0xec6 <usart_init_spi+0x250>
     f9e:	15 e2       	ldi	r17, 0x25	; 37
     fa0:	9e cf       	rjmp	.-196    	; 0xede <usart_init_spi+0x268>
     fa2:	df 91       	pop	r29
     fa4:	cf 91       	pop	r28
     fa6:	1f 91       	pop	r17
     fa8:	0f 91       	pop	r16
     faa:	ff 90       	pop	r15
     fac:	ef 90       	pop	r14
     fae:	08 95       	ret

00000fb0 <usart_spi_init>:
		*data = usart_spi_transmit(usart, CONFIG_USART_SPI_DUMMY);
		len--;
		data++;
 	}
	return STATUS_OK;
}
     fb0:	80 3a       	cpi	r24, 0xA0	; 160
     fb2:	28 e0       	ldi	r18, 0x08	; 8
     fb4:	92 07       	cpc	r25, r18
     fb6:	21 f4       	brne	.+8      	; 0xfc0 <usart_spi_init+0x10>
     fb8:	60 e1       	ldi	r22, 0x10	; 16
     fba:	83 e0       	ldi	r24, 0x03	; 3
     fbc:	a8 c0       	rjmp	.+336    	; 0x110e <sysclk_enable_module>
     fbe:	08 95       	ret
     fc0:	80 3b       	cpi	r24, 0xB0	; 176
     fc2:	28 e0       	ldi	r18, 0x08	; 8
     fc4:	92 07       	cpc	r25, r18
     fc6:	21 f4       	brne	.+8      	; 0xfd0 <usart_spi_init+0x20>
     fc8:	60 e2       	ldi	r22, 0x20	; 32
     fca:	83 e0       	ldi	r24, 0x03	; 3
     fcc:	a0 c0       	rjmp	.+320    	; 0x110e <sysclk_enable_module>
     fce:	08 95       	ret
     fd0:	80 3a       	cpi	r24, 0xA0	; 160
     fd2:	29 e0       	ldi	r18, 0x09	; 9
     fd4:	92 07       	cpc	r25, r18
     fd6:	21 f4       	brne	.+8      	; 0xfe0 <usart_spi_init+0x30>
     fd8:	60 e1       	ldi	r22, 0x10	; 16
     fda:	84 e0       	ldi	r24, 0x04	; 4
     fdc:	98 c0       	rjmp	.+304    	; 0x110e <sysclk_enable_module>
     fde:	08 95       	ret
     fe0:	80 3b       	cpi	r24, 0xB0	; 176
     fe2:	29 e0       	ldi	r18, 0x09	; 9
     fe4:	92 07       	cpc	r25, r18
     fe6:	21 f4       	brne	.+8      	; 0xff0 <usart_spi_init+0x40>
     fe8:	60 e2       	ldi	r22, 0x20	; 32
     fea:	84 e0       	ldi	r24, 0x04	; 4
     fec:	90 c0       	rjmp	.+288    	; 0x110e <sysclk_enable_module>
     fee:	08 95       	ret
     ff0:	80 3a       	cpi	r24, 0xA0	; 160
     ff2:	2a e0       	ldi	r18, 0x0A	; 10
     ff4:	92 07       	cpc	r25, r18
     ff6:	21 f4       	brne	.+8      	; 0x1000 <usart_spi_init+0x50>
     ff8:	60 e1       	ldi	r22, 0x10	; 16
     ffa:	85 e0       	ldi	r24, 0x05	; 5
     ffc:	88 c0       	rjmp	.+272    	; 0x110e <sysclk_enable_module>
     ffe:	08 95       	ret
    1000:	80 3a       	cpi	r24, 0xA0	; 160
    1002:	9b 40       	sbci	r25, 0x0B	; 11
    1004:	19 f4       	brne	.+6      	; 0x100c <usart_spi_init+0x5c>
    1006:	60 e1       	ldi	r22, 0x10	; 16
    1008:	86 e0       	ldi	r24, 0x06	; 6
    100a:	81 c0       	rjmp	.+258    	; 0x110e <sysclk_enable_module>
    100c:	08 95       	ret

0000100e <usart_spi_setup_device>:
    100e:	0f 93       	push	r16
    1010:	1f 93       	push	r17
    1012:	cf 93       	push	r28
    1014:	df 93       	push	r29
    1016:	00 d0       	rcall	.+0      	; 0x1018 <usart_spi_setup_device+0xa>
    1018:	00 d0       	rcall	.+0      	; 0x101a <usart_spi_setup_device+0xc>
    101a:	cd b7       	in	r28, 0x3d	; 61
    101c:	de b7       	in	r29, 0x3e	; 62
    101e:	09 83       	std	Y+1, r16	; 0x01
    1020:	1a 83       	std	Y+2, r17	; 0x02
    1022:	2b 83       	std	Y+3, r18	; 0x03
    1024:	3c 83       	std	Y+4, r19	; 0x04
    1026:	4d 83       	std	Y+5, r20	; 0x05
    1028:	1e 82       	std	Y+6, r1	; 0x06
    102a:	be 01       	movw	r22, r28
    102c:	6f 5f       	subi	r22, 0xFF	; 255
    102e:	7f 4f       	sbci	r23, 0xFF	; 255
    1030:	22 de       	rcall	.-956    	; 0xc76 <usart_init_spi>
    1032:	26 96       	adiw	r28, 0x06	; 6
    1034:	cd bf       	out	0x3d, r28	; 61
    1036:	de bf       	out	0x3e, r29	; 62
    1038:	df 91       	pop	r29
    103a:	cf 91       	pop	r28
    103c:	1f 91       	pop	r17
    103e:	0f 91       	pop	r16
    1040:	08 95       	ret

00001042 <usart_spi_select_device>:

void usart_spi_select_device(USART_t *usart, struct usart_spi_device *device)
{
	ioport_set_pin_low(device->id);
    1042:	fb 01       	movw	r30, r22
    1044:	80 81       	ld	r24, Z
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
    1046:	e8 2f       	mov	r30, r24
    1048:	e6 95       	lsr	r30
    104a:	e6 95       	lsr	r30
    104c:	e6 95       	lsr	r30
    104e:	40 e2       	ldi	r20, 0x20	; 32
    1050:	e4 9f       	mul	r30, r20
    1052:	f0 01       	movw	r30, r0
    1054:	11 24       	eor	r1, r1
    1056:	fa 5f       	subi	r31, 0xFA	; 250
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
    1058:	87 70       	andi	r24, 0x07	; 7
    105a:	21 e0       	ldi	r18, 0x01	; 1
    105c:	30 e0       	ldi	r19, 0x00	; 0
    105e:	a9 01       	movw	r20, r18
    1060:	02 c0       	rjmp	.+4      	; 0x1066 <usart_spi_select_device+0x24>
    1062:	44 0f       	add	r20, r20
    1064:	55 1f       	adc	r21, r21
    1066:	8a 95       	dec	r24
    1068:	e2 f7       	brpl	.-8      	; 0x1062 <usart_spi_select_device+0x20>
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
    106a:	46 83       	std	Z+6, r20	; 0x06
    106c:	08 95       	ret

0000106e <usart_spi_deselect_device>:
}

void usart_spi_deselect_device(USART_t *usart, struct usart_spi_device *device)
{
	ioport_set_pin_high(device->id);
    106e:	fb 01       	movw	r30, r22
    1070:	80 81       	ld	r24, Z
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
    1072:	e8 2f       	mov	r30, r24
    1074:	e6 95       	lsr	r30
    1076:	e6 95       	lsr	r30
    1078:	e6 95       	lsr	r30
    107a:	40 e2       	ldi	r20, 0x20	; 32
    107c:	e4 9f       	mul	r30, r20
    107e:	f0 01       	movw	r30, r0
    1080:	11 24       	eor	r1, r1
    1082:	fa 5f       	subi	r31, 0xFA	; 250
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
    1084:	87 70       	andi	r24, 0x07	; 7
    1086:	21 e0       	ldi	r18, 0x01	; 1
    1088:	30 e0       	ldi	r19, 0x00	; 0
    108a:	a9 01       	movw	r20, r18
    108c:	02 c0       	rjmp	.+4      	; 0x1092 <usart_spi_deselect_device+0x24>
    108e:	44 0f       	add	r20, r20
    1090:	55 1f       	adc	r21, r21
    1092:	8a 95       	dec	r24
    1094:	e2 f7       	brpl	.-8      	; 0x108e <usart_spi_deselect_device+0x20>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    1096:	45 83       	std	Z+5, r20	; 0x05
    1098:	08 95       	ret

0000109a <gfx_mono_set_framebuffer>:
	gfx_coord_t *framebuffer_pt = fbpointer +
			((page * GFX_MONO_LCD_WIDTH) + column);
	do {
		*data++ = *framebuffer_pt++;
	} while (--width > 0);
}
    109a:	80 93 34 22 	sts	0x2234, r24	; 0x802234 <fbpointer>
    109e:	90 93 35 22 	sts	0x2235, r25	; 0x802235 <fbpointer+0x1>
    10a2:	08 95       	ret

000010a4 <gfx_mono_framebuffer_put_byte>:
\endcode
 */
void gfx_mono_framebuffer_put_byte(gfx_coord_t page, gfx_coord_t column,
		uint8_t data)
{
	*(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column) = data;
    10a4:	20 91 34 22 	lds	r18, 0x2234	; 0x802234 <fbpointer>
    10a8:	30 91 35 22 	lds	r19, 0x2235	; 0x802235 <fbpointer+0x1>
    10ac:	90 e8       	ldi	r25, 0x80	; 128
    10ae:	89 9f       	mul	r24, r25
    10b0:	20 0d       	add	r18, r0
    10b2:	31 1d       	adc	r19, r1
    10b4:	11 24       	eor	r1, r1
    10b6:	f9 01       	movw	r30, r18
    10b8:	e6 0f       	add	r30, r22
    10ba:	f1 1d       	adc	r31, r1
    10bc:	40 83       	st	Z, r20
    10be:	08 95       	ret

000010c0 <sysclk_init>:
#endif
	bool need_rc2mhz = false;

	/* Turn off all peripheral clocks that can be turned off. */
	for (i = 0; i <= SYSCLK_PORT_F; i++) {
		*(reg++) = 0xff;
    10c0:	8f ef       	ldi	r24, 0xFF	; 255
    10c2:	80 93 70 00 	sts	0x0070, r24	; 0x800070 <__TEXT_REGION_LENGTH__+0x700070>
    10c6:	80 93 71 00 	sts	0x0071, r24	; 0x800071 <__TEXT_REGION_LENGTH__+0x700071>
    10ca:	80 93 72 00 	sts	0x0072, r24	; 0x800072 <__TEXT_REGION_LENGTH__+0x700072>
    10ce:	80 93 73 00 	sts	0x0073, r24	; 0x800073 <__TEXT_REGION_LENGTH__+0x700073>
    10d2:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x700074>
    10d6:	80 93 75 00 	sts	0x0075, r24	; 0x800075 <__TEXT_REGION_LENGTH__+0x700075>
    10da:	80 93 76 00 	sts	0x0076, r24	; 0x800076 <__TEXT_REGION_LENGTH__+0x700076>

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    10de:	9f b7       	in	r25, 0x3f	; 63
	cpu_irq_disable();
    10e0:	f8 94       	cli
	irqflags_t flags;

	Assert(id != OSC_ID_USBSOF);

	flags = cpu_irq_save();
	OSC.CTRL |= id;
    10e2:	e0 e5       	ldi	r30, 0x50	; 80
    10e4:	f0 e0       	ldi	r31, 0x00	; 0
    10e6:	80 81       	ld	r24, Z
    10e8:	82 60       	ori	r24, 0x02	; 2
    10ea:	80 83       	st	Z, r24
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    10ec:	9f bf       	out	0x3f, r25	; 63

static inline bool osc_is_ready(uint8_t id)
{
	Assert(id != OSC_ID_USBSOF);

	return OSC.STATUS & id;
    10ee:	81 81       	ldd	r24, Z+1	; 0x01
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
	while (!osc_is_ready(id)) {
    10f0:	81 ff       	sbrs	r24, 1
    10f2:	fd cf       	rjmp	.-6      	; 0x10ee <sysclk_init+0x2e>
		default:
			//unhandled_case(CONFIG_SYSCLK_SOURCE);
			return;
		}

		ccp_write_io((uint8_t *)&CLK.CTRL, CONFIG_SYSCLK_SOURCE);
    10f4:	61 e0       	ldi	r22, 0x01	; 1
    10f6:	80 e4       	ldi	r24, 0x40	; 64
    10f8:	90 e0       	ldi	r25, 0x00	; 0
    10fa:	15 d0       	rcall	.+42     	; 0x1126 <ccp_write_io>

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    10fc:	9f b7       	in	r25, 0x3f	; 63
	cpu_irq_disable();
    10fe:	f8 94       	cli
	irqflags_t flags;

	Assert(id != OSC_ID_USBSOF);

	flags = cpu_irq_save();
	OSC.CTRL &= ~id;
    1100:	e0 e5       	ldi	r30, 0x50	; 80
    1102:	f0 e0       	ldi	r31, 0x00	; 0
    1104:	80 81       	ld	r24, Z
    1106:	8e 7f       	andi	r24, 0xFE	; 254
    1108:	80 83       	st	Z, r24
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    110a:	9f bf       	out	0x3f, r25	; 63
    110c:	08 95       	ret

0000110e <sysclk_enable_module>:

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    110e:	9f b7       	in	r25, 0x3f	; 63
	cpu_irq_disable();
    1110:	f8 94       	cli

void sysclk_enable_module(enum sysclk_port_id port, uint8_t id)
{
	irqflags_t flags = cpu_irq_save();

	*((uint8_t *)&PR.PRGEN + port) &= ~id;
    1112:	e8 2f       	mov	r30, r24
    1114:	f0 e0       	ldi	r31, 0x00	; 0
    1116:	e0 59       	subi	r30, 0x90	; 144
    1118:	ff 4f       	sbci	r31, 0xFF	; 255
    111a:	60 95       	com	r22
    111c:	80 81       	ld	r24, Z
    111e:	68 23       	and	r22, r24
    1120:	60 83       	st	Z, r22
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    1122:	9f bf       	out	0x3f, r25	; 63
    1124:	08 95       	ret

00001126 <ccp_write_io>:

	PUBLIC_FUNCTION(ccp_write_io)

#if defined(__GNUC__)

	out     RAMPZ, r1               // Reset bits 23:16 of Z
    1126:	1b be       	out	0x3b, r1	; 59
	movw    r30, r24                // Load addr into Z
    1128:	fc 01       	movw	r30, r24
	ldi     r18, CCP_IOREG          // Load magic CCP value
    112a:	28 ed       	ldi	r18, 0xD8	; 216
	out     CCP, r18                // Start CCP handshake
    112c:	24 bf       	out	0x34, r18	; 52
	st      Z, r22                  // Write value to I/O register
    112e:	60 83       	st	Z, r22
	ret                             // Return to caller
    1130:	08 95       	ret

00001132 <ioport_configure_port_pin>:
#include "ioport_compat.h"

#if defined(IOPORT_XMEGA_COMPAT)
void ioport_configure_port_pin(void *port, pin_mask_t pin_mask,
		port_pin_flags_t flags)
{
    1132:	cf 93       	push	r28
    1134:	df 93       	push	r29
    1136:	fc 01       	movw	r30, r24
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
		if (pin_mask & (1 << pin)) {
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
    1138:	20 e0       	ldi	r18, 0x00	; 0
    113a:	30 e0       	ldi	r19, 0x00	; 0
		port_pin_flags_t flags)
{
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
		if (pin_mask & (1 << pin)) {
    113c:	c6 2f       	mov	r28, r22
    113e:	d0 e0       	ldi	r29, 0x00	; 0
    1140:	de 01       	movw	r26, r28
    1142:	02 2e       	mov	r0, r18
    1144:	02 c0       	rjmp	.+4      	; 0x114a <ioport_configure_port_pin+0x18>
    1146:	b5 95       	asr	r27
    1148:	a7 95       	ror	r26
    114a:	0a 94       	dec	r0
    114c:	e2 f7       	brpl	.-8      	; 0x1146 <ioport_configure_port_pin+0x14>
    114e:	a0 fd       	sbrc	r26, 0
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
    1150:	50 8b       	std	Z+16, r21	; 0x10
    1152:	2f 5f       	subi	r18, 0xFF	; 255
    1154:	3f 4f       	sbci	r19, 0xFF	; 255
    1156:	31 96       	adiw	r30, 0x01	; 1
void ioport_configure_port_pin(void *port, pin_mask_t pin_mask,
		port_pin_flags_t flags)
{
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
    1158:	28 30       	cpi	r18, 0x08	; 8
    115a:	31 05       	cpc	r19, r1
    115c:	89 f7       	brne	.-30     	; 0x1140 <ioport_configure_port_pin+0xe>
		if (pin_mask & (1 << pin)) {
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
		}
	}
	/* Select direction and initial pin state */
	if (flags & IOPORT_DIR_OUTPUT) {
    115e:	40 ff       	sbrs	r20, 0
    1160:	0a c0       	rjmp	.+20     	; 0x1176 <ioport_configure_port_pin+0x44>
		if (flags & IOPORT_INIT_HIGH) {
    1162:	41 ff       	sbrs	r20, 1
    1164:	03 c0       	rjmp	.+6      	; 0x116c <ioport_configure_port_pin+0x3a>
			*((uint8_t *)port + PORT_OUTSET) = pin_mask;
    1166:	fc 01       	movw	r30, r24
    1168:	65 83       	std	Z+5, r22	; 0x05
    116a:	02 c0       	rjmp	.+4      	; 0x1170 <ioport_configure_port_pin+0x3e>
		} else {
			*((uint8_t *)port + PORT_OUTCLR) = pin_mask;
    116c:	fc 01       	movw	r30, r24
    116e:	66 83       	std	Z+6, r22	; 0x06
		}

		*((uint8_t *)port + PORT_DIRSET) = pin_mask;
    1170:	fc 01       	movw	r30, r24
    1172:	61 83       	std	Z+1, r22	; 0x01
    1174:	02 c0       	rjmp	.+4      	; 0x117a <ioport_configure_port_pin+0x48>
	} else {
		*((uint8_t *)port + PORT_DIRCLR) = pin_mask;
    1176:	fc 01       	movw	r30, r24
    1178:	62 83       	std	Z+2, r22	; 0x02
	}
}
    117a:	df 91       	pop	r29
    117c:	cf 91       	pop	r28
    117e:	08 95       	ret

00001180 <board_init>:
 * \param flags Bitmask of flags specifying additional configuration
 * parameters.
 */
static inline void ioport_configure_pin(port_pin_t pin, port_pin_flags_t flags)
{
	ioport_configure_port_pin(arch_ioport_pin_to_base(pin),
    1180:	43 e0       	ldi	r20, 0x03	; 3
    1182:	50 e0       	ldi	r21, 0x00	; 0
    1184:	61 e0       	ldi	r22, 0x01	; 1
    1186:	80 ee       	ldi	r24, 0xE0	; 224
    1188:	97 e0       	ldi	r25, 0x07	; 7
    118a:	d3 df       	rcall	.-90     	; 0x1132 <ioport_configure_port_pin>
    118c:	43 e0       	ldi	r20, 0x03	; 3
    118e:	50 e0       	ldi	r21, 0x00	; 0
    1190:	62 e0       	ldi	r22, 0x02	; 2
    1192:	80 ee       	ldi	r24, 0xE0	; 224
    1194:	97 e0       	ldi	r25, 0x07	; 7
    1196:	cd df       	rcall	.-102    	; 0x1132 <ioport_configure_port_pin>
    1198:	43 e0       	ldi	r20, 0x03	; 3
    119a:	50 e0       	ldi	r21, 0x00	; 0
    119c:	60 e1       	ldi	r22, 0x10	; 16
    119e:	80 e6       	ldi	r24, 0x60	; 96
    11a0:	96 e0       	ldi	r25, 0x06	; 6
    11a2:	c7 df       	rcall	.-114    	; 0x1132 <ioport_configure_port_pin>
    11a4:	41 e0       	ldi	r20, 0x01	; 1
    11a6:	50 e4       	ldi	r21, 0x40	; 64
    11a8:	60 e2       	ldi	r22, 0x20	; 32
    11aa:	80 e6       	ldi	r24, 0x60	; 96
    11ac:	96 e0       	ldi	r25, 0x06	; 6
    11ae:	c1 df       	rcall	.-126    	; 0x1132 <ioport_configure_port_pin>
    11b0:	40 e0       	ldi	r20, 0x00	; 0
    11b2:	5b e1       	ldi	r21, 0x1B	; 27
    11b4:	60 e2       	ldi	r22, 0x20	; 32
    11b6:	80 e8       	ldi	r24, 0x80	; 128
    11b8:	96 e0       	ldi	r25, 0x06	; 6
    11ba:	bb df       	rcall	.-138    	; 0x1132 <ioport_configure_port_pin>
    11bc:	40 e0       	ldi	r20, 0x00	; 0
    11be:	5b e1       	ldi	r21, 0x1B	; 27
    11c0:	62 e0       	ldi	r22, 0x02	; 2
    11c2:	80 ea       	ldi	r24, 0xA0	; 160
    11c4:	96 e0       	ldi	r25, 0x06	; 6
    11c6:	b5 df       	rcall	.-150    	; 0x1132 <ioport_configure_port_pin>
    11c8:	40 e0       	ldi	r20, 0x00	; 0
    11ca:	5b e1       	ldi	r21, 0x1B	; 27
    11cc:	64 e0       	ldi	r22, 0x04	; 4
    11ce:	80 ea       	ldi	r24, 0xA0	; 160
    11d0:	96 e0       	ldi	r25, 0x06	; 6
    11d2:	af df       	rcall	.-162    	; 0x1132 <ioport_configure_port_pin>
    11d4:	43 e0       	ldi	r20, 0x03	; 3
    11d6:	50 e0       	ldi	r21, 0x00	; 0
    11d8:	62 e0       	ldi	r22, 0x02	; 2
    11da:	80 e6       	ldi	r24, 0x60	; 96
    11dc:	96 e0       	ldi	r25, 0x06	; 6
    11de:	a9 df       	rcall	.-174    	; 0x1132 <ioport_configure_port_pin>
    11e0:	43 e0       	ldi	r20, 0x03	; 3
    11e2:	50 e0       	ldi	r21, 0x00	; 0
    11e4:	68 e0       	ldi	r22, 0x08	; 8
    11e6:	80 e6       	ldi	r24, 0x60	; 96
    11e8:	96 e0       	ldi	r25, 0x06	; 6
    11ea:	a3 df       	rcall	.-186    	; 0x1132 <ioport_configure_port_pin>
    11ec:	43 e0       	ldi	r20, 0x03	; 3
    11ee:	50 e0       	ldi	r21, 0x00	; 0
    11f0:	68 e0       	ldi	r22, 0x08	; 8
    11f2:	80 ea       	ldi	r24, 0xA0	; 160
    11f4:	96 e0       	ldi	r25, 0x06	; 6
    11f6:	9d df       	rcall	.-198    	; 0x1132 <ioport_configure_port_pin>
    11f8:	43 e0       	ldi	r20, 0x03	; 3
    11fa:	50 e0       	ldi	r21, 0x00	; 0
    11fc:	61 e0       	ldi	r22, 0x01	; 1
    11fe:	80 e6       	ldi	r24, 0x60	; 96
    1200:	96 e0       	ldi	r25, 0x06	; 6
    1202:	97 df       	rcall	.-210    	; 0x1132 <ioport_configure_port_pin>
    1204:	43 e0       	ldi	r20, 0x03	; 3
    1206:	50 e0       	ldi	r21, 0x00	; 0
    1208:	68 e0       	ldi	r22, 0x08	; 8
    120a:	80 e0       	ldi	r24, 0x00	; 0
    120c:	96 e0       	ldi	r25, 0x06	; 6
    120e:	91 df       	rcall	.-222    	; 0x1132 <ioport_configure_port_pin>
    1210:	41 e0       	ldi	r20, 0x01	; 1
    1212:	50 e0       	ldi	r21, 0x00	; 0
    1214:	60 e1       	ldi	r22, 0x10	; 16
    1216:	80 e8       	ldi	r24, 0x80	; 128
    1218:	96 e0       	ldi	r25, 0x06	; 6
    121a:	8b df       	rcall	.-234    	; 0x1132 <ioport_configure_port_pin>
    121c:	43 e0       	ldi	r20, 0x03	; 3
    121e:	50 e0       	ldi	r21, 0x00	; 0
    1220:	62 e0       	ldi	r22, 0x02	; 2
    1222:	80 e6       	ldi	r24, 0x60	; 96
    1224:	96 e0       	ldi	r25, 0x06	; 6
    1226:	85 df       	rcall	.-246    	; 0x1132 <ioport_configure_port_pin>
    1228:	43 e0       	ldi	r20, 0x03	; 3
    122a:	50 e0       	ldi	r21, 0x00	; 0
    122c:	68 e0       	ldi	r22, 0x08	; 8
    122e:	80 e6       	ldi	r24, 0x60	; 96
    1230:	96 e0       	ldi	r25, 0x06	; 6
    1232:	7f df       	rcall	.-258    	; 0x1132 <ioport_configure_port_pin>
    1234:	40 e0       	ldi	r20, 0x00	; 0
    1236:	50 e0       	ldi	r21, 0x00	; 0
    1238:	64 e0       	ldi	r22, 0x04	; 4
    123a:	80 e6       	ldi	r24, 0x60	; 96
    123c:	96 e0       	ldi	r25, 0x06	; 6
    123e:	79 df       	rcall	.-270    	; 0x1132 <ioport_configure_port_pin>
    1240:	43 e0       	ldi	r20, 0x03	; 3
    1242:	50 e0       	ldi	r21, 0x00	; 0
    1244:	60 e1       	ldi	r22, 0x10	; 16
    1246:	80 ea       	ldi	r24, 0xA0	; 160
    1248:	96 e0       	ldi	r25, 0x06	; 6
    124a:	73 df       	rcall	.-282    	; 0x1132 <ioport_configure_port_pin>
    124c:	40 e0       	ldi	r20, 0x00	; 0
    124e:	50 e0       	ldi	r21, 0x00	; 0
    1250:	61 e0       	ldi	r22, 0x01	; 1
    1252:	80 e0       	ldi	r24, 0x00	; 0
    1254:	96 e0       	ldi	r25, 0x06	; 6
    1256:	6d df       	rcall	.-294    	; 0x1132 <ioport_configure_port_pin>
    1258:	40 e0       	ldi	r20, 0x00	; 0
    125a:	50 e0       	ldi	r21, 0x00	; 0
    125c:	64 e0       	ldi	r22, 0x04	; 4
    125e:	80 e0       	ldi	r24, 0x00	; 0
    1260:	96 e0       	ldi	r25, 0x06	; 6
    1262:	67 df       	rcall	.-306    	; 0x1132 <ioport_configure_port_pin>
    1264:	40 e0       	ldi	r20, 0x00	; 0
    1266:	50 e0       	ldi	r21, 0x00	; 0
    1268:	62 e0       	ldi	r22, 0x02	; 2
    126a:	80 e2       	ldi	r24, 0x20	; 32
    126c:	96 e0       	ldi	r25, 0x06	; 6
    126e:	61 df       	rcall	.-318    	; 0x1132 <ioport_configure_port_pin>
    1270:	43 e0       	ldi	r20, 0x03	; 3
    1272:	50 e0       	ldi	r21, 0x00	; 0
    1274:	68 e0       	ldi	r22, 0x08	; 8
    1276:	80 e4       	ldi	r24, 0x40	; 64
    1278:	96 e0       	ldi	r25, 0x06	; 6
    127a:	5b df       	rcall	.-330    	; 0x1132 <ioport_configure_port_pin>
    127c:	40 e0       	ldi	r20, 0x00	; 0
    127e:	50 e0       	ldi	r21, 0x00	; 0
    1280:	64 e0       	ldi	r22, 0x04	; 4
    1282:	80 e4       	ldi	r24, 0x40	; 64
    1284:	96 e0       	ldi	r25, 0x06	; 6
    1286:	55 df       	rcall	.-342    	; 0x1132 <ioport_configure_port_pin>
    1288:	43 e0       	ldi	r20, 0x03	; 3
    128a:	50 e0       	ldi	r21, 0x00	; 0
    128c:	68 e0       	ldi	r22, 0x08	; 8
    128e:	80 e6       	ldi	r24, 0x60	; 96
    1290:	96 e0       	ldi	r25, 0x06	; 6
    1292:	4f df       	rcall	.-354    	; 0x1132 <ioport_configure_port_pin>
    1294:	40 e0       	ldi	r20, 0x00	; 0
    1296:	50 e0       	ldi	r21, 0x00	; 0
    1298:	64 e0       	ldi	r22, 0x04	; 4
    129a:	80 e6       	ldi	r24, 0x60	; 96
    129c:	96 e0       	ldi	r25, 0x06	; 6
    129e:	49 df       	rcall	.-366    	; 0x1132 <ioport_configure_port_pin>
    12a0:	43 e0       	ldi	r20, 0x03	; 3
    12a2:	50 e0       	ldi	r21, 0x00	; 0
    12a4:	68 e0       	ldi	r22, 0x08	; 8
    12a6:	80 e8       	ldi	r24, 0x80	; 128
    12a8:	96 e0       	ldi	r25, 0x06	; 6
    12aa:	43 df       	rcall	.-378    	; 0x1132 <ioport_configure_port_pin>
    12ac:	40 e0       	ldi	r20, 0x00	; 0
    12ae:	50 e0       	ldi	r21, 0x00	; 0
    12b0:	64 e0       	ldi	r22, 0x04	; 4
    12b2:	80 e8       	ldi	r24, 0x80	; 128
    12b4:	96 e0       	ldi	r25, 0x06	; 6
    12b6:	3d cf       	rjmp	.-390    	; 0x1132 <ioport_configure_port_pin>
    12b8:	08 95       	ret

000012ba <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    12ba:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    12bc:	03 96       	adiw	r24, 0x03	; 3
    12be:	81 83       	std	Z+1, r24	; 0x01
    12c0:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    12c2:	2f ef       	ldi	r18, 0xFF	; 255
    12c4:	3f ef       	ldi	r19, 0xFF	; 255
    12c6:	23 83       	std	Z+3, r18	; 0x03
    12c8:	34 83       	std	Z+4, r19	; 0x04

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    12ca:	85 83       	std	Z+5, r24	; 0x05
    12cc:	96 83       	std	Z+6, r25	; 0x06
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    12ce:	87 83       	std	Z+7, r24	; 0x07
    12d0:	90 87       	std	Z+8, r25	; 0x08

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    12d2:	10 82       	st	Z, r1
    12d4:	08 95       	ret

000012d6 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    12d6:	fc 01       	movw	r30, r24
    12d8:	10 86       	std	Z+8, r1	; 0x08
    12da:	11 86       	std	Z+9, r1	; 0x09
    12dc:	08 95       	ret

000012de <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    12de:	cf 93       	push	r28
    12e0:	df 93       	push	r29
    12e2:	9c 01       	movw	r18, r24
    12e4:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    12e6:	dc 01       	movw	r26, r24
    12e8:	11 96       	adiw	r26, 0x01	; 1
    12ea:	cd 91       	ld	r28, X+
    12ec:	dc 91       	ld	r29, X
    12ee:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    12f0:	c2 83       	std	Z+2, r28	; 0x02
    12f2:	d3 83       	std	Z+3, r29	; 0x03
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    12f4:	8c 81       	ldd	r24, Y+4	; 0x04
    12f6:	9d 81       	ldd	r25, Y+5	; 0x05
    12f8:	84 83       	std	Z+4, r24	; 0x04
    12fa:	95 83       	std	Z+5, r25	; 0x05

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    12fc:	8c 81       	ldd	r24, Y+4	; 0x04
    12fe:	9d 81       	ldd	r25, Y+5	; 0x05
    1300:	dc 01       	movw	r26, r24
    1302:	12 96       	adiw	r26, 0x02	; 2
    1304:	6d 93       	st	X+, r22
    1306:	7c 93       	st	X, r23
    1308:	13 97       	sbiw	r26, 0x03	; 3
	pxIndex->pxPrevious = pxNewListItem;
    130a:	6c 83       	std	Y+4, r22	; 0x04
    130c:	7d 83       	std	Y+5, r23	; 0x05

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    130e:	20 87       	std	Z+8, r18	; 0x08
    1310:	31 87       	std	Z+9, r19	; 0x09

	( pxList->uxNumberOfItems )++;
    1312:	f9 01       	movw	r30, r18
    1314:	80 81       	ld	r24, Z
    1316:	8f 5f       	subi	r24, 0xFF	; 255
    1318:	80 83       	st	Z, r24
}
    131a:	df 91       	pop	r29
    131c:	cf 91       	pop	r28
    131e:	08 95       	ret

00001320 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1320:	cf 93       	push	r28
    1322:	df 93       	push	r29
    1324:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1326:	48 81       	ld	r20, Y
    1328:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    132a:	4f 3f       	cpi	r20, 0xFF	; 255
    132c:	2f ef       	ldi	r18, 0xFF	; 255
    132e:	52 07       	cpc	r21, r18
    1330:	21 f4       	brne	.+8      	; 0x133a <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1332:	fc 01       	movw	r30, r24
    1334:	a7 81       	ldd	r26, Z+7	; 0x07
    1336:	b0 85       	ldd	r27, Z+8	; 0x08
    1338:	0d c0       	rjmp	.+26     	; 0x1354 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    133a:	dc 01       	movw	r26, r24
    133c:	13 96       	adiw	r26, 0x03	; 3
    133e:	01 c0       	rjmp	.+2      	; 0x1342 <vListInsert+0x22>
    1340:	df 01       	movw	r26, r30
    1342:	12 96       	adiw	r26, 0x02	; 2
    1344:	ed 91       	ld	r30, X+
    1346:	fc 91       	ld	r31, X
    1348:	13 97       	sbiw	r26, 0x03	; 3
    134a:	20 81       	ld	r18, Z
    134c:	31 81       	ldd	r19, Z+1	; 0x01
    134e:	42 17       	cp	r20, r18
    1350:	53 07       	cpc	r21, r19
    1352:	b0 f7       	brcc	.-20     	; 0x1340 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1354:	12 96       	adiw	r26, 0x02	; 2
    1356:	ed 91       	ld	r30, X+
    1358:	fc 91       	ld	r31, X
    135a:	13 97       	sbiw	r26, 0x03	; 3
    135c:	ea 83       	std	Y+2, r30	; 0x02
    135e:	fb 83       	std	Y+3, r31	; 0x03
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1360:	c4 83       	std	Z+4, r28	; 0x04
    1362:	d5 83       	std	Z+5, r29	; 0x05
	pxNewListItem->pxPrevious = pxIterator;
    1364:	ac 83       	std	Y+4, r26	; 0x04
    1366:	bd 83       	std	Y+5, r27	; 0x05
	pxIterator->pxNext = pxNewListItem;
    1368:	12 96       	adiw	r26, 0x02	; 2
    136a:	cd 93       	st	X+, r28
    136c:	dc 93       	st	X, r29
    136e:	13 97       	sbiw	r26, 0x03	; 3

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1370:	88 87       	std	Y+8, r24	; 0x08
    1372:	99 87       	std	Y+9, r25	; 0x09

	( pxList->uxNumberOfItems )++;
    1374:	fc 01       	movw	r30, r24
    1376:	20 81       	ld	r18, Z
    1378:	2f 5f       	subi	r18, 0xFF	; 255
    137a:	20 83       	st	Z, r18
}
    137c:	df 91       	pop	r29
    137e:	cf 91       	pop	r28
    1380:	08 95       	ret

00001382 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1382:	cf 93       	push	r28
    1384:	df 93       	push	r29
    1386:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    1388:	a0 85       	ldd	r26, Z+8	; 0x08
    138a:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    138c:	c2 81       	ldd	r28, Z+2	; 0x02
    138e:	d3 81       	ldd	r29, Z+3	; 0x03
    1390:	84 81       	ldd	r24, Z+4	; 0x04
    1392:	95 81       	ldd	r25, Z+5	; 0x05
    1394:	8c 83       	std	Y+4, r24	; 0x04
    1396:	9d 83       	std	Y+5, r25	; 0x05
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1398:	c4 81       	ldd	r28, Z+4	; 0x04
    139a:	d5 81       	ldd	r29, Z+5	; 0x05
    139c:	82 81       	ldd	r24, Z+2	; 0x02
    139e:	93 81       	ldd	r25, Z+3	; 0x03
    13a0:	8a 83       	std	Y+2, r24	; 0x02
    13a2:	9b 83       	std	Y+3, r25	; 0x03

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    13a4:	11 96       	adiw	r26, 0x01	; 1
    13a6:	8d 91       	ld	r24, X+
    13a8:	9c 91       	ld	r25, X
    13aa:	12 97       	sbiw	r26, 0x02	; 2
    13ac:	e8 17       	cp	r30, r24
    13ae:	f9 07       	cpc	r31, r25
    13b0:	31 f4       	brne	.+12     	; 0x13be <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    13b2:	84 81       	ldd	r24, Z+4	; 0x04
    13b4:	95 81       	ldd	r25, Z+5	; 0x05
    13b6:	11 96       	adiw	r26, 0x01	; 1
    13b8:	8d 93       	st	X+, r24
    13ba:	9c 93       	st	X, r25
    13bc:	12 97       	sbiw	r26, 0x02	; 2
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    13be:	10 86       	std	Z+8, r1	; 0x08
    13c0:	11 86       	std	Z+9, r1	; 0x09
	( pxList->uxNumberOfItems )--;
    13c2:	8c 91       	ld	r24, X
    13c4:	81 50       	subi	r24, 0x01	; 1
    13c6:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
    13c8:	df 91       	pop	r29
    13ca:	cf 91       	pop	r28
    13cc:	08 95       	ret

000013ce <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    13ce:	0f 93       	push	r16
    13d0:	1f 93       	push	r17
    13d2:	8b 01       	movw	r16, r22
uint16_t usAddress;

    /* Place a few bytes of known values on the bottom of the stack.
    This is just useful for debugging. */

    *pxTopOfStack = 0x11;
    13d4:	71 e1       	ldi	r23, 0x11	; 17
    13d6:	fc 01       	movw	r30, r24
    13d8:	70 83       	st	Z, r23
    pxTopOfStack--;
    *pxTopOfStack = 0x22;
    13da:	31 97       	sbiw	r30, 0x01	; 1
    13dc:	62 e2       	ldi	r22, 0x22	; 34
    13de:	60 83       	st	Z, r22
    pxTopOfStack--;
    *pxTopOfStack = 0x33;
    13e0:	31 97       	sbiw	r30, 0x01	; 1
    13e2:	23 e3       	ldi	r18, 0x33	; 51
    13e4:	20 83       	st	Z, r18

    /*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

    /* The start of the task code will be popped off the stack last, so place
    it on first. */
    ulAddress = ( uint32_t ) pxCode;
    13e6:	01 2e       	mov	r0, r17
    13e8:	00 0c       	add	r0, r0
    13ea:	22 0b       	sbc	r18, r18
    13ec:	33 0b       	sbc	r19, r19
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    13ee:	31 97       	sbiw	r30, 0x01	; 1
    13f0:	00 83       	st	Z, r16
    pxTopOfStack--;

    ulAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    13f2:	31 97       	sbiw	r30, 0x01	; 1
    13f4:	10 83       	st	Z, r17
    pxTopOfStack--;

#ifdef __AVR_3_BYTE_PC__
    ulAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    13f6:	31 97       	sbiw	r30, 0x01	; 1
    13f8:	20 83       	st	Z, r18

    /* Next simulate the stack as if after a call to portSAVE_CONTEXT().
    portSAVE_CONTEXT places the flags on the stack immediately after r0
    to ensure the interrupts get disabled as soon as possible, and so ensuring
    the stack use is minimal should a context switch interrupt occur. */
    *pxTopOfStack = ( StackType_t ) 0x00;   /* R0 */
    13fa:	31 97       	sbiw	r30, 0x01	; 1
    13fc:	10 82       	st	Z, r1
    pxTopOfStack--;
    *pxTopOfStack = portFLAGS_INT_ENABLED;
    13fe:	31 97       	sbiw	r30, 0x01	; 1
    1400:	20 e8       	ldi	r18, 0x80	; 128
    1402:	20 83       	st	Z, r18
    pxTopOfStack--;

    /* Now the remaining registers.   The compiler expects R1 to be 0. */
    *pxTopOfStack = ( StackType_t ) 0x00;   /* R1 */
    1404:	31 97       	sbiw	r30, 0x01	; 1
    1406:	10 82       	st	Z, r1
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x02;   /* R2 */
    1408:	31 97       	sbiw	r30, 0x01	; 1
    140a:	22 e0       	ldi	r18, 0x02	; 2
    140c:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x03;   /* R3 */
    140e:	31 97       	sbiw	r30, 0x01	; 1
    1410:	23 e0       	ldi	r18, 0x03	; 3
    1412:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x04;   /* R4 */
    1414:	31 97       	sbiw	r30, 0x01	; 1
    1416:	24 e0       	ldi	r18, 0x04	; 4
    1418:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x05;   /* R5 */
    141a:	31 97       	sbiw	r30, 0x01	; 1
    141c:	25 e0       	ldi	r18, 0x05	; 5
    141e:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x06;   /* R6 */
    1420:	31 97       	sbiw	r30, 0x01	; 1
    1422:	26 e0       	ldi	r18, 0x06	; 6
    1424:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x07;   /* R7 */
    1426:	31 97       	sbiw	r30, 0x01	; 1
    1428:	27 e0       	ldi	r18, 0x07	; 7
    142a:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x08;   /* R8 */
    142c:	31 97       	sbiw	r30, 0x01	; 1
    142e:	28 e0       	ldi	r18, 0x08	; 8
    1430:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x09;   /* R9 */
    1432:	31 97       	sbiw	r30, 0x01	; 1
    1434:	29 e0       	ldi	r18, 0x09	; 9
    1436:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x10;   /* R10 */
    1438:	31 97       	sbiw	r30, 0x01	; 1
    143a:	20 e1       	ldi	r18, 0x10	; 16
    143c:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x11;   /* R11 */
    143e:	31 97       	sbiw	r30, 0x01	; 1
    1440:	70 83       	st	Z, r23
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x12;   /* R12 */
    1442:	31 97       	sbiw	r30, 0x01	; 1
    1444:	22 e1       	ldi	r18, 0x12	; 18
    1446:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x13;   /* R13 */
    1448:	31 97       	sbiw	r30, 0x01	; 1
    144a:	23 e1       	ldi	r18, 0x13	; 19
    144c:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x14;   /* R14 */
    144e:	31 97       	sbiw	r30, 0x01	; 1
    1450:	24 e1       	ldi	r18, 0x14	; 20
    1452:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x15;   /* R15 */
    1454:	31 97       	sbiw	r30, 0x01	; 1
    1456:	25 e1       	ldi	r18, 0x15	; 21
    1458:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x16;   /* R16 */
    145a:	31 97       	sbiw	r30, 0x01	; 1
    145c:	26 e1       	ldi	r18, 0x16	; 22
    145e:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x17;   /* R17 */
    1460:	31 97       	sbiw	r30, 0x01	; 1
    1462:	27 e1       	ldi	r18, 0x17	; 23
    1464:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x18;   /* R18 */
    1466:	31 97       	sbiw	r30, 0x01	; 1
    1468:	28 e1       	ldi	r18, 0x18	; 24
    146a:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x19;   /* R19 */
    146c:	31 97       	sbiw	r30, 0x01	; 1
    146e:	29 e1       	ldi	r18, 0x19	; 25
    1470:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x20;   /* R20 */
    1472:	31 97       	sbiw	r30, 0x01	; 1
    1474:	20 e2       	ldi	r18, 0x20	; 32
    1476:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x21;   /* R21 */
    1478:	31 97       	sbiw	r30, 0x01	; 1
    147a:	21 e2       	ldi	r18, 0x21	; 33
    147c:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x22;   /* R22 */
    147e:	31 97       	sbiw	r30, 0x01	; 1
    1480:	60 83       	st	Z, r22
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x23;   /* R23 */
    1482:	31 97       	sbiw	r30, 0x01	; 1
    1484:	23 e2       	ldi	r18, 0x23	; 35
    1486:	20 83       	st	Z, r18
    pxTopOfStack--;

    /* Place the parameter on the stack in the expected location. */
    usAddress = ( uint16_t ) pvParameters;
    *pxTopOfStack = ( StackType_t ) ( usAddress & ( uint32_t ) 0x000000ff );
    1488:	31 97       	sbiw	r30, 0x01	; 1
    148a:	40 83       	st	Z, r20
    pxTopOfStack--;

    usAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( usAddress & ( uint32_t ) 0x000000ff );
    148c:	31 97       	sbiw	r30, 0x01	; 1
    148e:	50 83       	st	Z, r21
    pxTopOfStack--;

    *pxTopOfStack = ( StackType_t ) 0x26;   /* R26 X */
    1490:	31 97       	sbiw	r30, 0x01	; 1
    1492:	26 e2       	ldi	r18, 0x26	; 38
    1494:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x27;   /* R27 */
    1496:	31 97       	sbiw	r30, 0x01	; 1
    1498:	27 e2       	ldi	r18, 0x27	; 39
    149a:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x28;   /* R28 Y */
    149c:	31 97       	sbiw	r30, 0x01	; 1
    149e:	28 e2       	ldi	r18, 0x28	; 40
    14a0:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x29;   /* R29 */
    14a2:	31 97       	sbiw	r30, 0x01	; 1
    14a4:	29 e2       	ldi	r18, 0x29	; 41
    14a6:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x30;   /* R30 Z */
    14a8:	31 97       	sbiw	r30, 0x01	; 1
    14aa:	20 e3       	ldi	r18, 0x30	; 48
    14ac:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x31;   /* R31 */
    14ae:	31 97       	sbiw	r30, 0x01	; 1
    14b0:	21 e3       	ldi	r18, 0x31	; 49
    14b2:	20 83       	st	Z, r18
    pxTopOfStack--;

    /*lint +e950 +e611 +e923 */

    return pxTopOfStack;
}
    14b4:	87 97       	sbiw	r24, 0x27	; 39
    14b6:	1f 91       	pop	r17
    14b8:	0f 91       	pop	r16
    14ba:	08 95       	ret

000014bc <xPortStartScheduler>:
 * Setup timer generate a tick interrupt.
 */
static void prvSetupTimerInterrupt(void)
{
    // disable global interrupt for a moment
    cli();
    14bc:	f8 94       	cli

    {
        //enable TC0 clock source, high resolution
        PR.PRPC &= ~(PR_TC0_bm | PR_HIRES_bm);
    14be:	e0 e7       	ldi	r30, 0x70	; 112
    14c0:	f0 e0       	ldi	r31, 0x00	; 0
    14c2:	83 81       	ldd	r24, Z+3	; 0x03
    14c4:	8a 7f       	andi	r24, 0xFA	; 250
    14c6:	83 83       	std	Z+3, r24	; 0x03

        //set period of counter
        TCC0.PER = configCPU_CLOCK_HZ / configTICK_RATE_HZ / 1;
    14c8:	e0 e0       	ldi	r30, 0x00	; 0
    14ca:	f8 e0       	ldi	r31, 0x08	; 8
    14cc:	80 e0       	ldi	r24, 0x00	; 0
    14ce:	9a ef       	ldi	r25, 0xFA	; 250
    14d0:	86 a3       	std	Z+38, r24	; 0x26
    14d2:	97 a3       	std	Z+39, r25	; 0x27

        //enable interrupt and set low level
        TCC0.INTCTRLA = TC_OVFINTLVL_LO_gc;
    14d4:	91 e0       	ldi	r25, 0x01	; 1
    14d6:	96 83       	std	Z+6, r25	; 0x06

        //enable low-level interrupt
        PMIC.CTRL |= PMIC_LOLVLEN_bm;
    14d8:	a0 ea       	ldi	r26, 0xA0	; 160
    14da:	b0 e0       	ldi	r27, 0x00	; 0
    14dc:	12 96       	adiw	r26, 0x02	; 2
    14de:	8c 91       	ld	r24, X
    14e0:	12 97       	sbiw	r26, 0x02	; 2
    14e2:	81 60       	ori	r24, 0x01	; 1
    14e4:	12 96       	adiw	r26, 0x02	; 2
    14e6:	8c 93       	st	X, r24

        //select (start) the clock source
        TCC0.CTRLA = TC_CLKSEL_DIV1_gc;
    14e8:	90 83       	st	Z, r25

    }

    // enable global interrupt
    sei();
    14ea:	78 94       	sei
{
    /* Setup the hardware to generate the tick. */
    prvSetupTimerInterrupt();

    /* Restore the context of the first task that is going to run. */
    portRESTORE_CONTEXT();
    14ec:	a0 91 8e 22 	lds	r26, 0x228E	; 0x80228e <pxCurrentTCB>
    14f0:	b0 91 8f 22 	lds	r27, 0x228F	; 0x80228f <pxCurrentTCB+0x1>
    14f4:	0d 90       	ld	r0, X+
    14f6:	0d be       	out	0x3d, r0	; 61
    14f8:	0d 90       	ld	r0, X+
    14fa:	0e be       	out	0x3e, r0	; 62
    14fc:	ff 91       	pop	r31
    14fe:	ef 91       	pop	r30
    1500:	df 91       	pop	r29
    1502:	cf 91       	pop	r28
    1504:	bf 91       	pop	r27
    1506:	af 91       	pop	r26
    1508:	9f 91       	pop	r25
    150a:	8f 91       	pop	r24
    150c:	7f 91       	pop	r23
    150e:	6f 91       	pop	r22
    1510:	5f 91       	pop	r21
    1512:	4f 91       	pop	r20
    1514:	3f 91       	pop	r19
    1516:	2f 91       	pop	r18
    1518:	1f 91       	pop	r17
    151a:	0f 91       	pop	r16
    151c:	ff 90       	pop	r15
    151e:	ef 90       	pop	r14
    1520:	df 90       	pop	r13
    1522:	cf 90       	pop	r12
    1524:	bf 90       	pop	r11
    1526:	af 90       	pop	r10
    1528:	9f 90       	pop	r9
    152a:	8f 90       	pop	r8
    152c:	7f 90       	pop	r7
    152e:	6f 90       	pop	r6
    1530:	5f 90       	pop	r5
    1532:	4f 90       	pop	r4
    1534:	3f 90       	pop	r3
    1536:	2f 90       	pop	r2
    1538:	1f 90       	pop	r1
    153a:	0f 90       	pop	r0
    153c:	0f be       	out	0x3f, r0	; 63
    153e:	0f 90       	pop	r0

    /* Simulate a function call end as generated by the compiler.  We will now
    jump to the start of the task the context of which we have just restored. */
    asm volatile ( "ret" );
    1540:	08 95       	ret

    /* Should not get here. */
    return pdTRUE;
}
    1542:	81 e0       	ldi	r24, 0x01	; 1
    1544:	08 95       	ret

00001546 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
    portSAVE_CONTEXT();
    1546:	0f 92       	push	r0
    1548:	0f b6       	in	r0, 0x3f	; 63
    154a:	f8 94       	cli
    154c:	0f 92       	push	r0
    154e:	1f 92       	push	r1
    1550:	11 24       	eor	r1, r1
    1552:	2f 92       	push	r2
    1554:	3f 92       	push	r3
    1556:	4f 92       	push	r4
    1558:	5f 92       	push	r5
    155a:	6f 92       	push	r6
    155c:	7f 92       	push	r7
    155e:	8f 92       	push	r8
    1560:	9f 92       	push	r9
    1562:	af 92       	push	r10
    1564:	bf 92       	push	r11
    1566:	cf 92       	push	r12
    1568:	df 92       	push	r13
    156a:	ef 92       	push	r14
    156c:	ff 92       	push	r15
    156e:	0f 93       	push	r16
    1570:	1f 93       	push	r17
    1572:	2f 93       	push	r18
    1574:	3f 93       	push	r19
    1576:	4f 93       	push	r20
    1578:	5f 93       	push	r21
    157a:	6f 93       	push	r22
    157c:	7f 93       	push	r23
    157e:	8f 93       	push	r24
    1580:	9f 93       	push	r25
    1582:	af 93       	push	r26
    1584:	bf 93       	push	r27
    1586:	cf 93       	push	r28
    1588:	df 93       	push	r29
    158a:	ef 93       	push	r30
    158c:	ff 93       	push	r31
    158e:	a0 91 8e 22 	lds	r26, 0x228E	; 0x80228e <pxCurrentTCB>
    1592:	b0 91 8f 22 	lds	r27, 0x228F	; 0x80228f <pxCurrentTCB+0x1>
    1596:	0d b6       	in	r0, 0x3d	; 61
    1598:	0d 92       	st	X+, r0
    159a:	0e b6       	in	r0, 0x3e	; 62
    vTaskSwitchContext();
    159c:	0d 92       	st	X+, r0
    portRESTORE_CONTEXT();
    159e:	0e d6       	rcall	.+3100   	; 0x21bc <vTaskSwitchContext>
    15a0:	a0 91 8e 22 	lds	r26, 0x228E	; 0x80228e <pxCurrentTCB>
    15a4:	b0 91 8f 22 	lds	r27, 0x228F	; 0x80228f <pxCurrentTCB+0x1>
    15a8:	0d 90       	ld	r0, X+
    15aa:	0d be       	out	0x3d, r0	; 61
    15ac:	0d 90       	ld	r0, X+
    15ae:	0e be       	out	0x3e, r0	; 62
    15b0:	ff 91       	pop	r31
    15b2:	ef 91       	pop	r30
    15b4:	df 91       	pop	r29
    15b6:	cf 91       	pop	r28
    15b8:	bf 91       	pop	r27
    15ba:	af 91       	pop	r26
    15bc:	9f 91       	pop	r25
    15be:	8f 91       	pop	r24
    15c0:	7f 91       	pop	r23
    15c2:	6f 91       	pop	r22
    15c4:	5f 91       	pop	r21
    15c6:	4f 91       	pop	r20
    15c8:	3f 91       	pop	r19
    15ca:	2f 91       	pop	r18
    15cc:	1f 91       	pop	r17
    15ce:	0f 91       	pop	r16
    15d0:	ff 90       	pop	r15
    15d2:	ef 90       	pop	r14
    15d4:	df 90       	pop	r13
    15d6:	cf 90       	pop	r12
    15d8:	bf 90       	pop	r11
    15da:	af 90       	pop	r10
    15dc:	9f 90       	pop	r9
    15de:	8f 90       	pop	r8
    15e0:	7f 90       	pop	r7
    15e2:	6f 90       	pop	r6
    15e4:	5f 90       	pop	r5
    15e6:	4f 90       	pop	r4
    15e8:	3f 90       	pop	r3
    15ea:	2f 90       	pop	r2
    15ec:	1f 90       	pop	r1
    15ee:	0f 90       	pop	r0
    15f0:	0f be       	out	0x3f, r0	; 63

    asm volatile ( "ret" );
    15f2:	0f 90       	pop	r0
    15f4:	08 95       	ret

000015f6 <__vector_14>:
         * Context switch function used by the tick.  This must be identical to
         * vPortYield() from the call to vTaskSwitchContext() onwards.  The only
         * difference from vPortYield() is the tick count is incremented as the
         * call comes from the tick ISR.
         */
        portSAVE_CONTEXT();
    15f6:	0f 92       	push	r0
    15f8:	0f b6       	in	r0, 0x3f	; 63
    15fa:	f8 94       	cli
    15fc:	0f 92       	push	r0
    15fe:	1f 92       	push	r1
    1600:	11 24       	eor	r1, r1
    1602:	2f 92       	push	r2
    1604:	3f 92       	push	r3
    1606:	4f 92       	push	r4
    1608:	5f 92       	push	r5
    160a:	6f 92       	push	r6
    160c:	7f 92       	push	r7
    160e:	8f 92       	push	r8
    1610:	9f 92       	push	r9
    1612:	af 92       	push	r10
    1614:	bf 92       	push	r11
    1616:	cf 92       	push	r12
    1618:	df 92       	push	r13
    161a:	ef 92       	push	r14
    161c:	ff 92       	push	r15
    161e:	0f 93       	push	r16
    1620:	1f 93       	push	r17
    1622:	2f 93       	push	r18
    1624:	3f 93       	push	r19
    1626:	4f 93       	push	r20
    1628:	5f 93       	push	r21
    162a:	6f 93       	push	r22
    162c:	7f 93       	push	r23
    162e:	8f 93       	push	r24
    1630:	9f 93       	push	r25
    1632:	af 93       	push	r26
    1634:	bf 93       	push	r27
    1636:	cf 93       	push	r28
    1638:	df 93       	push	r29
    163a:	ef 93       	push	r30
    163c:	ff 93       	push	r31
    163e:	a0 91 8e 22 	lds	r26, 0x228E	; 0x80228e <pxCurrentTCB>
    1642:	b0 91 8f 22 	lds	r27, 0x228F	; 0x80228f <pxCurrentTCB+0x1>
    1646:	0d b6       	in	r0, 0x3d	; 61
    1648:	0d 92       	st	X+, r0
    164a:	0e b6       	in	r0, 0x3e	; 62
        if( xTaskIncrementTick() != pdFALSE )
    164c:	0d 92       	st	X+, r0
        {
            vTaskSwitchContext();
    164e:	4b d4       	rcall	.+2198   	; 0x1ee6 <xTaskIncrementTick>
    1650:	81 11       	cpse	r24, r1
        }
        portRESTORE_CONTEXT();
    1652:	b4 d5       	rcall	.+2920   	; 0x21bc <vTaskSwitchContext>
    1654:	a0 91 8e 22 	lds	r26, 0x228E	; 0x80228e <pxCurrentTCB>
    1658:	b0 91 8f 22 	lds	r27, 0x228F	; 0x80228f <pxCurrentTCB+0x1>
    165c:	0d 90       	ld	r0, X+
    165e:	0d be       	out	0x3d, r0	; 61
    1660:	0d 90       	ld	r0, X+
    1662:	0e be       	out	0x3e, r0	; 62
    1664:	ff 91       	pop	r31
    1666:	ef 91       	pop	r30
    1668:	df 91       	pop	r29
    166a:	cf 91       	pop	r28
    166c:	bf 91       	pop	r27
    166e:	af 91       	pop	r26
    1670:	9f 91       	pop	r25
    1672:	8f 91       	pop	r24
    1674:	7f 91       	pop	r23
    1676:	6f 91       	pop	r22
    1678:	5f 91       	pop	r21
    167a:	4f 91       	pop	r20
    167c:	3f 91       	pop	r19
    167e:	2f 91       	pop	r18
    1680:	1f 91       	pop	r17
    1682:	0f 91       	pop	r16
    1684:	ff 90       	pop	r15
    1686:	ef 90       	pop	r14
    1688:	df 90       	pop	r13
    168a:	cf 90       	pop	r12
    168c:	bf 90       	pop	r11
    168e:	af 90       	pop	r10
    1690:	9f 90       	pop	r9
    1692:	8f 90       	pop	r8
    1694:	7f 90       	pop	r7
    1696:	6f 90       	pop	r6
    1698:	5f 90       	pop	r5
    169a:	4f 90       	pop	r4
    169c:	3f 90       	pop	r3
    169e:	2f 90       	pop	r2
    16a0:	1f 90       	pop	r1
    16a2:	0f 90       	pop	r0
    16a4:	0f be       	out	0x3f, r0	; 63

        asm volatile ( "reti" );
    16a6:	0f 90       	pop	r0
    16a8:	18 95       	reti

000016aa <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    16aa:	cf 93       	push	r28
    16ac:	df 93       	push	r29
void *pvReturn;

	vTaskSuspendAll();
    16ae:	ec 01       	movw	r28, r24
	{
		pvReturn = malloc( xWantedSize );
    16b0:	0a d4       	rcall	.+2068   	; 0x1ec6 <vTaskSuspendAll>
    16b2:	ce 01       	movw	r24, r28
    16b4:	0e 94 21 15 	call	0x2a42	; 0x2a42 <malloc>
		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    16b8:	ec 01       	movw	r28, r24
		}
	}
	#endif

	return pvReturn;
}
    16ba:	e8 d4       	rcall	.+2512   	; 0x208c <xTaskResumeAll>
    16bc:	ce 01       	movw	r24, r28
    16be:	df 91       	pop	r29
    16c0:	cf 91       	pop	r28
    16c2:	08 95       	ret

000016c4 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    16c4:	cf 93       	push	r28
    16c6:	df 93       	push	r29
	if( pv )
    16c8:	00 97       	sbiw	r24, 0x00	; 0
    16ca:	31 f0       	breq	.+12     	; 0x16d8 <vPortFree+0x14>
	{
		vTaskSuspendAll();
    16cc:	ec 01       	movw	r28, r24
		{
			free( pv );
    16ce:	fb d3       	rcall	.+2038   	; 0x1ec6 <vTaskSuspendAll>
    16d0:	ce 01       	movw	r24, r28
			traceFREE( pv, 0 );
		}
		( void ) xTaskResumeAll();
    16d2:	0e 94 b9 15 	call	0x2b72	; 0x2b72 <free>
	}
}
    16d6:	da d4       	rcall	.+2484   	; 0x208c <xTaskResumeAll>
    16d8:	df 91       	pop	r29
    16da:	cf 91       	pop	r28
    16dc:	08 95       	ret

000016de <prvCopyDataToQueue>:
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    16de:	1f 93       	push	r17
    16e0:	cf 93       	push	r28
    16e2:	df 93       	push	r29
    16e4:	ec 01       	movw	r28, r24
    16e6:	14 2f       	mov	r17, r20
    16e8:	4c 8d       	ldd	r20, Y+28	; 0x1c
    16ea:	44 23       	and	r20, r20
    16ec:	d9 f1       	breq	.+118    	; 0x1764 <prvCopyDataToQueue+0x86>
    16ee:	11 11       	cpse	r17, r1
    16f0:	16 c0       	rjmp	.+44     	; 0x171e <prvCopyDataToQueue+0x40>
    16f2:	50 e0       	ldi	r21, 0x00	; 0
    16f4:	8c 81       	ldd	r24, Y+4	; 0x04
    16f6:	9d 81       	ldd	r25, Y+5	; 0x05
    16f8:	0e 94 42 16 	call	0x2c84	; 0x2c84 <memcpy>
    16fc:	2c 8d       	ldd	r18, Y+28	; 0x1c
    16fe:	8c 81       	ldd	r24, Y+4	; 0x04
    1700:	9d 81       	ldd	r25, Y+5	; 0x05
    1702:	82 0f       	add	r24, r18
    1704:	91 1d       	adc	r25, r1
    1706:	8c 83       	std	Y+4, r24	; 0x04
    1708:	9d 83       	std	Y+5, r25	; 0x05
    170a:	2a 81       	ldd	r18, Y+2	; 0x02
    170c:	3b 81       	ldd	r19, Y+3	; 0x03
    170e:	82 17       	cp	r24, r18
    1710:	93 07       	cpc	r25, r19
    1712:	40 f1       	brcs	.+80     	; 0x1764 <prvCopyDataToQueue+0x86>
    1714:	88 81       	ld	r24, Y
    1716:	99 81       	ldd	r25, Y+1	; 0x01
    1718:	8c 83       	std	Y+4, r24	; 0x04
    171a:	9d 83       	std	Y+5, r25	; 0x05
    171c:	23 c0       	rjmp	.+70     	; 0x1764 <prvCopyDataToQueue+0x86>
    171e:	50 e0       	ldi	r21, 0x00	; 0
    1720:	8e 81       	ldd	r24, Y+6	; 0x06
    1722:	9f 81       	ldd	r25, Y+7	; 0x07
    1724:	0e 94 42 16 	call	0x2c84	; 0x2c84 <memcpy>
    1728:	8c 8d       	ldd	r24, Y+28	; 0x1c
    172a:	90 e0       	ldi	r25, 0x00	; 0
    172c:	91 95       	neg	r25
    172e:	81 95       	neg	r24
    1730:	91 09       	sbc	r25, r1
    1732:	2e 81       	ldd	r18, Y+6	; 0x06
    1734:	3f 81       	ldd	r19, Y+7	; 0x07
    1736:	28 0f       	add	r18, r24
    1738:	39 1f       	adc	r19, r25
    173a:	2e 83       	std	Y+6, r18	; 0x06
    173c:	3f 83       	std	Y+7, r19	; 0x07
    173e:	48 81       	ld	r20, Y
    1740:	59 81       	ldd	r21, Y+1	; 0x01
    1742:	24 17       	cp	r18, r20
    1744:	35 07       	cpc	r19, r21
    1746:	30 f4       	brcc	.+12     	; 0x1754 <prvCopyDataToQueue+0x76>
    1748:	2a 81       	ldd	r18, Y+2	; 0x02
    174a:	3b 81       	ldd	r19, Y+3	; 0x03
    174c:	82 0f       	add	r24, r18
    174e:	93 1f       	adc	r25, r19
    1750:	8e 83       	std	Y+6, r24	; 0x06
    1752:	9f 83       	std	Y+7, r25	; 0x07
    1754:	12 30       	cpi	r17, 0x02	; 2
    1756:	31 f4       	brne	.+12     	; 0x1764 <prvCopyDataToQueue+0x86>
    1758:	8a 8d       	ldd	r24, Y+26	; 0x1a
    175a:	88 23       	and	r24, r24
    175c:	19 f0       	breq	.+6      	; 0x1764 <prvCopyDataToQueue+0x86>
    175e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1760:	81 50       	subi	r24, 0x01	; 1
    1762:	8a 8f       	std	Y+26, r24	; 0x1a
    1764:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1766:	8f 5f       	subi	r24, 0xFF	; 255
    1768:	8a 8f       	std	Y+26, r24	; 0x1a
    176a:	80 e0       	ldi	r24, 0x00	; 0
    176c:	df 91       	pop	r29
    176e:	cf 91       	pop	r28
    1770:	1f 91       	pop	r17
    1772:	08 95       	ret

00001774 <prvCopyDataFromQueue>:
    1774:	fc 01       	movw	r30, r24
    1776:	44 8d       	ldd	r20, Z+28	; 0x1c
    1778:	44 23       	and	r20, r20
    177a:	a9 f0       	breq	.+42     	; 0x17a6 <prvCopyDataFromQueue+0x32>
    177c:	50 e0       	ldi	r21, 0x00	; 0
    177e:	26 81       	ldd	r18, Z+6	; 0x06
    1780:	37 81       	ldd	r19, Z+7	; 0x07
    1782:	24 0f       	add	r18, r20
    1784:	35 1f       	adc	r19, r21
    1786:	26 83       	std	Z+6, r18	; 0x06
    1788:	37 83       	std	Z+7, r19	; 0x07
    178a:	82 81       	ldd	r24, Z+2	; 0x02
    178c:	93 81       	ldd	r25, Z+3	; 0x03
    178e:	28 17       	cp	r18, r24
    1790:	39 07       	cpc	r19, r25
    1792:	20 f0       	brcs	.+8      	; 0x179c <prvCopyDataFromQueue+0x28>
    1794:	80 81       	ld	r24, Z
    1796:	91 81       	ldd	r25, Z+1	; 0x01
    1798:	86 83       	std	Z+6, r24	; 0x06
    179a:	97 83       	std	Z+7, r25	; 0x07
    179c:	cb 01       	movw	r24, r22
    179e:	66 81       	ldd	r22, Z+6	; 0x06
    17a0:	77 81       	ldd	r23, Z+7	; 0x07
    17a2:	0c 94 42 16 	jmp	0x2c84	; 0x2c84 <memcpy>
    17a6:	08 95       	ret

000017a8 <prvUnlockQueue>:
    17a8:	0f 93       	push	r16
    17aa:	1f 93       	push	r17
    17ac:	cf 93       	push	r28
    17ae:	df 93       	push	r29
    17b0:	ec 01       	movw	r28, r24
    17b2:	0f b6       	in	r0, 0x3f	; 63
    17b4:	f8 94       	cli
    17b6:	0f 92       	push	r0
    17b8:	8e 8d       	ldd	r24, Y+30	; 0x1e
    17ba:	18 16       	cp	r1, r24
    17bc:	ac f4       	brge	.+42     	; 0x17e8 <prvUnlockQueue+0x40>
    17be:	89 89       	ldd	r24, Y+17	; 0x11
    17c0:	81 11       	cpse	r24, r1
    17c2:	05 c0       	rjmp	.+10     	; 0x17ce <prvUnlockQueue+0x26>
    17c4:	11 c0       	rjmp	.+34     	; 0x17e8 <prvUnlockQueue+0x40>
    17c6:	89 89       	ldd	r24, Y+17	; 0x11
    17c8:	81 11       	cpse	r24, r1
    17ca:	04 c0       	rjmp	.+8      	; 0x17d4 <prvUnlockQueue+0x2c>
    17cc:	0d c0       	rjmp	.+26     	; 0x17e8 <prvUnlockQueue+0x40>
    17ce:	8e 01       	movw	r16, r28
    17d0:	0f 5e       	subi	r16, 0xEF	; 239
    17d2:	1f 4f       	sbci	r17, 0xFF	; 255
    17d4:	c8 01       	movw	r24, r16
    17d6:	93 d5       	rcall	.+2854   	; 0x22fe <xTaskRemoveFromEventList>
    17d8:	81 11       	cpse	r24, r1
    17da:	13 d6       	rcall	.+3110   	; 0x2402 <vTaskMissedYield>
    17dc:	8e 8d       	ldd	r24, Y+30	; 0x1e
    17de:	81 50       	subi	r24, 0x01	; 1
    17e0:	8e 8f       	std	Y+30, r24	; 0x1e
    17e2:	8e 8d       	ldd	r24, Y+30	; 0x1e
    17e4:	18 16       	cp	r1, r24
    17e6:	7c f3       	brlt	.-34     	; 0x17c6 <prvUnlockQueue+0x1e>
    17e8:	8f ef       	ldi	r24, 0xFF	; 255
    17ea:	8e 8f       	std	Y+30, r24	; 0x1e
    17ec:	0f 90       	pop	r0
    17ee:	0f be       	out	0x3f, r0	; 63
    17f0:	0f b6       	in	r0, 0x3f	; 63
    17f2:	f8 94       	cli
    17f4:	0f 92       	push	r0
    17f6:	8d 8d       	ldd	r24, Y+29	; 0x1d
    17f8:	18 16       	cp	r1, r24
    17fa:	ac f4       	brge	.+42     	; 0x1826 <prvUnlockQueue+0x7e>
    17fc:	88 85       	ldd	r24, Y+8	; 0x08
    17fe:	81 11       	cpse	r24, r1
    1800:	05 c0       	rjmp	.+10     	; 0x180c <prvUnlockQueue+0x64>
    1802:	11 c0       	rjmp	.+34     	; 0x1826 <prvUnlockQueue+0x7e>
    1804:	88 85       	ldd	r24, Y+8	; 0x08
    1806:	81 11       	cpse	r24, r1
    1808:	04 c0       	rjmp	.+8      	; 0x1812 <prvUnlockQueue+0x6a>
    180a:	0d c0       	rjmp	.+26     	; 0x1826 <prvUnlockQueue+0x7e>
    180c:	8e 01       	movw	r16, r28
    180e:	08 5f       	subi	r16, 0xF8	; 248
    1810:	1f 4f       	sbci	r17, 0xFF	; 255
    1812:	c8 01       	movw	r24, r16
    1814:	74 d5       	rcall	.+2792   	; 0x22fe <xTaskRemoveFromEventList>
    1816:	81 11       	cpse	r24, r1
    1818:	f4 d5       	rcall	.+3048   	; 0x2402 <vTaskMissedYield>
    181a:	8d 8d       	ldd	r24, Y+29	; 0x1d
    181c:	81 50       	subi	r24, 0x01	; 1
    181e:	8d 8f       	std	Y+29, r24	; 0x1d
    1820:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1822:	18 16       	cp	r1, r24
    1824:	7c f3       	brlt	.-34     	; 0x1804 <prvUnlockQueue+0x5c>
    1826:	8f ef       	ldi	r24, 0xFF	; 255
    1828:	8d 8f       	std	Y+29, r24	; 0x1d
    182a:	0f 90       	pop	r0
    182c:	0f be       	out	0x3f, r0	; 63
    182e:	df 91       	pop	r29
    1830:	cf 91       	pop	r28
    1832:	1f 91       	pop	r17
    1834:	0f 91       	pop	r16
    1836:	08 95       	ret

00001838 <xQueueGenericReset>:
    1838:	cf 93       	push	r28
    183a:	df 93       	push	r29
    183c:	ec 01       	movw	r28, r24
    183e:	0f b6       	in	r0, 0x3f	; 63
    1840:	f8 94       	cli
    1842:	0f 92       	push	r0
    1844:	48 81       	ld	r20, Y
    1846:	59 81       	ldd	r21, Y+1	; 0x01
    1848:	2c 8d       	ldd	r18, Y+28	; 0x1c
    184a:	30 e0       	ldi	r19, 0x00	; 0
    184c:	7b 8d       	ldd	r23, Y+27	; 0x1b
    184e:	72 9f       	mul	r23, r18
    1850:	c0 01       	movw	r24, r0
    1852:	73 9f       	mul	r23, r19
    1854:	90 0d       	add	r25, r0
    1856:	11 24       	eor	r1, r1
    1858:	fa 01       	movw	r30, r20
    185a:	e8 0f       	add	r30, r24
    185c:	f9 1f       	adc	r31, r25
    185e:	ea 83       	std	Y+2, r30	; 0x02
    1860:	fb 83       	std	Y+3, r31	; 0x03
    1862:	1a 8e       	std	Y+26, r1	; 0x1a
    1864:	4c 83       	std	Y+4, r20	; 0x04
    1866:	5d 83       	std	Y+5, r21	; 0x05
    1868:	82 1b       	sub	r24, r18
    186a:	93 0b       	sbc	r25, r19
    186c:	84 0f       	add	r24, r20
    186e:	95 1f       	adc	r25, r21
    1870:	8e 83       	std	Y+6, r24	; 0x06
    1872:	9f 83       	std	Y+7, r25	; 0x07
    1874:	8f ef       	ldi	r24, 0xFF	; 255
    1876:	8d 8f       	std	Y+29, r24	; 0x1d
    1878:	8e 8f       	std	Y+30, r24	; 0x1e
    187a:	61 11       	cpse	r22, r1
    187c:	0a c0       	rjmp	.+20     	; 0x1892 <xQueueGenericReset+0x5a>
    187e:	88 85       	ldd	r24, Y+8	; 0x08
    1880:	88 23       	and	r24, r24
    1882:	69 f0       	breq	.+26     	; 0x189e <xQueueGenericReset+0x66>
    1884:	ce 01       	movw	r24, r28
    1886:	08 96       	adiw	r24, 0x08	; 8
    1888:	3a d5       	rcall	.+2676   	; 0x22fe <xTaskRemoveFromEventList>
    188a:	81 30       	cpi	r24, 0x01	; 1
    188c:	41 f4       	brne	.+16     	; 0x189e <xQueueGenericReset+0x66>
    188e:	5b de       	rcall	.-842    	; 0x1546 <vPortYield>
    1890:	06 c0       	rjmp	.+12     	; 0x189e <xQueueGenericReset+0x66>
    1892:	ce 01       	movw	r24, r28
    1894:	08 96       	adiw	r24, 0x08	; 8
    1896:	11 dd       	rcall	.-1502   	; 0x12ba <vListInitialise>
    1898:	ce 01       	movw	r24, r28
    189a:	41 96       	adiw	r24, 0x11	; 17
    189c:	0e dd       	rcall	.-1508   	; 0x12ba <vListInitialise>
    189e:	0f 90       	pop	r0
    18a0:	0f be       	out	0x3f, r0	; 63
    18a2:	81 e0       	ldi	r24, 0x01	; 1
    18a4:	df 91       	pop	r29
    18a6:	cf 91       	pop	r28
    18a8:	08 95       	ret

000018aa <xQueueGenericCreate>:
    18aa:	0f 93       	push	r16
    18ac:	1f 93       	push	r17
    18ae:	cf 93       	push	r28
    18b0:	df 93       	push	r29
    18b2:	08 2f       	mov	r16, r24
    18b4:	16 2f       	mov	r17, r22
    18b6:	66 23       	and	r22, r22
    18b8:	a9 f0       	breq	.+42     	; 0x18e4 <xQueueGenericCreate+0x3a>
    18ba:	86 9f       	mul	r24, r22
    18bc:	c0 01       	movw	r24, r0
    18be:	11 24       	eor	r1, r1
    18c0:	80 96       	adiw	r24, 0x20	; 32
    18c2:	f3 de       	rcall	.-538    	; 0x16aa <pvPortMalloc>
    18c4:	ec 01       	movw	r28, r24
    18c6:	00 97       	sbiw	r24, 0x00	; 0
    18c8:	21 f4       	brne	.+8      	; 0x18d2 <xQueueGenericCreate+0x28>
    18ca:	12 c0       	rjmp	.+36     	; 0x18f0 <xQueueGenericCreate+0x46>
    18cc:	c8 83       	st	Y, r28
    18ce:	d9 83       	std	Y+1, r29	; 0x01
    18d0:	03 c0       	rjmp	.+6      	; 0x18d8 <xQueueGenericCreate+0x2e>
    18d2:	4f 96       	adiw	r24, 0x1f	; 31
    18d4:	88 83       	st	Y, r24
    18d6:	99 83       	std	Y+1, r25	; 0x01
    18d8:	0b 8f       	std	Y+27, r16	; 0x1b
    18da:	1c 8f       	std	Y+28, r17	; 0x1c
    18dc:	61 e0       	ldi	r22, 0x01	; 1
    18de:	ce 01       	movw	r24, r28
    18e0:	ab df       	rcall	.-170    	; 0x1838 <xQueueGenericReset>
    18e2:	06 c0       	rjmp	.+12     	; 0x18f0 <xQueueGenericCreate+0x46>
    18e4:	8f e1       	ldi	r24, 0x1F	; 31
    18e6:	90 e0       	ldi	r25, 0x00	; 0
    18e8:	e0 de       	rcall	.-576    	; 0x16aa <pvPortMalloc>
    18ea:	ec 01       	movw	r28, r24
    18ec:	89 2b       	or	r24, r25
    18ee:	71 f7       	brne	.-36     	; 0x18cc <xQueueGenericCreate+0x22>
    18f0:	ce 01       	movw	r24, r28
    18f2:	df 91       	pop	r29
    18f4:	cf 91       	pop	r28
    18f6:	1f 91       	pop	r17
    18f8:	0f 91       	pop	r16
    18fa:	08 95       	ret

000018fc <xQueueGenericSend>:
    18fc:	af 92       	push	r10
    18fe:	bf 92       	push	r11
    1900:	cf 92       	push	r12
    1902:	df 92       	push	r13
    1904:	ef 92       	push	r14
    1906:	ff 92       	push	r15
    1908:	0f 93       	push	r16
    190a:	1f 93       	push	r17
    190c:	cf 93       	push	r28
    190e:	df 93       	push	r29
    1910:	cd b7       	in	r28, 0x3d	; 61
    1912:	de b7       	in	r29, 0x3e	; 62
    1914:	25 97       	sbiw	r28, 0x05	; 5
    1916:	cd bf       	out	0x3d, r28	; 61
    1918:	de bf       	out	0x3e, r29	; 62
    191a:	8c 01       	movw	r16, r24
    191c:	6b 01       	movw	r12, r22
    191e:	4c 83       	std	Y+4, r20	; 0x04
    1920:	5d 83       	std	Y+5, r21	; 0x05
    1922:	a2 2e       	mov	r10, r18
    1924:	b1 2c       	mov	r11, r1
    1926:	7c 01       	movw	r14, r24
    1928:	88 e0       	ldi	r24, 0x08	; 8
    192a:	e8 0e       	add	r14, r24
    192c:	f1 1c       	adc	r15, r1
    192e:	0f b6       	in	r0, 0x3f	; 63
    1930:	f8 94       	cli
    1932:	0f 92       	push	r0
    1934:	f8 01       	movw	r30, r16
    1936:	92 8d       	ldd	r25, Z+26	; 0x1a
    1938:	83 8d       	ldd	r24, Z+27	; 0x1b
    193a:	98 17       	cp	r25, r24
    193c:	18 f0       	brcs	.+6      	; 0x1944 <xQueueGenericSend+0x48>
    193e:	f2 e0       	ldi	r31, 0x02	; 2
    1940:	af 12       	cpse	r10, r31
    1942:	15 c0       	rjmp	.+42     	; 0x196e <xQueueGenericSend+0x72>
    1944:	4a 2d       	mov	r20, r10
    1946:	b6 01       	movw	r22, r12
    1948:	c8 01       	movw	r24, r16
    194a:	c9 de       	rcall	.-622    	; 0x16de <prvCopyDataToQueue>
    194c:	f8 01       	movw	r30, r16
    194e:	91 89       	ldd	r25, Z+17	; 0x11
    1950:	99 23       	and	r25, r25
    1952:	39 f0       	breq	.+14     	; 0x1962 <xQueueGenericSend+0x66>
    1954:	c8 01       	movw	r24, r16
    1956:	41 96       	adiw	r24, 0x11	; 17
    1958:	d2 d4       	rcall	.+2468   	; 0x22fe <xTaskRemoveFromEventList>
    195a:	81 30       	cpi	r24, 0x01	; 1
    195c:	21 f4       	brne	.+8      	; 0x1966 <xQueueGenericSend+0x6a>
    195e:	f3 dd       	rcall	.-1050   	; 0x1546 <vPortYield>
    1960:	02 c0       	rjmp	.+4      	; 0x1966 <xQueueGenericSend+0x6a>
    1962:	81 11       	cpse	r24, r1
    1964:	f0 dd       	rcall	.-1056   	; 0x1546 <vPortYield>
    1966:	0f 90       	pop	r0
    1968:	0f be       	out	0x3f, r0	; 63
    196a:	81 e0       	ldi	r24, 0x01	; 1
    196c:	46 c0       	rjmp	.+140    	; 0x19fa <xQueueGenericSend+0xfe>
    196e:	8c 81       	ldd	r24, Y+4	; 0x04
    1970:	9d 81       	ldd	r25, Y+5	; 0x05
    1972:	89 2b       	or	r24, r25
    1974:	21 f4       	brne	.+8      	; 0x197e <xQueueGenericSend+0x82>
    1976:	0f 90       	pop	r0
    1978:	0f be       	out	0x3f, r0	; 63
    197a:	80 e0       	ldi	r24, 0x00	; 0
    197c:	3e c0       	rjmp	.+124    	; 0x19fa <xQueueGenericSend+0xfe>
    197e:	b1 10       	cpse	r11, r1
    1980:	05 c0       	rjmp	.+10     	; 0x198c <xQueueGenericSend+0x90>
    1982:	ce 01       	movw	r24, r28
    1984:	01 96       	adiw	r24, 0x01	; 1
    1986:	01 d5       	rcall	.+2562   	; 0x238a <vTaskSetTimeOutState>
    1988:	bb 24       	eor	r11, r11
    198a:	b3 94       	inc	r11
    198c:	0f 90       	pop	r0
    198e:	0f be       	out	0x3f, r0	; 63
    1990:	9a d2       	rcall	.+1332   	; 0x1ec6 <vTaskSuspendAll>
    1992:	0f b6       	in	r0, 0x3f	; 63
    1994:	f8 94       	cli
    1996:	0f 92       	push	r0
    1998:	f8 01       	movw	r30, r16
    199a:	85 8d       	ldd	r24, Z+29	; 0x1d
    199c:	8f 3f       	cpi	r24, 0xFF	; 255
    199e:	09 f4       	brne	.+2      	; 0x19a2 <xQueueGenericSend+0xa6>
    19a0:	15 8e       	std	Z+29, r1	; 0x1d
    19a2:	f8 01       	movw	r30, r16
    19a4:	86 8d       	ldd	r24, Z+30	; 0x1e
    19a6:	8f 3f       	cpi	r24, 0xFF	; 255
    19a8:	09 f4       	brne	.+2      	; 0x19ac <xQueueGenericSend+0xb0>
    19aa:	16 8e       	std	Z+30, r1	; 0x1e
    19ac:	0f 90       	pop	r0
    19ae:	0f be       	out	0x3f, r0	; 63
    19b0:	be 01       	movw	r22, r28
    19b2:	6c 5f       	subi	r22, 0xFC	; 252
    19b4:	7f 4f       	sbci	r23, 0xFF	; 255
    19b6:	ce 01       	movw	r24, r28
    19b8:	01 96       	adiw	r24, 0x01	; 1
    19ba:	f2 d4       	rcall	.+2532   	; 0x23a0 <xTaskCheckForTimeOut>
    19bc:	81 11       	cpse	r24, r1
    19be:	19 c0       	rjmp	.+50     	; 0x19f2 <xQueueGenericSend+0xf6>
    19c0:	0f b6       	in	r0, 0x3f	; 63
    19c2:	f8 94       	cli
    19c4:	0f 92       	push	r0
    19c6:	f8 01       	movw	r30, r16
    19c8:	92 8d       	ldd	r25, Z+26	; 0x1a
    19ca:	0f 90       	pop	r0
    19cc:	0f be       	out	0x3f, r0	; 63
    19ce:	83 8d       	ldd	r24, Z+27	; 0x1b
    19d0:	98 13       	cpse	r25, r24
    19d2:	0b c0       	rjmp	.+22     	; 0x19ea <xQueueGenericSend+0xee>
    19d4:	6c 81       	ldd	r22, Y+4	; 0x04
    19d6:	7d 81       	ldd	r23, Y+5	; 0x05
    19d8:	c7 01       	movw	r24, r14
    19da:	5d d4       	rcall	.+2234   	; 0x2296 <vTaskPlaceOnEventList>
    19dc:	c8 01       	movw	r24, r16
    19de:	e4 de       	rcall	.-568    	; 0x17a8 <prvUnlockQueue>
    19e0:	55 d3       	rcall	.+1706   	; 0x208c <xTaskResumeAll>
    19e2:	81 11       	cpse	r24, r1
    19e4:	a4 cf       	rjmp	.-184    	; 0x192e <xQueueGenericSend+0x32>
    19e6:	af dd       	rcall	.-1186   	; 0x1546 <vPortYield>
    19e8:	a2 cf       	rjmp	.-188    	; 0x192e <xQueueGenericSend+0x32>
    19ea:	c8 01       	movw	r24, r16
    19ec:	dd de       	rcall	.-582    	; 0x17a8 <prvUnlockQueue>
    19ee:	4e d3       	rcall	.+1692   	; 0x208c <xTaskResumeAll>
    19f0:	9e cf       	rjmp	.-196    	; 0x192e <xQueueGenericSend+0x32>
    19f2:	c8 01       	movw	r24, r16
    19f4:	d9 de       	rcall	.-590    	; 0x17a8 <prvUnlockQueue>
    19f6:	4a d3       	rcall	.+1684   	; 0x208c <xTaskResumeAll>
    19f8:	80 e0       	ldi	r24, 0x00	; 0
    19fa:	25 96       	adiw	r28, 0x05	; 5
    19fc:	cd bf       	out	0x3d, r28	; 61
    19fe:	de bf       	out	0x3e, r29	; 62
    1a00:	df 91       	pop	r29
    1a02:	cf 91       	pop	r28
    1a04:	1f 91       	pop	r17
    1a06:	0f 91       	pop	r16
    1a08:	ff 90       	pop	r15
    1a0a:	ef 90       	pop	r14
    1a0c:	df 90       	pop	r13
    1a0e:	cf 90       	pop	r12
    1a10:	bf 90       	pop	r11
    1a12:	af 90       	pop	r10
    1a14:	08 95       	ret

00001a16 <xQueueGenericSendFromISR>:
    1a16:	0f 93       	push	r16
    1a18:	1f 93       	push	r17
    1a1a:	cf 93       	push	r28
    1a1c:	df 93       	push	r29
    1a1e:	fa 01       	movw	r30, r20
    1a20:	dc 01       	movw	r26, r24
    1a22:	5a 96       	adiw	r26, 0x1a	; 26
    1a24:	5c 91       	ld	r21, X
    1a26:	5a 97       	sbiw	r26, 0x1a	; 26
    1a28:	5b 96       	adiw	r26, 0x1b	; 27
    1a2a:	3c 91       	ld	r19, X
    1a2c:	53 17       	cp	r21, r19
    1a2e:	10 f0       	brcs	.+4      	; 0x1a34 <xQueueGenericSendFromISR+0x1e>
    1a30:	22 30       	cpi	r18, 0x02	; 2
    1a32:	d9 f4       	brne	.+54     	; 0x1a6a <xQueueGenericSendFromISR+0x54>
    1a34:	42 2f       	mov	r20, r18
    1a36:	8f 01       	movw	r16, r30
    1a38:	ec 01       	movw	r28, r24
    1a3a:	51 de       	rcall	.-862    	; 0x16de <prvCopyDataToQueue>
    1a3c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1a3e:	8f 3f       	cpi	r24, 0xFF	; 255
    1a40:	79 f4       	brne	.+30     	; 0x1a60 <xQueueGenericSendFromISR+0x4a>
    1a42:	89 89       	ldd	r24, Y+17	; 0x11
    1a44:	88 23       	and	r24, r24
    1a46:	99 f0       	breq	.+38     	; 0x1a6e <xQueueGenericSendFromISR+0x58>
    1a48:	ce 01       	movw	r24, r28
    1a4a:	41 96       	adiw	r24, 0x11	; 17
    1a4c:	58 d4       	rcall	.+2224   	; 0x22fe <xTaskRemoveFromEventList>
    1a4e:	88 23       	and	r24, r24
    1a50:	81 f0       	breq	.+32     	; 0x1a72 <xQueueGenericSendFromISR+0x5c>
    1a52:	01 15       	cp	r16, r1
    1a54:	11 05       	cpc	r17, r1
    1a56:	79 f0       	breq	.+30     	; 0x1a76 <xQueueGenericSendFromISR+0x60>
    1a58:	81 e0       	ldi	r24, 0x01	; 1
    1a5a:	f8 01       	movw	r30, r16
    1a5c:	80 83       	st	Z, r24
    1a5e:	0c c0       	rjmp	.+24     	; 0x1a78 <xQueueGenericSendFromISR+0x62>
    1a60:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1a62:	8f 5f       	subi	r24, 0xFF	; 255
    1a64:	8e 8f       	std	Y+30, r24	; 0x1e
    1a66:	81 e0       	ldi	r24, 0x01	; 1
    1a68:	07 c0       	rjmp	.+14     	; 0x1a78 <xQueueGenericSendFromISR+0x62>
    1a6a:	80 e0       	ldi	r24, 0x00	; 0
    1a6c:	05 c0       	rjmp	.+10     	; 0x1a78 <xQueueGenericSendFromISR+0x62>
    1a6e:	81 e0       	ldi	r24, 0x01	; 1
    1a70:	03 c0       	rjmp	.+6      	; 0x1a78 <xQueueGenericSendFromISR+0x62>
    1a72:	81 e0       	ldi	r24, 0x01	; 1
    1a74:	01 c0       	rjmp	.+2      	; 0x1a78 <xQueueGenericSendFromISR+0x62>
    1a76:	81 e0       	ldi	r24, 0x01	; 1
    1a78:	df 91       	pop	r29
    1a7a:	cf 91       	pop	r28
    1a7c:	1f 91       	pop	r17
    1a7e:	0f 91       	pop	r16
    1a80:	08 95       	ret

00001a82 <xQueueGenericReceive>:
    1a82:	af 92       	push	r10
    1a84:	bf 92       	push	r11
    1a86:	cf 92       	push	r12
    1a88:	df 92       	push	r13
    1a8a:	ef 92       	push	r14
    1a8c:	ff 92       	push	r15
    1a8e:	0f 93       	push	r16
    1a90:	1f 93       	push	r17
    1a92:	cf 93       	push	r28
    1a94:	df 93       	push	r29
    1a96:	cd b7       	in	r28, 0x3d	; 61
    1a98:	de b7       	in	r29, 0x3e	; 62
    1a9a:	25 97       	sbiw	r28, 0x05	; 5
    1a9c:	cd bf       	out	0x3d, r28	; 61
    1a9e:	de bf       	out	0x3e, r29	; 62
    1aa0:	8c 01       	movw	r16, r24
    1aa2:	6b 01       	movw	r12, r22
    1aa4:	4c 83       	std	Y+4, r20	; 0x04
    1aa6:	5d 83       	std	Y+5, r21	; 0x05
    1aa8:	a2 2e       	mov	r10, r18
    1aaa:	b1 2c       	mov	r11, r1
    1aac:	7c 01       	movw	r14, r24
    1aae:	81 e1       	ldi	r24, 0x11	; 17
    1ab0:	e8 0e       	add	r14, r24
    1ab2:	f1 1c       	adc	r15, r1
    1ab4:	0f b6       	in	r0, 0x3f	; 63
    1ab6:	f8 94       	cli
    1ab8:	0f 92       	push	r0
    1aba:	f8 01       	movw	r30, r16
    1abc:	82 8d       	ldd	r24, Z+26	; 0x1a
    1abe:	88 23       	and	r24, r24
    1ac0:	21 f1       	breq	.+72     	; 0x1b0a <xQueueGenericReceive+0x88>
    1ac2:	e6 80       	ldd	r14, Z+6	; 0x06
    1ac4:	f7 80       	ldd	r15, Z+7	; 0x07
    1ac6:	b6 01       	movw	r22, r12
    1ac8:	c8 01       	movw	r24, r16
    1aca:	54 de       	rcall	.-856    	; 0x1774 <prvCopyDataFromQueue>
    1acc:	a1 10       	cpse	r10, r1
    1ace:	0e c0       	rjmp	.+28     	; 0x1aec <xQueueGenericReceive+0x6a>
    1ad0:	f8 01       	movw	r30, r16
    1ad2:	82 8d       	ldd	r24, Z+26	; 0x1a
    1ad4:	81 50       	subi	r24, 0x01	; 1
    1ad6:	82 8f       	std	Z+26, r24	; 0x1a
    1ad8:	80 85       	ldd	r24, Z+8	; 0x08
    1ada:	88 23       	and	r24, r24
    1adc:	91 f0       	breq	.+36     	; 0x1b02 <xQueueGenericReceive+0x80>
    1ade:	c8 01       	movw	r24, r16
    1ae0:	08 96       	adiw	r24, 0x08	; 8
    1ae2:	0d d4       	rcall	.+2074   	; 0x22fe <xTaskRemoveFromEventList>
    1ae4:	81 30       	cpi	r24, 0x01	; 1
    1ae6:	69 f4       	brne	.+26     	; 0x1b02 <xQueueGenericReceive+0x80>
    1ae8:	2e dd       	rcall	.-1444   	; 0x1546 <vPortYield>
    1aea:	0b c0       	rjmp	.+22     	; 0x1b02 <xQueueGenericReceive+0x80>
    1aec:	f8 01       	movw	r30, r16
    1aee:	e6 82       	std	Z+6, r14	; 0x06
    1af0:	f7 82       	std	Z+7, r15	; 0x07
    1af2:	81 89       	ldd	r24, Z+17	; 0x11
    1af4:	88 23       	and	r24, r24
    1af6:	29 f0       	breq	.+10     	; 0x1b02 <xQueueGenericReceive+0x80>
    1af8:	c8 01       	movw	r24, r16
    1afa:	41 96       	adiw	r24, 0x11	; 17
    1afc:	00 d4       	rcall	.+2048   	; 0x22fe <xTaskRemoveFromEventList>
    1afe:	81 11       	cpse	r24, r1
    1b00:	22 dd       	rcall	.-1468   	; 0x1546 <vPortYield>
    1b02:	0f 90       	pop	r0
    1b04:	0f be       	out	0x3f, r0	; 63
    1b06:	81 e0       	ldi	r24, 0x01	; 1
    1b08:	45 c0       	rjmp	.+138    	; 0x1b94 <xQueueGenericReceive+0x112>
    1b0a:	8c 81       	ldd	r24, Y+4	; 0x04
    1b0c:	9d 81       	ldd	r25, Y+5	; 0x05
    1b0e:	89 2b       	or	r24, r25
    1b10:	21 f4       	brne	.+8      	; 0x1b1a <xQueueGenericReceive+0x98>
    1b12:	0f 90       	pop	r0
    1b14:	0f be       	out	0x3f, r0	; 63
    1b16:	80 e0       	ldi	r24, 0x00	; 0
    1b18:	3d c0       	rjmp	.+122    	; 0x1b94 <xQueueGenericReceive+0x112>
    1b1a:	b1 10       	cpse	r11, r1
    1b1c:	05 c0       	rjmp	.+10     	; 0x1b28 <xQueueGenericReceive+0xa6>
    1b1e:	ce 01       	movw	r24, r28
    1b20:	01 96       	adiw	r24, 0x01	; 1
    1b22:	33 d4       	rcall	.+2150   	; 0x238a <vTaskSetTimeOutState>
    1b24:	bb 24       	eor	r11, r11
    1b26:	b3 94       	inc	r11
    1b28:	0f 90       	pop	r0
    1b2a:	0f be       	out	0x3f, r0	; 63
    1b2c:	cc d1       	rcall	.+920    	; 0x1ec6 <vTaskSuspendAll>
    1b2e:	0f b6       	in	r0, 0x3f	; 63
    1b30:	f8 94       	cli
    1b32:	0f 92       	push	r0
    1b34:	f8 01       	movw	r30, r16
    1b36:	85 8d       	ldd	r24, Z+29	; 0x1d
    1b38:	8f 3f       	cpi	r24, 0xFF	; 255
    1b3a:	09 f4       	brne	.+2      	; 0x1b3e <xQueueGenericReceive+0xbc>
    1b3c:	15 8e       	std	Z+29, r1	; 0x1d
    1b3e:	f8 01       	movw	r30, r16
    1b40:	86 8d       	ldd	r24, Z+30	; 0x1e
    1b42:	8f 3f       	cpi	r24, 0xFF	; 255
    1b44:	09 f4       	brne	.+2      	; 0x1b48 <xQueueGenericReceive+0xc6>
    1b46:	16 8e       	std	Z+30, r1	; 0x1e
    1b48:	0f 90       	pop	r0
    1b4a:	0f be       	out	0x3f, r0	; 63
    1b4c:	be 01       	movw	r22, r28
    1b4e:	6c 5f       	subi	r22, 0xFC	; 252
    1b50:	7f 4f       	sbci	r23, 0xFF	; 255
    1b52:	ce 01       	movw	r24, r28
    1b54:	01 96       	adiw	r24, 0x01	; 1
    1b56:	24 d4       	rcall	.+2120   	; 0x23a0 <xTaskCheckForTimeOut>
    1b58:	81 11       	cpse	r24, r1
    1b5a:	18 c0       	rjmp	.+48     	; 0x1b8c <xQueueGenericReceive+0x10a>
    1b5c:	0f b6       	in	r0, 0x3f	; 63
    1b5e:	f8 94       	cli
    1b60:	0f 92       	push	r0
    1b62:	f8 01       	movw	r30, r16
    1b64:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b66:	0f 90       	pop	r0
    1b68:	0f be       	out	0x3f, r0	; 63
    1b6a:	81 11       	cpse	r24, r1
    1b6c:	0b c0       	rjmp	.+22     	; 0x1b84 <xQueueGenericReceive+0x102>
    1b6e:	6c 81       	ldd	r22, Y+4	; 0x04
    1b70:	7d 81       	ldd	r23, Y+5	; 0x05
    1b72:	c7 01       	movw	r24, r14
    1b74:	90 d3       	rcall	.+1824   	; 0x2296 <vTaskPlaceOnEventList>
    1b76:	c8 01       	movw	r24, r16
    1b78:	17 de       	rcall	.-978    	; 0x17a8 <prvUnlockQueue>
    1b7a:	88 d2       	rcall	.+1296   	; 0x208c <xTaskResumeAll>
    1b7c:	81 11       	cpse	r24, r1
    1b7e:	9a cf       	rjmp	.-204    	; 0x1ab4 <xQueueGenericReceive+0x32>
    1b80:	e2 dc       	rcall	.-1596   	; 0x1546 <vPortYield>
    1b82:	98 cf       	rjmp	.-208    	; 0x1ab4 <xQueueGenericReceive+0x32>
    1b84:	c8 01       	movw	r24, r16
    1b86:	10 de       	rcall	.-992    	; 0x17a8 <prvUnlockQueue>
    1b88:	81 d2       	rcall	.+1282   	; 0x208c <xTaskResumeAll>
    1b8a:	94 cf       	rjmp	.-216    	; 0x1ab4 <xQueueGenericReceive+0x32>
    1b8c:	c8 01       	movw	r24, r16
    1b8e:	0c de       	rcall	.-1000   	; 0x17a8 <prvUnlockQueue>
    1b90:	7d d2       	rcall	.+1274   	; 0x208c <xTaskResumeAll>
    1b92:	80 e0       	ldi	r24, 0x00	; 0
    1b94:	25 96       	adiw	r28, 0x05	; 5
    1b96:	cd bf       	out	0x3d, r28	; 61
    1b98:	de bf       	out	0x3e, r29	; 62
    1b9a:	df 91       	pop	r29
    1b9c:	cf 91       	pop	r28
    1b9e:	1f 91       	pop	r17
    1ba0:	0f 91       	pop	r16
    1ba2:	ff 90       	pop	r15
    1ba4:	ef 90       	pop	r14
    1ba6:	df 90       	pop	r13
    1ba8:	cf 90       	pop	r12
    1baa:	bf 90       	pop	r11
    1bac:	af 90       	pop	r10
    1bae:	08 95       	ret

00001bb0 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
    1bb0:	cf 93       	push	r28
    1bb2:	df 93       	push	r29
    1bb4:	ec 01       	movw	r28, r24
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
    1bb6:	0f b6       	in	r0, 0x3f	; 63
    1bb8:	f8 94       	cli
    1bba:	0f 92       	push	r0
    1bbc:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1bbe:	8f 3f       	cpi	r24, 0xFF	; 255
    1bc0:	09 f4       	brne	.+2      	; 0x1bc4 <vQueueWaitForMessageRestricted+0x14>
    1bc2:	1d 8e       	std	Y+29, r1	; 0x1d
    1bc4:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1bc6:	8f 3f       	cpi	r24, 0xFF	; 255
    1bc8:	09 f4       	brne	.+2      	; 0x1bcc <vQueueWaitForMessageRestricted+0x1c>
    1bca:	1e 8e       	std	Y+30, r1	; 0x1e
    1bcc:	0f 90       	pop	r0
    1bce:	0f be       	out	0x3f, r0	; 63
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    1bd0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1bd2:	81 11       	cpse	r24, r1
    1bd4:	03 c0       	rjmp	.+6      	; 0x1bdc <vQueueWaitForMessageRestricted+0x2c>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    1bd6:	ce 01       	movw	r24, r28
    1bd8:	41 96       	adiw	r24, 0x11	; 17
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
    1bda:	77 d3       	rcall	.+1774   	; 0x22ca <vTaskPlaceOnEventListRestricted>
    1bdc:	ce 01       	movw	r24, r28
	}
    1bde:	e4 dd       	rcall	.-1080   	; 0x17a8 <prvUnlockQueue>
    1be0:	df 91       	pop	r29
    1be2:	cf 91       	pop	r28
    1be4:	08 95       	ret

00001be6 <prvIdleTask>:
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    1be6:	c1 e6       	ldi	r28, 0x61	; 97
    1be8:	d2 e2       	ldi	r29, 0x22	; 34
    1bea:	88 81       	ld	r24, Y
    1bec:	82 30       	cpi	r24, 0x02	; 2
    1bee:	f0 f3       	brcs	.-4      	; 0x1bec <prvIdleTask+0x6>
    1bf0:	aa dc       	rcall	.-1708   	; 0x1546 <vPortYield>
    1bf2:	fb cf       	rjmp	.-10     	; 0x1bea <prvIdleTask+0x4>

00001bf4 <prvAddCurrentTaskToDelayedList>:
    1bf4:	cf 93       	push	r28
    1bf6:	df 93       	push	r29
    1bf8:	ec 01       	movw	r28, r24
    1bfa:	e0 91 8e 22 	lds	r30, 0x228E	; 0x80228e <pxCurrentTCB>
    1bfe:	f0 91 8f 22 	lds	r31, 0x228F	; 0x80228f <pxCurrentTCB+0x1>
    1c02:	82 83       	std	Z+2, r24	; 0x02
    1c04:	93 83       	std	Z+3, r25	; 0x03
    1c06:	80 91 3f 22 	lds	r24, 0x223F	; 0x80223f <xTickCount>
    1c0a:	90 91 40 22 	lds	r25, 0x2240	; 0x802240 <xTickCount+0x1>
    1c0e:	c8 17       	cp	r28, r24
    1c10:	d9 07       	cpc	r29, r25
    1c12:	60 f4       	brcc	.+24     	; 0x1c2c <prvAddCurrentTaskToDelayedList+0x38>
    1c14:	60 91 8e 22 	lds	r22, 0x228E	; 0x80228e <pxCurrentTCB>
    1c18:	70 91 8f 22 	lds	r23, 0x228F	; 0x80228f <pxCurrentTCB+0x1>
    1c1c:	80 91 4b 22 	lds	r24, 0x224B	; 0x80224b <pxOverflowDelayedTaskList>
    1c20:	90 91 4c 22 	lds	r25, 0x224C	; 0x80224c <pxOverflowDelayedTaskList+0x1>
    1c24:	6e 5f       	subi	r22, 0xFE	; 254
    1c26:	7f 4f       	sbci	r23, 0xFF	; 255
    1c28:	7b db       	rcall	.-2314   	; 0x1320 <vListInsert>
    1c2a:	16 c0       	rjmp	.+44     	; 0x1c58 <prvAddCurrentTaskToDelayedList+0x64>
    1c2c:	60 91 8e 22 	lds	r22, 0x228E	; 0x80228e <pxCurrentTCB>
    1c30:	70 91 8f 22 	lds	r23, 0x228F	; 0x80228f <pxCurrentTCB+0x1>
    1c34:	80 91 4d 22 	lds	r24, 0x224D	; 0x80224d <pxDelayedTaskList>
    1c38:	90 91 4e 22 	lds	r25, 0x224E	; 0x80224e <pxDelayedTaskList+0x1>
    1c3c:	6e 5f       	subi	r22, 0xFE	; 254
    1c3e:	7f 4f       	sbci	r23, 0xFF	; 255
    1c40:	6f db       	rcall	.-2338   	; 0x1320 <vListInsert>
    1c42:	80 91 37 22 	lds	r24, 0x2237	; 0x802237 <xNextTaskUnblockTime>
    1c46:	90 91 38 22 	lds	r25, 0x2238	; 0x802238 <xNextTaskUnblockTime+0x1>
    1c4a:	c8 17       	cp	r28, r24
    1c4c:	d9 07       	cpc	r29, r25
    1c4e:	20 f4       	brcc	.+8      	; 0x1c58 <prvAddCurrentTaskToDelayedList+0x64>
    1c50:	c0 93 37 22 	sts	0x2237, r28	; 0x802237 <xNextTaskUnblockTime>
    1c54:	d0 93 38 22 	sts	0x2238, r29	; 0x802238 <xNextTaskUnblockTime+0x1>
    1c58:	df 91       	pop	r29
    1c5a:	cf 91       	pop	r28
    1c5c:	08 95       	ret

00001c5e <xTaskGenericCreate>:
    1c5e:	4f 92       	push	r4
    1c60:	5f 92       	push	r5
    1c62:	6f 92       	push	r6
    1c64:	7f 92       	push	r7
    1c66:	8f 92       	push	r8
    1c68:	9f 92       	push	r9
    1c6a:	af 92       	push	r10
    1c6c:	bf 92       	push	r11
    1c6e:	cf 92       	push	r12
    1c70:	df 92       	push	r13
    1c72:	ef 92       	push	r14
    1c74:	ff 92       	push	r15
    1c76:	0f 93       	push	r16
    1c78:	1f 93       	push	r17
    1c7a:	cf 93       	push	r28
    1c7c:	df 93       	push	r29
    1c7e:	4c 01       	movw	r8, r24
    1c80:	eb 01       	movw	r28, r22
    1c82:	5a 01       	movw	r10, r20
    1c84:	29 01       	movw	r4, r18
    1c86:	c1 14       	cp	r12, r1
    1c88:	d1 04       	cpc	r13, r1
    1c8a:	31 f4       	brne	.+12     	; 0x1c98 <xTaskGenericCreate+0x3a>
    1c8c:	ca 01       	movw	r24, r20
    1c8e:	0d dd       	rcall	.-1510   	; 0x16aa <pvPortMalloc>
    1c90:	6c 01       	movw	r12, r24
    1c92:	89 2b       	or	r24, r25
    1c94:	09 f4       	brne	.+2      	; 0x1c98 <xTaskGenericCreate+0x3a>
    1c96:	d2 c0       	rjmp	.+420    	; 0x1e3c <xTaskGenericCreate+0x1de>
    1c98:	86 e2       	ldi	r24, 0x26	; 38
    1c9a:	90 e0       	ldi	r25, 0x00	; 0
    1c9c:	06 dd       	rcall	.-1524   	; 0x16aa <pvPortMalloc>
    1c9e:	3c 01       	movw	r6, r24
    1ca0:	00 97       	sbiw	r24, 0x00	; 0
    1ca2:	79 f0       	breq	.+30     	; 0x1cc2 <xTaskGenericCreate+0x64>
    1ca4:	fc 01       	movw	r30, r24
    1ca6:	c7 8a       	std	Z+23, r12	; 0x17
    1ca8:	d0 8e       	std	Z+24, r13	; 0x18
    1caa:	f1 e0       	ldi	r31, 0x01	; 1
    1cac:	af 1a       	sub	r10, r31
    1cae:	b1 08       	sbc	r11, r1
    1cb0:	ca 0c       	add	r12, r10
    1cb2:	db 1c       	adc	r13, r11
    1cb4:	88 81       	ld	r24, Y
    1cb6:	f3 01       	movw	r30, r6
    1cb8:	81 8f       	std	Z+25, r24	; 0x19
    1cba:	88 81       	ld	r24, Y
    1cbc:	81 11       	cpse	r24, r1
    1cbe:	04 c0       	rjmp	.+8      	; 0x1cc8 <xTaskGenericCreate+0x6a>
    1cc0:	13 c0       	rjmp	.+38     	; 0x1ce8 <xTaskGenericCreate+0x8a>
    1cc2:	c6 01       	movw	r24, r12
    1cc4:	ff dc       	rcall	.-1538   	; 0x16c4 <vPortFree>
    1cc6:	ba c0       	rjmp	.+372    	; 0x1e3c <xTaskGenericCreate+0x1de>
    1cc8:	d3 01       	movw	r26, r6
    1cca:	5a 96       	adiw	r26, 0x1a	; 26
    1ccc:	fe 01       	movw	r30, r28
    1cce:	31 96       	adiw	r30, 0x01	; 1
    1cd0:	9e 01       	movw	r18, r28
    1cd2:	28 5f       	subi	r18, 0xF8	; 248
    1cd4:	3f 4f       	sbci	r19, 0xFF	; 255
    1cd6:	ef 01       	movw	r28, r30
    1cd8:	81 91       	ld	r24, Z+
    1cda:	8d 93       	st	X+, r24
    1cdc:	88 81       	ld	r24, Y
    1cde:	88 23       	and	r24, r24
    1ce0:	19 f0       	breq	.+6      	; 0x1ce8 <xTaskGenericCreate+0x8a>
    1ce2:	2e 17       	cp	r18, r30
    1ce4:	3f 07       	cpc	r19, r31
    1ce6:	b9 f7       	brne	.-18     	; 0x1cd6 <xTaskGenericCreate+0x78>
    1ce8:	f3 01       	movw	r30, r6
    1cea:	10 a2       	std	Z+32, r1	; 0x20
    1cec:	10 2f       	mov	r17, r16
    1cee:	05 30       	cpi	r16, 0x05	; 5
    1cf0:	08 f0       	brcs	.+2      	; 0x1cf4 <xTaskGenericCreate+0x96>
    1cf2:	14 e0       	ldi	r17, 0x04	; 4
    1cf4:	f3 01       	movw	r30, r6
    1cf6:	16 8b       	std	Z+22, r17	; 0x16
    1cf8:	e3 01       	movw	r28, r6
    1cfa:	22 96       	adiw	r28, 0x02	; 2
    1cfc:	ce 01       	movw	r24, r28
    1cfe:	eb da       	rcall	.-2602   	; 0x12d6 <vListInitialiseItem>
    1d00:	c3 01       	movw	r24, r6
    1d02:	0c 96       	adiw	r24, 0x0c	; 12
    1d04:	e8 da       	rcall	.-2608   	; 0x12d6 <vListInitialiseItem>
    1d06:	f3 01       	movw	r30, r6
    1d08:	60 86       	std	Z+8, r6	; 0x08
    1d0a:	71 86       	std	Z+9, r7	; 0x09
    1d0c:	85 e0       	ldi	r24, 0x05	; 5
    1d0e:	90 e0       	ldi	r25, 0x00	; 0
    1d10:	81 1b       	sub	r24, r17
    1d12:	91 09       	sbc	r25, r1
    1d14:	84 87       	std	Z+12, r24	; 0x0c
    1d16:	95 87       	std	Z+13, r25	; 0x0d
    1d18:	62 8a       	std	Z+18, r6	; 0x12
    1d1a:	73 8a       	std	Z+19, r7	; 0x13
    1d1c:	11 a2       	std	Z+33, r1	; 0x21
    1d1e:	12 a2       	std	Z+34, r1	; 0x22
    1d20:	13 a2       	std	Z+35, r1	; 0x23
    1d22:	14 a2       	std	Z+36, r1	; 0x24
    1d24:	15 a2       	std	Z+37, r1	; 0x25
    1d26:	a2 01       	movw	r20, r4
    1d28:	b4 01       	movw	r22, r8
    1d2a:	c6 01       	movw	r24, r12
    1d2c:	50 db       	rcall	.-2400   	; 0x13ce <pxPortInitialiseStack>
    1d2e:	f3 01       	movw	r30, r6
    1d30:	80 83       	st	Z, r24
    1d32:	91 83       	std	Z+1, r25	; 0x01
    1d34:	e1 14       	cp	r14, r1
    1d36:	f1 04       	cpc	r15, r1
    1d38:	19 f0       	breq	.+6      	; 0x1d40 <xTaskGenericCreate+0xe2>
    1d3a:	f7 01       	movw	r30, r14
    1d3c:	60 82       	st	Z, r6
    1d3e:	71 82       	std	Z+1, r7	; 0x01
    1d40:	0f b6       	in	r0, 0x3f	; 63
    1d42:	f8 94       	cli
    1d44:	0f 92       	push	r0
    1d46:	80 91 41 22 	lds	r24, 0x2241	; 0x802241 <uxCurrentNumberOfTasks>
    1d4a:	8f 5f       	subi	r24, 0xFF	; 255
    1d4c:	80 93 41 22 	sts	0x2241, r24	; 0x802241 <uxCurrentNumberOfTasks>
    1d50:	80 91 8e 22 	lds	r24, 0x228E	; 0x80228e <pxCurrentTCB>
    1d54:	90 91 8f 22 	lds	r25, 0x228F	; 0x80228f <pxCurrentTCB+0x1>
    1d58:	89 2b       	or	r24, r25
    1d5a:	91 f5       	brne	.+100    	; 0x1dc0 <xTaskGenericCreate+0x162>
    1d5c:	60 92 8e 22 	sts	0x228E, r6	; 0x80228e <pxCurrentTCB>
    1d60:	70 92 8f 22 	sts	0x228F, r7	; 0x80228f <pxCurrentTCB+0x1>
    1d64:	80 91 41 22 	lds	r24, 0x2241	; 0x802241 <uxCurrentNumberOfTasks>
    1d68:	81 30       	cpi	r24, 0x01	; 1
    1d6a:	c9 f5       	brne	.+114    	; 0x1dde <xTaskGenericCreate+0x180>
    1d6c:	0f 2e       	mov	r0, r31
    1d6e:	f1 e6       	ldi	r31, 0x61	; 97
    1d70:	ef 2e       	mov	r14, r31
    1d72:	f2 e2       	ldi	r31, 0x22	; 34
    1d74:	ff 2e       	mov	r15, r31
    1d76:	f0 2d       	mov	r31, r0
    1d78:	0f 2e       	mov	r0, r31
    1d7a:	fe e8       	ldi	r31, 0x8E	; 142
    1d7c:	cf 2e       	mov	r12, r31
    1d7e:	f2 e2       	ldi	r31, 0x22	; 34
    1d80:	df 2e       	mov	r13, r31
    1d82:	f0 2d       	mov	r31, r0
    1d84:	c7 01       	movw	r24, r14
    1d86:	99 da       	rcall	.-2766   	; 0x12ba <vListInitialise>
    1d88:	f9 e0       	ldi	r31, 0x09	; 9
    1d8a:	ef 0e       	add	r14, r31
    1d8c:	f1 1c       	adc	r15, r1
    1d8e:	ec 14       	cp	r14, r12
    1d90:	fd 04       	cpc	r15, r13
    1d92:	c1 f7       	brne	.-16     	; 0x1d84 <xTaskGenericCreate+0x126>
    1d94:	88 e5       	ldi	r24, 0x58	; 88
    1d96:	92 e2       	ldi	r25, 0x22	; 34
    1d98:	90 da       	rcall	.-2784   	; 0x12ba <vListInitialise>
    1d9a:	8f e4       	ldi	r24, 0x4F	; 79
    1d9c:	92 e2       	ldi	r25, 0x22	; 34
    1d9e:	8d da       	rcall	.-2790   	; 0x12ba <vListInitialise>
    1da0:	82 e4       	ldi	r24, 0x42	; 66
    1da2:	92 e2       	ldi	r25, 0x22	; 34
    1da4:	8a da       	rcall	.-2796   	; 0x12ba <vListInitialise>
    1da6:	88 e5       	ldi	r24, 0x58	; 88
    1da8:	92 e2       	ldi	r25, 0x22	; 34
    1daa:	80 93 4d 22 	sts	0x224D, r24	; 0x80224d <pxDelayedTaskList>
    1dae:	90 93 4e 22 	sts	0x224E, r25	; 0x80224e <pxDelayedTaskList+0x1>
    1db2:	8f e4       	ldi	r24, 0x4F	; 79
    1db4:	92 e2       	ldi	r25, 0x22	; 34
    1db6:	80 93 4b 22 	sts	0x224B, r24	; 0x80224b <pxOverflowDelayedTaskList>
    1dba:	90 93 4c 22 	sts	0x224C, r25	; 0x80224c <pxOverflowDelayedTaskList+0x1>
    1dbe:	0f c0       	rjmp	.+30     	; 0x1dde <xTaskGenericCreate+0x180>
    1dc0:	80 91 3d 22 	lds	r24, 0x223D	; 0x80223d <xSchedulerRunning>
    1dc4:	81 11       	cpse	r24, r1
    1dc6:	0b c0       	rjmp	.+22     	; 0x1dde <xTaskGenericCreate+0x180>
    1dc8:	e0 91 8e 22 	lds	r30, 0x228E	; 0x80228e <pxCurrentTCB>
    1dcc:	f0 91 8f 22 	lds	r31, 0x228F	; 0x80228f <pxCurrentTCB+0x1>
    1dd0:	86 89       	ldd	r24, Z+22	; 0x16
    1dd2:	08 17       	cp	r16, r24
    1dd4:	20 f0       	brcs	.+8      	; 0x1dde <xTaskGenericCreate+0x180>
    1dd6:	60 92 8e 22 	sts	0x228E, r6	; 0x80228e <pxCurrentTCB>
    1dda:	70 92 8f 22 	sts	0x228F, r7	; 0x80228f <pxCurrentTCB+0x1>
    1dde:	80 91 39 22 	lds	r24, 0x2239	; 0x802239 <uxTaskNumber>
    1de2:	8f 5f       	subi	r24, 0xFF	; 255
    1de4:	80 93 39 22 	sts	0x2239, r24	; 0x802239 <uxTaskNumber>
    1de8:	f3 01       	movw	r30, r6
    1dea:	86 89       	ldd	r24, Z+22	; 0x16
    1dec:	90 91 3e 22 	lds	r25, 0x223E	; 0x80223e <uxTopReadyPriority>
    1df0:	98 17       	cp	r25, r24
    1df2:	10 f4       	brcc	.+4      	; 0x1df8 <xTaskGenericCreate+0x19a>
    1df4:	80 93 3e 22 	sts	0x223E, r24	; 0x80223e <uxTopReadyPriority>
    1df8:	90 e0       	ldi	r25, 0x00	; 0
    1dfa:	9c 01       	movw	r18, r24
    1dfc:	22 0f       	add	r18, r18
    1dfe:	33 1f       	adc	r19, r19
    1e00:	22 0f       	add	r18, r18
    1e02:	33 1f       	adc	r19, r19
    1e04:	22 0f       	add	r18, r18
    1e06:	33 1f       	adc	r19, r19
    1e08:	82 0f       	add	r24, r18
    1e0a:	93 1f       	adc	r25, r19
    1e0c:	be 01       	movw	r22, r28
    1e0e:	8f 59       	subi	r24, 0x9F	; 159
    1e10:	9d 4d       	sbci	r25, 0xDD	; 221
    1e12:	65 da       	rcall	.-2870   	; 0x12de <vListInsertEnd>
    1e14:	0f 90       	pop	r0
    1e16:	0f be       	out	0x3f, r0	; 63
    1e18:	80 91 3d 22 	lds	r24, 0x223D	; 0x80223d <xSchedulerRunning>
    1e1c:	88 23       	and	r24, r24
    1e1e:	51 f0       	breq	.+20     	; 0x1e34 <xTaskGenericCreate+0x1d6>
    1e20:	e0 91 8e 22 	lds	r30, 0x228E	; 0x80228e <pxCurrentTCB>
    1e24:	f0 91 8f 22 	lds	r31, 0x228F	; 0x80228f <pxCurrentTCB+0x1>
    1e28:	86 89       	ldd	r24, Z+22	; 0x16
    1e2a:	80 17       	cp	r24, r16
    1e2c:	28 f4       	brcc	.+10     	; 0x1e38 <xTaskGenericCreate+0x1da>
    1e2e:	8b db       	rcall	.-2282   	; 0x1546 <vPortYield>
    1e30:	81 e0       	ldi	r24, 0x01	; 1
    1e32:	05 c0       	rjmp	.+10     	; 0x1e3e <xTaskGenericCreate+0x1e0>
    1e34:	81 e0       	ldi	r24, 0x01	; 1
    1e36:	03 c0       	rjmp	.+6      	; 0x1e3e <xTaskGenericCreate+0x1e0>
    1e38:	81 e0       	ldi	r24, 0x01	; 1
    1e3a:	01 c0       	rjmp	.+2      	; 0x1e3e <xTaskGenericCreate+0x1e0>
    1e3c:	8f ef       	ldi	r24, 0xFF	; 255
    1e3e:	df 91       	pop	r29
    1e40:	cf 91       	pop	r28
    1e42:	1f 91       	pop	r17
    1e44:	0f 91       	pop	r16
    1e46:	ff 90       	pop	r15
    1e48:	ef 90       	pop	r14
    1e4a:	df 90       	pop	r13
    1e4c:	cf 90       	pop	r12
    1e4e:	bf 90       	pop	r11
    1e50:	af 90       	pop	r10
    1e52:	9f 90       	pop	r9
    1e54:	8f 90       	pop	r8
    1e56:	7f 90       	pop	r7
    1e58:	6f 90       	pop	r6
    1e5a:	5f 90       	pop	r5
    1e5c:	4f 90       	pop	r4
    1e5e:	08 95       	ret

00001e60 <vTaskStartScheduler>:
    1e60:	af 92       	push	r10
    1e62:	bf 92       	push	r11
    1e64:	cf 92       	push	r12
    1e66:	df 92       	push	r13
    1e68:	ef 92       	push	r14
    1e6a:	ff 92       	push	r15
    1e6c:	0f 93       	push	r16
    1e6e:	a1 2c       	mov	r10, r1
    1e70:	b1 2c       	mov	r11, r1
    1e72:	c1 2c       	mov	r12, r1
    1e74:	d1 2c       	mov	r13, r1
    1e76:	e1 2c       	mov	r14, r1
    1e78:	f1 2c       	mov	r15, r1
    1e7a:	00 e0       	ldi	r16, 0x00	; 0
    1e7c:	20 e0       	ldi	r18, 0x00	; 0
    1e7e:	30 e0       	ldi	r19, 0x00	; 0
    1e80:	45 e5       	ldi	r20, 0x55	; 85
    1e82:	50 e0       	ldi	r21, 0x00	; 0
    1e84:	6d e0       	ldi	r22, 0x0D	; 13
    1e86:	70 e2       	ldi	r23, 0x20	; 32
    1e88:	83 ef       	ldi	r24, 0xF3	; 243
    1e8a:	9d e0       	ldi	r25, 0x0D	; 13
    1e8c:	e8 de       	rcall	.-560    	; 0x1c5e <xTaskGenericCreate>
    1e8e:	81 30       	cpi	r24, 0x01	; 1
    1e90:	91 f4       	brne	.+36     	; 0x1eb6 <vTaskStartScheduler+0x56>
    1e92:	20 d3       	rcall	.+1600   	; 0x24d4 <xTimerCreateTimerTask>
    1e94:	81 30       	cpi	r24, 0x01	; 1
    1e96:	79 f4       	brne	.+30     	; 0x1eb6 <vTaskStartScheduler+0x56>
    1e98:	f8 94       	cli
    1e9a:	8f ef       	ldi	r24, 0xFF	; 255
    1e9c:	9f ef       	ldi	r25, 0xFF	; 255
    1e9e:	80 93 37 22 	sts	0x2237, r24	; 0x802237 <xNextTaskUnblockTime>
    1ea2:	90 93 38 22 	sts	0x2238, r25	; 0x802238 <xNextTaskUnblockTime+0x1>
    1ea6:	81 e0       	ldi	r24, 0x01	; 1
    1ea8:	80 93 3d 22 	sts	0x223D, r24	; 0x80223d <xSchedulerRunning>
    1eac:	10 92 3f 22 	sts	0x223F, r1	; 0x80223f <xTickCount>
    1eb0:	10 92 40 22 	sts	0x2240, r1	; 0x802240 <xTickCount+0x1>
    1eb4:	03 db       	rcall	.-2554   	; 0x14bc <xPortStartScheduler>
    1eb6:	0f 91       	pop	r16
    1eb8:	ff 90       	pop	r15
    1eba:	ef 90       	pop	r14
    1ebc:	df 90       	pop	r13
    1ebe:	cf 90       	pop	r12
    1ec0:	bf 90       	pop	r11
    1ec2:	af 90       	pop	r10
    1ec4:	08 95       	ret

00001ec6 <vTaskSuspendAll>:
    1ec6:	80 91 36 22 	lds	r24, 0x2236	; 0x802236 <uxSchedulerSuspended>
    1eca:	8f 5f       	subi	r24, 0xFF	; 255
    1ecc:	80 93 36 22 	sts	0x2236, r24	; 0x802236 <uxSchedulerSuspended>
    1ed0:	08 95       	ret

00001ed2 <xTaskGetTickCount>:
    1ed2:	0f b6       	in	r0, 0x3f	; 63
    1ed4:	f8 94       	cli
    1ed6:	0f 92       	push	r0
    1ed8:	80 91 3f 22 	lds	r24, 0x223F	; 0x80223f <xTickCount>
    1edc:	90 91 40 22 	lds	r25, 0x2240	; 0x802240 <xTickCount+0x1>
    1ee0:	0f 90       	pop	r0
    1ee2:	0f be       	out	0x3f, r0	; 63
    1ee4:	08 95       	ret

00001ee6 <xTaskIncrementTick>:
    1ee6:	df 92       	push	r13
    1ee8:	ef 92       	push	r14
    1eea:	ff 92       	push	r15
    1eec:	0f 93       	push	r16
    1eee:	1f 93       	push	r17
    1ef0:	cf 93       	push	r28
    1ef2:	df 93       	push	r29
    1ef4:	80 91 36 22 	lds	r24, 0x2236	; 0x802236 <uxSchedulerSuspended>
    1ef8:	81 11       	cpse	r24, r1
    1efa:	b3 c0       	rjmp	.+358    	; 0x2062 <xTaskIncrementTick+0x17c>
    1efc:	80 91 3f 22 	lds	r24, 0x223F	; 0x80223f <xTickCount>
    1f00:	90 91 40 22 	lds	r25, 0x2240	; 0x802240 <xTickCount+0x1>
    1f04:	01 96       	adiw	r24, 0x01	; 1
    1f06:	80 93 3f 22 	sts	0x223F, r24	; 0x80223f <xTickCount>
    1f0a:	90 93 40 22 	sts	0x2240, r25	; 0x802240 <xTickCount+0x1>
    1f0e:	e0 90 3f 22 	lds	r14, 0x223F	; 0x80223f <xTickCount>
    1f12:	f0 90 40 22 	lds	r15, 0x2240	; 0x802240 <xTickCount+0x1>
    1f16:	e1 14       	cp	r14, r1
    1f18:	f1 04       	cpc	r15, r1
    1f1a:	99 f5       	brne	.+102    	; 0x1f82 <xTaskIncrementTick+0x9c>
    1f1c:	80 91 4d 22 	lds	r24, 0x224D	; 0x80224d <pxDelayedTaskList>
    1f20:	90 91 4e 22 	lds	r25, 0x224E	; 0x80224e <pxDelayedTaskList+0x1>
    1f24:	20 91 4b 22 	lds	r18, 0x224B	; 0x80224b <pxOverflowDelayedTaskList>
    1f28:	30 91 4c 22 	lds	r19, 0x224C	; 0x80224c <pxOverflowDelayedTaskList+0x1>
    1f2c:	20 93 4d 22 	sts	0x224D, r18	; 0x80224d <pxDelayedTaskList>
    1f30:	30 93 4e 22 	sts	0x224E, r19	; 0x80224e <pxDelayedTaskList+0x1>
    1f34:	80 93 4b 22 	sts	0x224B, r24	; 0x80224b <pxOverflowDelayedTaskList>
    1f38:	90 93 4c 22 	sts	0x224C, r25	; 0x80224c <pxOverflowDelayedTaskList+0x1>
    1f3c:	80 91 3a 22 	lds	r24, 0x223A	; 0x80223a <xNumOfOverflows>
    1f40:	8f 5f       	subi	r24, 0xFF	; 255
    1f42:	80 93 3a 22 	sts	0x223A, r24	; 0x80223a <xNumOfOverflows>
    1f46:	e0 91 4d 22 	lds	r30, 0x224D	; 0x80224d <pxDelayedTaskList>
    1f4a:	f0 91 4e 22 	lds	r31, 0x224E	; 0x80224e <pxDelayedTaskList+0x1>
    1f4e:	80 81       	ld	r24, Z
    1f50:	81 11       	cpse	r24, r1
    1f52:	07 c0       	rjmp	.+14     	; 0x1f62 <xTaskIncrementTick+0x7c>
    1f54:	8f ef       	ldi	r24, 0xFF	; 255
    1f56:	9f ef       	ldi	r25, 0xFF	; 255
    1f58:	80 93 37 22 	sts	0x2237, r24	; 0x802237 <xNextTaskUnblockTime>
    1f5c:	90 93 38 22 	sts	0x2238, r25	; 0x802238 <xNextTaskUnblockTime+0x1>
    1f60:	10 c0       	rjmp	.+32     	; 0x1f82 <xTaskIncrementTick+0x9c>
    1f62:	e0 91 4d 22 	lds	r30, 0x224D	; 0x80224d <pxDelayedTaskList>
    1f66:	f0 91 4e 22 	lds	r31, 0x224E	; 0x80224e <pxDelayedTaskList+0x1>
    1f6a:	05 80       	ldd	r0, Z+5	; 0x05
    1f6c:	f6 81       	ldd	r31, Z+6	; 0x06
    1f6e:	e0 2d       	mov	r30, r0
    1f70:	06 80       	ldd	r0, Z+6	; 0x06
    1f72:	f7 81       	ldd	r31, Z+7	; 0x07
    1f74:	e0 2d       	mov	r30, r0
    1f76:	82 81       	ldd	r24, Z+2	; 0x02
    1f78:	93 81       	ldd	r25, Z+3	; 0x03
    1f7a:	80 93 37 22 	sts	0x2237, r24	; 0x802237 <xNextTaskUnblockTime>
    1f7e:	90 93 38 22 	sts	0x2238, r25	; 0x802238 <xNextTaskUnblockTime+0x1>
    1f82:	80 91 37 22 	lds	r24, 0x2237	; 0x802237 <xNextTaskUnblockTime>
    1f86:	90 91 38 22 	lds	r25, 0x2238	; 0x802238 <xNextTaskUnblockTime+0x1>
    1f8a:	e8 16       	cp	r14, r24
    1f8c:	f9 06       	cpc	r15, r25
    1f8e:	10 f4       	brcc	.+4      	; 0x1f94 <xTaskIncrementTick+0xae>
    1f90:	d1 2c       	mov	r13, r1
    1f92:	4f c0       	rjmp	.+158    	; 0x2032 <xTaskIncrementTick+0x14c>
    1f94:	d1 2c       	mov	r13, r1
    1f96:	e0 91 4d 22 	lds	r30, 0x224D	; 0x80224d <pxDelayedTaskList>
    1f9a:	f0 91 4e 22 	lds	r31, 0x224E	; 0x80224e <pxDelayedTaskList+0x1>
    1f9e:	80 81       	ld	r24, Z
    1fa0:	81 11       	cpse	r24, r1
    1fa2:	07 c0       	rjmp	.+14     	; 0x1fb2 <xTaskIncrementTick+0xcc>
    1fa4:	8f ef       	ldi	r24, 0xFF	; 255
    1fa6:	9f ef       	ldi	r25, 0xFF	; 255
    1fa8:	80 93 37 22 	sts	0x2237, r24	; 0x802237 <xNextTaskUnblockTime>
    1fac:	90 93 38 22 	sts	0x2238, r25	; 0x802238 <xNextTaskUnblockTime+0x1>
    1fb0:	40 c0       	rjmp	.+128    	; 0x2032 <xTaskIncrementTick+0x14c>
    1fb2:	e0 91 4d 22 	lds	r30, 0x224D	; 0x80224d <pxDelayedTaskList>
    1fb6:	f0 91 4e 22 	lds	r31, 0x224E	; 0x80224e <pxDelayedTaskList+0x1>
    1fba:	05 80       	ldd	r0, Z+5	; 0x05
    1fbc:	f6 81       	ldd	r31, Z+6	; 0x06
    1fbe:	e0 2d       	mov	r30, r0
    1fc0:	c6 81       	ldd	r28, Z+6	; 0x06
    1fc2:	d7 81       	ldd	r29, Z+7	; 0x07
    1fc4:	8a 81       	ldd	r24, Y+2	; 0x02
    1fc6:	9b 81       	ldd	r25, Y+3	; 0x03
    1fc8:	e8 16       	cp	r14, r24
    1fca:	f9 06       	cpc	r15, r25
    1fcc:	28 f4       	brcc	.+10     	; 0x1fd8 <xTaskIncrementTick+0xf2>
    1fce:	80 93 37 22 	sts	0x2237, r24	; 0x802237 <xNextTaskUnblockTime>
    1fd2:	90 93 38 22 	sts	0x2238, r25	; 0x802238 <xNextTaskUnblockTime+0x1>
    1fd6:	2d c0       	rjmp	.+90     	; 0x2032 <xTaskIncrementTick+0x14c>
    1fd8:	8e 01       	movw	r16, r28
    1fda:	0e 5f       	subi	r16, 0xFE	; 254
    1fdc:	1f 4f       	sbci	r17, 0xFF	; 255
    1fde:	c8 01       	movw	r24, r16
    1fe0:	d0 d9       	rcall	.-3168   	; 0x1382 <uxListRemove>
    1fe2:	8c 89       	ldd	r24, Y+20	; 0x14
    1fe4:	9d 89       	ldd	r25, Y+21	; 0x15
    1fe6:	89 2b       	or	r24, r25
    1fe8:	19 f0       	breq	.+6      	; 0x1ff0 <xTaskIncrementTick+0x10a>
    1fea:	ce 01       	movw	r24, r28
    1fec:	0c 96       	adiw	r24, 0x0c	; 12
    1fee:	c9 d9       	rcall	.-3182   	; 0x1382 <uxListRemove>
    1ff0:	8e 89       	ldd	r24, Y+22	; 0x16
    1ff2:	90 91 3e 22 	lds	r25, 0x223E	; 0x80223e <uxTopReadyPriority>
    1ff6:	98 17       	cp	r25, r24
    1ff8:	10 f4       	brcc	.+4      	; 0x1ffe <xTaskIncrementTick+0x118>
    1ffa:	80 93 3e 22 	sts	0x223E, r24	; 0x80223e <uxTopReadyPriority>
    1ffe:	90 e0       	ldi	r25, 0x00	; 0
    2000:	9c 01       	movw	r18, r24
    2002:	22 0f       	add	r18, r18
    2004:	33 1f       	adc	r19, r19
    2006:	22 0f       	add	r18, r18
    2008:	33 1f       	adc	r19, r19
    200a:	22 0f       	add	r18, r18
    200c:	33 1f       	adc	r19, r19
    200e:	82 0f       	add	r24, r18
    2010:	93 1f       	adc	r25, r19
    2012:	b8 01       	movw	r22, r16
    2014:	8f 59       	subi	r24, 0x9F	; 159
    2016:	9d 4d       	sbci	r25, 0xDD	; 221
    2018:	62 d9       	rcall	.-3388   	; 0x12de <vListInsertEnd>
    201a:	e0 91 8e 22 	lds	r30, 0x228E	; 0x80228e <pxCurrentTCB>
    201e:	f0 91 8f 22 	lds	r31, 0x228F	; 0x80228f <pxCurrentTCB+0x1>
    2022:	9e 89       	ldd	r25, Y+22	; 0x16
    2024:	86 89       	ldd	r24, Z+22	; 0x16
    2026:	98 17       	cp	r25, r24
    2028:	08 f4       	brcc	.+2      	; 0x202c <xTaskIncrementTick+0x146>
    202a:	b5 cf       	rjmp	.-150    	; 0x1f96 <xTaskIncrementTick+0xb0>
    202c:	dd 24       	eor	r13, r13
    202e:	d3 94       	inc	r13
    2030:	b2 cf       	rjmp	.-156    	; 0x1f96 <xTaskIncrementTick+0xb0>
    2032:	e0 91 8e 22 	lds	r30, 0x228E	; 0x80228e <pxCurrentTCB>
    2036:	f0 91 8f 22 	lds	r31, 0x228F	; 0x80228f <pxCurrentTCB+0x1>
    203a:	86 89       	ldd	r24, Z+22	; 0x16
    203c:	90 e0       	ldi	r25, 0x00	; 0
    203e:	fc 01       	movw	r30, r24
    2040:	ee 0f       	add	r30, r30
    2042:	ff 1f       	adc	r31, r31
    2044:	ee 0f       	add	r30, r30
    2046:	ff 1f       	adc	r31, r31
    2048:	ee 0f       	add	r30, r30
    204a:	ff 1f       	adc	r31, r31
    204c:	8e 0f       	add	r24, r30
    204e:	9f 1f       	adc	r25, r31
    2050:	fc 01       	movw	r30, r24
    2052:	ef 59       	subi	r30, 0x9F	; 159
    2054:	fd 4d       	sbci	r31, 0xDD	; 221
    2056:	80 81       	ld	r24, Z
    2058:	82 30       	cpi	r24, 0x02	; 2
    205a:	48 f0       	brcs	.+18     	; 0x206e <xTaskIncrementTick+0x188>
    205c:	dd 24       	eor	r13, r13
    205e:	d3 94       	inc	r13
    2060:	06 c0       	rjmp	.+12     	; 0x206e <xTaskIncrementTick+0x188>
    2062:	80 91 3c 22 	lds	r24, 0x223C	; 0x80223c <uxPendedTicks>
    2066:	8f 5f       	subi	r24, 0xFF	; 255
    2068:	80 93 3c 22 	sts	0x223C, r24	; 0x80223c <uxPendedTicks>
    206c:	d1 2c       	mov	r13, r1
    206e:	80 91 3b 22 	lds	r24, 0x223B	; 0x80223b <xYieldPending>
    2072:	88 23       	and	r24, r24
    2074:	11 f0       	breq	.+4      	; 0x207a <xTaskIncrementTick+0x194>
    2076:	dd 24       	eor	r13, r13
    2078:	d3 94       	inc	r13
    207a:	8d 2d       	mov	r24, r13
    207c:	df 91       	pop	r29
    207e:	cf 91       	pop	r28
    2080:	1f 91       	pop	r17
    2082:	0f 91       	pop	r16
    2084:	ff 90       	pop	r15
    2086:	ef 90       	pop	r14
    2088:	df 90       	pop	r13
    208a:	08 95       	ret

0000208c <xTaskResumeAll>:
    208c:	df 92       	push	r13
    208e:	ef 92       	push	r14
    2090:	ff 92       	push	r15
    2092:	0f 93       	push	r16
    2094:	1f 93       	push	r17
    2096:	cf 93       	push	r28
    2098:	df 93       	push	r29
    209a:	0f b6       	in	r0, 0x3f	; 63
    209c:	f8 94       	cli
    209e:	0f 92       	push	r0
    20a0:	80 91 36 22 	lds	r24, 0x2236	; 0x802236 <uxSchedulerSuspended>
    20a4:	81 50       	subi	r24, 0x01	; 1
    20a6:	80 93 36 22 	sts	0x2236, r24	; 0x802236 <uxSchedulerSuspended>
    20aa:	80 91 36 22 	lds	r24, 0x2236	; 0x802236 <uxSchedulerSuspended>
    20ae:	81 11       	cpse	r24, r1
    20b0:	5d c0       	rjmp	.+186    	; 0x216c <xTaskResumeAll+0xe0>
    20b2:	80 91 41 22 	lds	r24, 0x2241	; 0x802241 <uxCurrentNumberOfTasks>
    20b6:	81 11       	cpse	r24, r1
    20b8:	30 c0       	rjmp	.+96     	; 0x211a <xTaskResumeAll+0x8e>
    20ba:	5b c0       	rjmp	.+182    	; 0x2172 <xTaskResumeAll+0xe6>
    20bc:	d7 01       	movw	r26, r14
    20be:	15 96       	adiw	r26, 0x05	; 5
    20c0:	ed 91       	ld	r30, X+
    20c2:	fc 91       	ld	r31, X
    20c4:	16 97       	sbiw	r26, 0x06	; 6
    20c6:	c6 81       	ldd	r28, Z+6	; 0x06
    20c8:	d7 81       	ldd	r29, Z+7	; 0x07
    20ca:	ce 01       	movw	r24, r28
    20cc:	0c 96       	adiw	r24, 0x0c	; 12
    20ce:	59 d9       	rcall	.-3406   	; 0x1382 <uxListRemove>
    20d0:	8e 01       	movw	r16, r28
    20d2:	0e 5f       	subi	r16, 0xFE	; 254
    20d4:	1f 4f       	sbci	r17, 0xFF	; 255
    20d6:	c8 01       	movw	r24, r16
    20d8:	54 d9       	rcall	.-3416   	; 0x1382 <uxListRemove>
    20da:	8e 89       	ldd	r24, Y+22	; 0x16
    20dc:	90 91 3e 22 	lds	r25, 0x223E	; 0x80223e <uxTopReadyPriority>
    20e0:	98 17       	cp	r25, r24
    20e2:	10 f4       	brcc	.+4      	; 0x20e8 <xTaskResumeAll+0x5c>
    20e4:	80 93 3e 22 	sts	0x223E, r24	; 0x80223e <uxTopReadyPriority>
    20e8:	90 e0       	ldi	r25, 0x00	; 0
    20ea:	9c 01       	movw	r18, r24
    20ec:	22 0f       	add	r18, r18
    20ee:	33 1f       	adc	r19, r19
    20f0:	22 0f       	add	r18, r18
    20f2:	33 1f       	adc	r19, r19
    20f4:	22 0f       	add	r18, r18
    20f6:	33 1f       	adc	r19, r19
    20f8:	82 0f       	add	r24, r18
    20fa:	93 1f       	adc	r25, r19
    20fc:	b8 01       	movw	r22, r16
    20fe:	8f 59       	subi	r24, 0x9F	; 159
    2100:	9d 4d       	sbci	r25, 0xDD	; 221
    2102:	ed d8       	rcall	.-3622   	; 0x12de <vListInsertEnd>
    2104:	e0 91 8e 22 	lds	r30, 0x228E	; 0x80228e <pxCurrentTCB>
    2108:	f0 91 8f 22 	lds	r31, 0x228F	; 0x80228f <pxCurrentTCB+0x1>
    210c:	9e 89       	ldd	r25, Y+22	; 0x16
    210e:	86 89       	ldd	r24, Z+22	; 0x16
    2110:	98 17       	cp	r25, r24
    2112:	58 f0       	brcs	.+22     	; 0x212a <xTaskResumeAll+0x9e>
    2114:	d0 92 3b 22 	sts	0x223B, r13	; 0x80223b <xYieldPending>
    2118:	08 c0       	rjmp	.+16     	; 0x212a <xTaskResumeAll+0x9e>
    211a:	0f 2e       	mov	r0, r31
    211c:	f2 e4       	ldi	r31, 0x42	; 66
    211e:	ef 2e       	mov	r14, r31
    2120:	f2 e2       	ldi	r31, 0x22	; 34
    2122:	ff 2e       	mov	r15, r31
    2124:	f0 2d       	mov	r31, r0
    2126:	dd 24       	eor	r13, r13
    2128:	d3 94       	inc	r13
    212a:	f7 01       	movw	r30, r14
    212c:	80 81       	ld	r24, Z
    212e:	81 11       	cpse	r24, r1
    2130:	c5 cf       	rjmp	.-118    	; 0x20bc <xTaskResumeAll+0x30>
    2132:	80 91 3c 22 	lds	r24, 0x223C	; 0x80223c <uxPendedTicks>
    2136:	88 23       	and	r24, r24
    2138:	91 f0       	breq	.+36     	; 0x215e <xTaskResumeAll+0xd2>
    213a:	80 91 3c 22 	lds	r24, 0x223C	; 0x80223c <uxPendedTicks>
    213e:	88 23       	and	r24, r24
    2140:	71 f0       	breq	.+28     	; 0x215e <xTaskResumeAll+0xd2>
    2142:	c1 e0       	ldi	r28, 0x01	; 1
    2144:	d0 de       	rcall	.-608    	; 0x1ee6 <xTaskIncrementTick>
    2146:	81 11       	cpse	r24, r1
    2148:	c0 93 3b 22 	sts	0x223B, r28	; 0x80223b <xYieldPending>
    214c:	80 91 3c 22 	lds	r24, 0x223C	; 0x80223c <uxPendedTicks>
    2150:	81 50       	subi	r24, 0x01	; 1
    2152:	80 93 3c 22 	sts	0x223C, r24	; 0x80223c <uxPendedTicks>
    2156:	80 91 3c 22 	lds	r24, 0x223C	; 0x80223c <uxPendedTicks>
    215a:	81 11       	cpse	r24, r1
    215c:	f3 cf       	rjmp	.-26     	; 0x2144 <xTaskResumeAll+0xb8>
    215e:	80 91 3b 22 	lds	r24, 0x223B	; 0x80223b <xYieldPending>
    2162:	81 30       	cpi	r24, 0x01	; 1
    2164:	29 f4       	brne	.+10     	; 0x2170 <xTaskResumeAll+0xe4>
    2166:	ef d9       	rcall	.-3106   	; 0x1546 <vPortYield>
    2168:	81 e0       	ldi	r24, 0x01	; 1
    216a:	03 c0       	rjmp	.+6      	; 0x2172 <xTaskResumeAll+0xe6>
    216c:	80 e0       	ldi	r24, 0x00	; 0
    216e:	01 c0       	rjmp	.+2      	; 0x2172 <xTaskResumeAll+0xe6>
    2170:	80 e0       	ldi	r24, 0x00	; 0
    2172:	0f 90       	pop	r0
    2174:	0f be       	out	0x3f, r0	; 63
    2176:	df 91       	pop	r29
    2178:	cf 91       	pop	r28
    217a:	1f 91       	pop	r17
    217c:	0f 91       	pop	r16
    217e:	ff 90       	pop	r15
    2180:	ef 90       	pop	r14
    2182:	df 90       	pop	r13
    2184:	08 95       	ret

00002186 <vTaskDelay>:
    2186:	cf 93       	push	r28
    2188:	df 93       	push	r29
    218a:	ec 01       	movw	r28, r24
    218c:	89 2b       	or	r24, r25
    218e:	91 f0       	breq	.+36     	; 0x21b4 <vTaskDelay+0x2e>
    2190:	9a de       	rcall	.-716    	; 0x1ec6 <vTaskSuspendAll>
    2192:	80 91 3f 22 	lds	r24, 0x223F	; 0x80223f <xTickCount>
    2196:	90 91 40 22 	lds	r25, 0x2240	; 0x802240 <xTickCount+0x1>
    219a:	c8 0f       	add	r28, r24
    219c:	d9 1f       	adc	r29, r25
    219e:	80 91 8e 22 	lds	r24, 0x228E	; 0x80228e <pxCurrentTCB>
    21a2:	90 91 8f 22 	lds	r25, 0x228F	; 0x80228f <pxCurrentTCB+0x1>
    21a6:	02 96       	adiw	r24, 0x02	; 2
    21a8:	ec d8       	rcall	.-3624   	; 0x1382 <uxListRemove>
    21aa:	ce 01       	movw	r24, r28
    21ac:	23 dd       	rcall	.-1466   	; 0x1bf4 <prvAddCurrentTaskToDelayedList>
    21ae:	6e df       	rcall	.-292    	; 0x208c <xTaskResumeAll>
    21b0:	81 11       	cpse	r24, r1
    21b2:	01 c0       	rjmp	.+2      	; 0x21b6 <vTaskDelay+0x30>
    21b4:	c8 d9       	rcall	.-3184   	; 0x1546 <vPortYield>
    21b6:	df 91       	pop	r29
    21b8:	cf 91       	pop	r28
    21ba:	08 95       	ret

000021bc <vTaskSwitchContext>:
    21bc:	80 91 36 22 	lds	r24, 0x2236	; 0x802236 <uxSchedulerSuspended>
    21c0:	88 23       	and	r24, r24
    21c2:	21 f0       	breq	.+8      	; 0x21cc <vTaskSwitchContext+0x10>
    21c4:	81 e0       	ldi	r24, 0x01	; 1
    21c6:	80 93 3b 22 	sts	0x223B, r24	; 0x80223b <xYieldPending>
    21ca:	08 95       	ret
    21cc:	10 92 3b 22 	sts	0x223B, r1	; 0x80223b <xYieldPending>
    21d0:	80 91 3e 22 	lds	r24, 0x223E	; 0x80223e <uxTopReadyPriority>
    21d4:	90 e0       	ldi	r25, 0x00	; 0
    21d6:	fc 01       	movw	r30, r24
    21d8:	ee 0f       	add	r30, r30
    21da:	ff 1f       	adc	r31, r31
    21dc:	ee 0f       	add	r30, r30
    21de:	ff 1f       	adc	r31, r31
    21e0:	ee 0f       	add	r30, r30
    21e2:	ff 1f       	adc	r31, r31
    21e4:	8e 0f       	add	r24, r30
    21e6:	9f 1f       	adc	r25, r31
    21e8:	fc 01       	movw	r30, r24
    21ea:	ef 59       	subi	r30, 0x9F	; 159
    21ec:	fd 4d       	sbci	r31, 0xDD	; 221
    21ee:	80 81       	ld	r24, Z
    21f0:	81 11       	cpse	r24, r1
    21f2:	17 c0       	rjmp	.+46     	; 0x2222 <vTaskSwitchContext+0x66>
    21f4:	80 91 3e 22 	lds	r24, 0x223E	; 0x80223e <uxTopReadyPriority>
    21f8:	81 50       	subi	r24, 0x01	; 1
    21fa:	80 93 3e 22 	sts	0x223E, r24	; 0x80223e <uxTopReadyPriority>
    21fe:	80 91 3e 22 	lds	r24, 0x223E	; 0x80223e <uxTopReadyPriority>
    2202:	90 e0       	ldi	r25, 0x00	; 0
    2204:	fc 01       	movw	r30, r24
    2206:	ee 0f       	add	r30, r30
    2208:	ff 1f       	adc	r31, r31
    220a:	ee 0f       	add	r30, r30
    220c:	ff 1f       	adc	r31, r31
    220e:	ee 0f       	add	r30, r30
    2210:	ff 1f       	adc	r31, r31
    2212:	8e 0f       	add	r24, r30
    2214:	9f 1f       	adc	r25, r31
    2216:	fc 01       	movw	r30, r24
    2218:	ef 59       	subi	r30, 0x9F	; 159
    221a:	fd 4d       	sbci	r31, 0xDD	; 221
    221c:	80 81       	ld	r24, Z
    221e:	88 23       	and	r24, r24
    2220:	49 f3       	breq	.-46     	; 0x21f4 <vTaskSwitchContext+0x38>
    2222:	80 91 3e 22 	lds	r24, 0x223E	; 0x80223e <uxTopReadyPriority>
    2226:	90 e0       	ldi	r25, 0x00	; 0
    2228:	9c 01       	movw	r18, r24
    222a:	22 0f       	add	r18, r18
    222c:	33 1f       	adc	r19, r19
    222e:	22 0f       	add	r18, r18
    2230:	33 1f       	adc	r19, r19
    2232:	22 0f       	add	r18, r18
    2234:	33 1f       	adc	r19, r19
    2236:	28 0f       	add	r18, r24
    2238:	39 1f       	adc	r19, r25
    223a:	d9 01       	movw	r26, r18
    223c:	af 59       	subi	r26, 0x9F	; 159
    223e:	bd 4d       	sbci	r27, 0xDD	; 221
    2240:	11 96       	adiw	r26, 0x01	; 1
    2242:	ed 91       	ld	r30, X+
    2244:	fc 91       	ld	r31, X
    2246:	12 97       	sbiw	r26, 0x02	; 2
    2248:	02 80       	ldd	r0, Z+2	; 0x02
    224a:	f3 81       	ldd	r31, Z+3	; 0x03
    224c:	e0 2d       	mov	r30, r0
    224e:	11 96       	adiw	r26, 0x01	; 1
    2250:	ed 93       	st	X+, r30
    2252:	fc 93       	st	X, r31
    2254:	12 97       	sbiw	r26, 0x02	; 2
    2256:	2c 59       	subi	r18, 0x9C	; 156
    2258:	3d 4d       	sbci	r19, 0xDD	; 221
    225a:	e2 17       	cp	r30, r18
    225c:	f3 07       	cpc	r31, r19
    225e:	29 f4       	brne	.+10     	; 0x226a <vTaskSwitchContext+0xae>
    2260:	22 81       	ldd	r18, Z+2	; 0x02
    2262:	33 81       	ldd	r19, Z+3	; 0x03
    2264:	fd 01       	movw	r30, r26
    2266:	21 83       	std	Z+1, r18	; 0x01
    2268:	32 83       	std	Z+2, r19	; 0x02
    226a:	fc 01       	movw	r30, r24
    226c:	ee 0f       	add	r30, r30
    226e:	ff 1f       	adc	r31, r31
    2270:	ee 0f       	add	r30, r30
    2272:	ff 1f       	adc	r31, r31
    2274:	ee 0f       	add	r30, r30
    2276:	ff 1f       	adc	r31, r31
    2278:	8e 0f       	add	r24, r30
    227a:	9f 1f       	adc	r25, r31
    227c:	fc 01       	movw	r30, r24
    227e:	ef 59       	subi	r30, 0x9F	; 159
    2280:	fd 4d       	sbci	r31, 0xDD	; 221
    2282:	01 80       	ldd	r0, Z+1	; 0x01
    2284:	f2 81       	ldd	r31, Z+2	; 0x02
    2286:	e0 2d       	mov	r30, r0
    2288:	86 81       	ldd	r24, Z+6	; 0x06
    228a:	97 81       	ldd	r25, Z+7	; 0x07
    228c:	80 93 8e 22 	sts	0x228E, r24	; 0x80228e <pxCurrentTCB>
    2290:	90 93 8f 22 	sts	0x228F, r25	; 0x80228f <pxCurrentTCB+0x1>
    2294:	08 95       	ret

00002296 <vTaskPlaceOnEventList>:
    2296:	cf 93       	push	r28
    2298:	df 93       	push	r29
    229a:	eb 01       	movw	r28, r22
    229c:	60 91 8e 22 	lds	r22, 0x228E	; 0x80228e <pxCurrentTCB>
    22a0:	70 91 8f 22 	lds	r23, 0x228F	; 0x80228f <pxCurrentTCB+0x1>
    22a4:	64 5f       	subi	r22, 0xF4	; 244
    22a6:	7f 4f       	sbci	r23, 0xFF	; 255
    22a8:	3b d8       	rcall	.-3978   	; 0x1320 <vListInsert>
    22aa:	80 91 8e 22 	lds	r24, 0x228E	; 0x80228e <pxCurrentTCB>
    22ae:	90 91 8f 22 	lds	r25, 0x228F	; 0x80228f <pxCurrentTCB+0x1>
    22b2:	02 96       	adiw	r24, 0x02	; 2
    22b4:	66 d8       	rcall	.-3892   	; 0x1382 <uxListRemove>
    22b6:	80 91 3f 22 	lds	r24, 0x223F	; 0x80223f <xTickCount>
    22ba:	90 91 40 22 	lds	r25, 0x2240	; 0x802240 <xTickCount+0x1>
    22be:	8c 0f       	add	r24, r28
    22c0:	9d 1f       	adc	r25, r29
    22c2:	98 dc       	rcall	.-1744   	; 0x1bf4 <prvAddCurrentTaskToDelayedList>
    22c4:	df 91       	pop	r29
    22c6:	cf 91       	pop	r28
    22c8:	08 95       	ret

000022ca <vTaskPlaceOnEventListRestricted>:
    22ca:	cf 93       	push	r28
    22cc:	df 93       	push	r29
    22ce:	eb 01       	movw	r28, r22
    22d0:	60 91 8e 22 	lds	r22, 0x228E	; 0x80228e <pxCurrentTCB>
    22d4:	70 91 8f 22 	lds	r23, 0x228F	; 0x80228f <pxCurrentTCB+0x1>
    22d8:	64 5f       	subi	r22, 0xF4	; 244
    22da:	7f 4f       	sbci	r23, 0xFF	; 255
    22dc:	00 d8       	rcall	.-4096   	; 0x12de <vListInsertEnd>
    22de:	80 91 8e 22 	lds	r24, 0x228E	; 0x80228e <pxCurrentTCB>
    22e2:	90 91 8f 22 	lds	r25, 0x228F	; 0x80228f <pxCurrentTCB+0x1>
    22e6:	02 96       	adiw	r24, 0x02	; 2
    22e8:	4c d8       	rcall	.-3944   	; 0x1382 <uxListRemove>
    22ea:	80 91 3f 22 	lds	r24, 0x223F	; 0x80223f <xTickCount>
    22ee:	90 91 40 22 	lds	r25, 0x2240	; 0x802240 <xTickCount+0x1>
    22f2:	8c 0f       	add	r24, r28
    22f4:	9d 1f       	adc	r25, r29
    22f6:	7e dc       	rcall	.-1796   	; 0x1bf4 <prvAddCurrentTaskToDelayedList>
    22f8:	df 91       	pop	r29
    22fa:	cf 91       	pop	r28
    22fc:	08 95       	ret

000022fe <xTaskRemoveFromEventList>:
    22fe:	0f 93       	push	r16
    2300:	1f 93       	push	r17
    2302:	cf 93       	push	r28
    2304:	df 93       	push	r29
    2306:	dc 01       	movw	r26, r24
    2308:	15 96       	adiw	r26, 0x05	; 5
    230a:	ed 91       	ld	r30, X+
    230c:	fc 91       	ld	r31, X
    230e:	16 97       	sbiw	r26, 0x06	; 6
    2310:	c6 81       	ldd	r28, Z+6	; 0x06
    2312:	d7 81       	ldd	r29, Z+7	; 0x07
    2314:	8e 01       	movw	r16, r28
    2316:	04 5f       	subi	r16, 0xF4	; 244
    2318:	1f 4f       	sbci	r17, 0xFF	; 255
    231a:	c8 01       	movw	r24, r16
    231c:	32 d8       	rcall	.-3996   	; 0x1382 <uxListRemove>
    231e:	80 91 36 22 	lds	r24, 0x2236	; 0x802236 <uxSchedulerSuspended>
    2322:	81 11       	cpse	r24, r1
    2324:	1b c0       	rjmp	.+54     	; 0x235c <xTaskRemoveFromEventList+0x5e>
    2326:	0a 50       	subi	r16, 0x0A	; 10
    2328:	11 09       	sbc	r17, r1
    232a:	c8 01       	movw	r24, r16
    232c:	2a d8       	rcall	.-4012   	; 0x1382 <uxListRemove>
    232e:	8e 89       	ldd	r24, Y+22	; 0x16
    2330:	90 91 3e 22 	lds	r25, 0x223E	; 0x80223e <uxTopReadyPriority>
    2334:	98 17       	cp	r25, r24
    2336:	10 f4       	brcc	.+4      	; 0x233c <xTaskRemoveFromEventList+0x3e>
    2338:	80 93 3e 22 	sts	0x223E, r24	; 0x80223e <uxTopReadyPriority>
    233c:	90 e0       	ldi	r25, 0x00	; 0
    233e:	9c 01       	movw	r18, r24
    2340:	22 0f       	add	r18, r18
    2342:	33 1f       	adc	r19, r19
    2344:	22 0f       	add	r18, r18
    2346:	33 1f       	adc	r19, r19
    2348:	22 0f       	add	r18, r18
    234a:	33 1f       	adc	r19, r19
    234c:	82 0f       	add	r24, r18
    234e:	93 1f       	adc	r25, r19
    2350:	b8 01       	movw	r22, r16
    2352:	8f 59       	subi	r24, 0x9F	; 159
    2354:	9d 4d       	sbci	r25, 0xDD	; 221
    2356:	0e 94 6f 09 	call	0x12de	; 0x12de <vListInsertEnd>
    235a:	05 c0       	rjmp	.+10     	; 0x2366 <xTaskRemoveFromEventList+0x68>
    235c:	b8 01       	movw	r22, r16
    235e:	82 e4       	ldi	r24, 0x42	; 66
    2360:	92 e2       	ldi	r25, 0x22	; 34
    2362:	0e 94 6f 09 	call	0x12de	; 0x12de <vListInsertEnd>
    2366:	e0 91 8e 22 	lds	r30, 0x228E	; 0x80228e <pxCurrentTCB>
    236a:	f0 91 8f 22 	lds	r31, 0x228F	; 0x80228f <pxCurrentTCB+0x1>
    236e:	9e 89       	ldd	r25, Y+22	; 0x16
    2370:	86 89       	ldd	r24, Z+22	; 0x16
    2372:	89 17       	cp	r24, r25
    2374:	20 f4       	brcc	.+8      	; 0x237e <xTaskRemoveFromEventList+0x80>
    2376:	81 e0       	ldi	r24, 0x01	; 1
    2378:	80 93 3b 22 	sts	0x223B, r24	; 0x80223b <xYieldPending>
    237c:	01 c0       	rjmp	.+2      	; 0x2380 <xTaskRemoveFromEventList+0x82>
    237e:	80 e0       	ldi	r24, 0x00	; 0
    2380:	df 91       	pop	r29
    2382:	cf 91       	pop	r28
    2384:	1f 91       	pop	r17
    2386:	0f 91       	pop	r16
    2388:	08 95       	ret

0000238a <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    238a:	20 91 3a 22 	lds	r18, 0x223A	; 0x80223a <xNumOfOverflows>
    238e:	fc 01       	movw	r30, r24
    2390:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    2392:	20 91 3f 22 	lds	r18, 0x223F	; 0x80223f <xTickCount>
    2396:	30 91 40 22 	lds	r19, 0x2240	; 0x802240 <xTickCount+0x1>
    239a:	21 83       	std	Z+1, r18	; 0x01
    239c:	32 83       	std	Z+2, r19	; 0x02
    239e:	08 95       	ret

000023a0 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    23a0:	cf 93       	push	r28
    23a2:	df 93       	push	r29
    23a4:	fc 01       	movw	r30, r24
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    23a6:	0f b6       	in	r0, 0x3f	; 63
    23a8:	f8 94       	cli
    23aa:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    23ac:	20 91 3f 22 	lds	r18, 0x223F	; 0x80223f <xTickCount>
    23b0:	30 91 40 22 	lds	r19, 0x2240	; 0x802240 <xTickCount+0x1>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    23b4:	80 91 3a 22 	lds	r24, 0x223A	; 0x80223a <xNumOfOverflows>
    23b8:	90 81       	ld	r25, Z
    23ba:	98 17       	cp	r25, r24
    23bc:	29 f0       	breq	.+10     	; 0x23c8 <xTaskCheckForTimeOut+0x28>
    23be:	81 81       	ldd	r24, Z+1	; 0x01
    23c0:	92 81       	ldd	r25, Z+2	; 0x02
    23c2:	28 17       	cp	r18, r24
    23c4:	39 07       	cpc	r19, r25
    23c6:	a8 f4       	brcc	.+42     	; 0x23f2 <xTaskCheckForTimeOut+0x52>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    23c8:	a1 81       	ldd	r26, Z+1	; 0x01
    23ca:	b2 81       	ldd	r27, Z+2	; 0x02
    23cc:	eb 01       	movw	r28, r22
    23ce:	48 81       	ld	r20, Y
    23d0:	59 81       	ldd	r21, Y+1	; 0x01
    23d2:	c9 01       	movw	r24, r18
    23d4:	8a 1b       	sub	r24, r26
    23d6:	9b 0b       	sbc	r25, r27
    23d8:	84 17       	cp	r24, r20
    23da:	95 07       	cpc	r25, r21
    23dc:	60 f4       	brcc	.+24     	; 0x23f6 <xTaskCheckForTimeOut+0x56>
    23de:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
    23e0:	a2 1b       	sub	r26, r18
    23e2:	b3 0b       	sbc	r27, r19
    23e4:	4a 0f       	add	r20, r26
    23e6:	5b 1f       	adc	r21, r27
    23e8:	48 83       	st	Y, r20
			vTaskSetTimeOutState( pxTimeOut );
    23ea:	59 83       	std	Y+1, r21	; 0x01
			xReturn = pdFALSE;
    23ec:	ce df       	rcall	.-100    	; 0x238a <vTaskSetTimeOutState>
    23ee:	80 e0       	ldi	r24, 0x00	; 0
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    23f0:	03 c0       	rjmp	.+6      	; 0x23f8 <xTaskCheckForTimeOut+0x58>
    23f2:	81 e0       	ldi	r24, 0x01	; 1
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    23f4:	01 c0       	rjmp	.+2      	; 0x23f8 <xTaskCheckForTimeOut+0x58>
		}
	}
	taskEXIT_CRITICAL();
    23f6:	81 e0       	ldi	r24, 0x01	; 1
    23f8:	0f 90       	pop	r0

	return xReturn;
}
    23fa:	0f be       	out	0x3f, r0	; 63
    23fc:	df 91       	pop	r29
    23fe:	cf 91       	pop	r28
    2400:	08 95       	ret

00002402 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    2402:	81 e0       	ldi	r24, 0x01	; 1
    2404:	80 93 3b 22 	sts	0x223B, r24	; 0x80223b <xYieldPending>
    2408:	08 95       	ret

0000240a <xTaskGetSchedulerState>:

	BaseType_t xTaskGetSchedulerState( void )
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
    240a:	80 91 3d 22 	lds	r24, 0x223D	; 0x80223d <xSchedulerRunning>
    240e:	88 23       	and	r24, r24
    2410:	31 f0       	breq	.+12     	; 0x241e <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2412:	80 91 36 22 	lds	r24, 0x2236	; 0x802236 <uxSchedulerSuspended>
    2416:	88 23       	and	r24, r24
    2418:	21 f0       	breq	.+8      	; 0x2422 <xTaskGetSchedulerState+0x18>
			{
				xReturn = taskSCHEDULER_RUNNING;
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
    241a:	80 e0       	ldi	r24, 0x00	; 0
    241c:	08 95       	ret
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
    241e:	81 e0       	ldi	r24, 0x01	; 1
    2420:	08 95       	ret
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
			{
				xReturn = taskSCHEDULER_RUNNING;
    2422:	82 e0       	ldi	r24, 0x02	; 2
				xReturn = taskSCHEDULER_SUSPENDED;
			}
		}

		return xReturn;
	}
    2424:	08 95       	ret

00002426 <prvInsertTimerInActiveList>:
	return xTimeNow;
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
    2426:	fc 01       	movw	r30, r24
BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    2428:	62 83       	std	Z+2, r22	; 0x02
    242a:	73 83       	std	Z+3, r23	; 0x03
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    242c:	80 87       	std	Z+8, r24	; 0x08
    242e:	91 87       	std	Z+9, r25	; 0x09

	if( xNextExpiryTime <= xTimeNow )
    2430:	46 17       	cp	r20, r22
    2432:	57 07       	cpc	r21, r23
    2434:	90 f0       	brcs	.+36     	; 0x245a <prvInsertTimerInActiveList+0x34>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( xTimeNow - xCommandTime ) >= pxTimer->xTimerPeriodInTicks )
    2436:	42 1b       	sub	r20, r18
    2438:	53 0b       	sbc	r21, r19
    243a:	84 85       	ldd	r24, Z+12	; 0x0c
    243c:	95 85       	ldd	r25, Z+13	; 0x0d
    243e:	48 17       	cp	r20, r24
    2440:	59 07       	cpc	r21, r25
    2442:	e0 f4       	brcc	.+56     	; 0x247c <prvInsertTimerInActiveList+0x56>
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    2444:	bf 01       	movw	r22, r30
    2446:	6e 5f       	subi	r22, 0xFE	; 254
    2448:	7f 4f       	sbci	r23, 0xFF	; 255
    244a:	80 91 94 22 	lds	r24, 0x2294	; 0x802294 <pxOverflowTimerList>
    244e:	90 91 95 22 	lds	r25, 0x2295	; 0x802295 <pxOverflowTimerList+0x1>
    2452:	0e 94 90 09 	call	0x1320	; 0x1320 <vListInsert>
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
BaseType_t xProcessTimerNow = pdFALSE;
    2456:	80 e0       	ldi	r24, 0x00	; 0
    2458:	08 95       	ret
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    245a:	42 17       	cp	r20, r18
    245c:	53 07       	cpc	r21, r19
    245e:	18 f4       	brcc	.+6      	; 0x2466 <prvInsertTimerInActiveList+0x40>
    2460:	62 17       	cp	r22, r18
    2462:	73 07       	cpc	r23, r19
    2464:	68 f4       	brcc	.+26     	; 0x2480 <prvInsertTimerInActiveList+0x5a>
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    2466:	bf 01       	movw	r22, r30
    2468:	6e 5f       	subi	r22, 0xFE	; 254
    246a:	7f 4f       	sbci	r23, 0xFF	; 255
    246c:	80 91 96 22 	lds	r24, 0x2296	; 0x802296 <pxCurrentTimerList>
    2470:	90 91 97 22 	lds	r25, 0x2297	; 0x802297 <pxCurrentTimerList+0x1>
    2474:	0e 94 90 09 	call	0x1320	; 0x1320 <vListInsert>
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
BaseType_t xProcessTimerNow = pdFALSE;
    2478:	80 e0       	ldi	r24, 0x00	; 0
    247a:	08 95       	ret
		timer was issued, and the time the command was processed? */
		if( ( xTimeNow - xCommandTime ) >= pxTimer->xTimerPeriodInTicks )
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
    247c:	81 e0       	ldi	r24, 0x01	; 1
    247e:	08 95       	ret
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
		{
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
    2480:	81 e0       	ldi	r24, 0x01	; 1
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
		}
	}

	return xProcessTimerNow;
}
    2482:	08 95       	ret

00002484 <prvCheckForValidListAndQueue>:
static void prvCheckForValidListAndQueue( void )
{
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
    2484:	0f b6       	in	r0, 0x3f	; 63
    2486:	f8 94       	cli
    2488:	0f 92       	push	r0
	{
		if( xTimerQueue == NULL )
    248a:	80 91 92 22 	lds	r24, 0x2292	; 0x802292 <xTimerQueue>
    248e:	90 91 93 22 	lds	r25, 0x2293	; 0x802293 <xTimerQueue+0x1>
    2492:	89 2b       	or	r24, r25
    2494:	e1 f4       	brne	.+56     	; 0x24ce <prvCheckForValidListAndQueue+0x4a>
		{
			vListInitialise( &xActiveTimerList1 );
    2496:	81 ea       	ldi	r24, 0xA1	; 161
    2498:	92 e2       	ldi	r25, 0x22	; 34
    249a:	0e 94 5d 09 	call	0x12ba	; 0x12ba <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
    249e:	88 e9       	ldi	r24, 0x98	; 152
    24a0:	92 e2       	ldi	r25, 0x22	; 34
    24a2:	0e 94 5d 09 	call	0x12ba	; 0x12ba <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
    24a6:	81 ea       	ldi	r24, 0xA1	; 161
    24a8:	92 e2       	ldi	r25, 0x22	; 34
    24aa:	80 93 96 22 	sts	0x2296, r24	; 0x802296 <pxCurrentTimerList>
    24ae:	90 93 97 22 	sts	0x2297, r25	; 0x802297 <pxCurrentTimerList+0x1>
			pxOverflowTimerList = &xActiveTimerList2;
    24b2:	88 e9       	ldi	r24, 0x98	; 152
    24b4:	92 e2       	ldi	r25, 0x22	; 34
    24b6:	80 93 94 22 	sts	0x2294, r24	; 0x802294 <pxOverflowTimerList>
    24ba:	90 93 95 22 	sts	0x2295, r25	; 0x802295 <pxOverflowTimerList+0x1>
			xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    24be:	40 e0       	ldi	r20, 0x00	; 0
    24c0:	65 e0       	ldi	r22, 0x05	; 5
    24c2:	8a e0       	ldi	r24, 0x0A	; 10
    24c4:	f2 d9       	rcall	.-3100   	; 0x18aa <xQueueGenericCreate>
    24c6:	80 93 92 22 	sts	0x2292, r24	; 0x802292 <xTimerQueue>
    24ca:	90 93 93 22 	sts	0x2293, r25	; 0x802293 <xTimerQueue+0x1>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    24ce:	0f 90       	pop	r0
    24d0:	0f be       	out	0x3f, r0	; 63
    24d2:	08 95       	ret

000024d4 <xTimerCreateTimerTask>:
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty ) PRIVILEGED_FUNCTION;

/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
    24d4:	af 92       	push	r10
    24d6:	bf 92       	push	r11
    24d8:	cf 92       	push	r12
    24da:	df 92       	push	r13
    24dc:	ef 92       	push	r14
    24de:	ff 92       	push	r15

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
    24e0:	0f 93       	push	r16

	if( xTimerQueue != NULL )
    24e2:	d0 df       	rcall	.-96     	; 0x2484 <prvCheckForValidListAndQueue>
    24e4:	80 91 92 22 	lds	r24, 0x2292	; 0x802292 <xTimerQueue>
    24e8:	90 91 93 22 	lds	r25, 0x2293	; 0x802293 <xTimerQueue+0x1>
    24ec:	89 2b       	or	r24, r25
			xReturn = xTaskCreate( prvTimerTask, "Tmr Svc", ( uint16_t ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, &xTimerTaskHandle );
		}
		#else
		{
			/* Create the timer task without storing its handle. */
			xReturn = xTaskCreate( prvTimerTask, "Tmr Svc", ( uint16_t ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, NULL);
    24ee:	89 f0       	breq	.+34     	; 0x2512 <xTimerCreateTimerTask+0x3e>
    24f0:	a1 2c       	mov	r10, r1
    24f2:	b1 2c       	mov	r11, r1
    24f4:	c1 2c       	mov	r12, r1
    24f6:	d1 2c       	mov	r13, r1
    24f8:	e1 2c       	mov	r14, r1
    24fa:	f1 2c       	mov	r15, r1
    24fc:	03 e0       	ldi	r16, 0x03	; 3
    24fe:	20 e0       	ldi	r18, 0x00	; 0
    2500:	30 e0       	ldi	r19, 0x00	; 0
    2502:	45 e5       	ldi	r20, 0x55	; 85
    2504:	50 e0       	ldi	r21, 0x00	; 0
    2506:	62 e1       	ldi	r22, 0x12	; 18
    2508:	70 e2       	ldi	r23, 0x20	; 32
    250a:	88 e7       	ldi	r24, 0x78	; 120
    250c:	93 e1       	ldi	r25, 0x13	; 19
    250e:	a7 db       	rcall	.-2226   	; 0x1c5e <xTaskGenericCreate>

/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
BaseType_t xReturn = pdFAIL;
    2510:	01 c0       	rjmp	.+2      	; 0x2514 <xTimerCreateTimerTask+0x40>
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );
	return xReturn;
}
    2512:	80 e0       	ldi	r24, 0x00	; 0
    2514:	0f 91       	pop	r16
    2516:	ff 90       	pop	r15
    2518:	ef 90       	pop	r14
    251a:	df 90       	pop	r13
    251c:	cf 90       	pop	r12
    251e:	bf 90       	pop	r11
    2520:	af 90       	pop	r10
    2522:	08 95       	ret

00002524 <xTimerCreate>:
/*-----------------------------------------------------------*/

TimerHandle_t xTimerCreate( const char * const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void * const pvTimerID, TimerCallbackFunction_t pxCallbackFunction ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    2524:	8f 92       	push	r8
    2526:	9f 92       	push	r9
    2528:	bf 92       	push	r11
    252a:	cf 92       	push	r12
    252c:	df 92       	push	r13
    252e:	ef 92       	push	r14
    2530:	ff 92       	push	r15
    2532:	0f 93       	push	r16
    2534:	1f 93       	push	r17
    2536:	cf 93       	push	r28
    2538:	df 93       	push	r29
Timer_t *pxNewTimer;

	/* Allocate the timer structure. */
	if( xTimerPeriodInTicks == ( TickType_t ) 0U )
    253a:	61 15       	cp	r22, r1
    253c:	71 05       	cpc	r23, r1
    253e:	c9 f0       	breq	.+50     	; 0x2572 <xTimerCreate+0x4e>
    2540:	69 01       	movw	r12, r18
    2542:	b4 2e       	mov	r11, r20
    2544:	7b 01       	movw	r14, r22
    2546:	4c 01       	movw	r8, r24
	{
		pxNewTimer = NULL;
	}
	else
	{
		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) );
    2548:	83 e1       	ldi	r24, 0x13	; 19
    254a:	90 e0       	ldi	r25, 0x00	; 0
    254c:	ae d8       	rcall	.-3748   	; 0x16aa <pvPortMalloc>
    254e:	ec 01       	movw	r28, r24
		if( pxNewTimer != NULL )
    2550:	89 2b       	or	r24, r25
		{
			/* Ensure the infrastructure used by the timer service task has been
			created/initialised. */
			prvCheckForValidListAndQueue();
    2552:	89 f0       	breq	.+34     	; 0x2576 <xTimerCreate+0x52>

			/* Initialise the timer structure members using the function parameters. */
			pxNewTimer->pcTimerName = pcTimerName;
    2554:	97 df       	rcall	.-210    	; 0x2484 <prvCheckForValidListAndQueue>
    2556:	88 82       	st	Y, r8
			pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
    2558:	99 82       	std	Y+1, r9	; 0x01
    255a:	ec 86       	std	Y+12, r14	; 0x0c
			pxNewTimer->uxAutoReload = uxAutoReload;
    255c:	fd 86       	std	Y+13, r15	; 0x0d
			pxNewTimer->pvTimerID = pvTimerID;
    255e:	be 86       	std	Y+14, r11	; 0x0e
    2560:	cf 86       	std	Y+15, r12	; 0x0f
			pxNewTimer->pxCallbackFunction = pxCallbackFunction;
    2562:	d8 8a       	std	Y+16, r13	; 0x10
    2564:	09 8b       	std	Y+17, r16	; 0x11
			vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
    2566:	1a 8b       	std	Y+18, r17	; 0x12
    2568:	ce 01       	movw	r24, r28
    256a:	02 96       	adiw	r24, 0x02	; 2
    256c:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <vListInitialiseItem>
Timer_t *pxNewTimer;

	/* Allocate the timer structure. */
	if( xTimerPeriodInTicks == ( TickType_t ) 0U )
	{
		pxNewTimer = NULL;
    2570:	02 c0       	rjmp	.+4      	; 0x2576 <xTimerCreate+0x52>
    2572:	c0 e0       	ldi	r28, 0x00	; 0

	/* 0 is not a valid value for xTimerPeriodInTicks. */
	configASSERT( ( xTimerPeriodInTicks > 0 ) );

	return ( TimerHandle_t ) pxNewTimer;
}
    2574:	d0 e0       	ldi	r29, 0x00	; 0
    2576:	ce 01       	movw	r24, r28
    2578:	df 91       	pop	r29
    257a:	cf 91       	pop	r28
    257c:	1f 91       	pop	r17
    257e:	0f 91       	pop	r16
    2580:	ff 90       	pop	r15
    2582:	ef 90       	pop	r14
    2584:	df 90       	pop	r13
    2586:	cf 90       	pop	r12
    2588:	bf 90       	pop	r11
    258a:	9f 90       	pop	r9
    258c:	8f 90       	pop	r8
    258e:	08 95       	ret

00002590 <xTimerGenericCommand>:
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    2590:	0f 93       	push	r16
    2592:	1f 93       	push	r17
    2594:	cf 93       	push	r28
    2596:	df 93       	push	r29
    2598:	cd b7       	in	r28, 0x3d	; 61
    259a:	de b7       	in	r29, 0x3e	; 62
    259c:	25 97       	sbiw	r28, 0x05	; 5
    259e:	cd bf       	out	0x3d, r28	; 61
    25a0:	de bf       	out	0x3e, r29	; 62

	configASSERT( xTimer );

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
    25a2:	e0 91 92 22 	lds	r30, 0x2292	; 0x802292 <xTimerQueue>
    25a6:	f0 91 93 22 	lds	r31, 0x2293	; 0x802293 <xTimerQueue+0x1>
    25aa:	30 97       	sbiw	r30, 0x00	; 0
    25ac:	51 f1       	breq	.+84     	; 0x2602 <xTimerGenericCommand+0x72>
    25ae:	d9 01       	movw	r26, r18
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
    25b0:	69 83       	std	Y+1, r22	; 0x01
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    25b2:	4a 83       	std	Y+2, r20	; 0x02
    25b4:	5b 83       	std	Y+3, r21	; 0x03
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
    25b6:	8c 83       	std	Y+4, r24	; 0x04
    25b8:	9d 83       	std	Y+5, r25	; 0x05

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    25ba:	66 30       	cpi	r22, 0x06	; 6
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    25bc:	d4 f4       	brge	.+52     	; 0x25f2 <xTimerGenericCommand+0x62>
    25be:	25 df       	rcall	.-438    	; 0x240a <xTaskGetSchedulerState>
    25c0:	82 30       	cpi	r24, 0x02	; 2
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    25c2:	59 f4       	brne	.+22     	; 0x25da <xTimerGenericCommand+0x4a>
    25c4:	20 e0       	ldi	r18, 0x00	; 0
    25c6:	a8 01       	movw	r20, r16
    25c8:	be 01       	movw	r22, r28
    25ca:	6f 5f       	subi	r22, 0xFF	; 255
    25cc:	7f 4f       	sbci	r23, 0xFF	; 255
    25ce:	80 91 92 22 	lds	r24, 0x2292	; 0x802292 <xTimerQueue>
    25d2:	90 91 93 22 	lds	r25, 0x2293	; 0x802293 <xTimerQueue+0x1>
    25d6:	92 d9       	rcall	.-3292   	; 0x18fc <xQueueGenericSend>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    25d8:	15 c0       	rjmp	.+42     	; 0x2604 <xTimerGenericCommand+0x74>
    25da:	20 e0       	ldi	r18, 0x00	; 0
    25dc:	40 e0       	ldi	r20, 0x00	; 0
    25de:	50 e0       	ldi	r21, 0x00	; 0
    25e0:	be 01       	movw	r22, r28
    25e2:	6f 5f       	subi	r22, 0xFF	; 255
    25e4:	7f 4f       	sbci	r23, 0xFF	; 255
    25e6:	80 91 92 22 	lds	r24, 0x2292	; 0x802292 <xTimerQueue>
    25ea:	90 91 93 22 	lds	r25, 0x2293	; 0x802293 <xTimerQueue+0x1>
    25ee:	86 d9       	rcall	.-3316   	; 0x18fc <xQueueGenericSend>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    25f0:	09 c0       	rjmp	.+18     	; 0x2604 <xTimerGenericCommand+0x74>
    25f2:	20 e0       	ldi	r18, 0x00	; 0
    25f4:	ad 01       	movw	r20, r26
    25f6:	be 01       	movw	r22, r28
    25f8:	6f 5f       	subi	r22, 0xFF	; 255
    25fa:	7f 4f       	sbci	r23, 0xFF	; 255
    25fc:	cf 01       	movw	r24, r30
    25fe:	0b da       	rcall	.-3050   	; 0x1a16 <xQueueGenericSendFromISR>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    2600:	01 c0       	rjmp	.+2      	; 0x2604 <xTimerGenericCommand+0x74>
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
    2602:	80 e0       	ldi	r24, 0x00	; 0
    2604:	25 96       	adiw	r28, 0x05	; 5
    2606:	cd bf       	out	0x3d, r28	; 61
    2608:	de bf       	out	0x3e, r29	; 62
    260a:	df 91       	pop	r29
    260c:	cf 91       	pop	r28
    260e:	1f 91       	pop	r17
    2610:	0f 91       	pop	r16
    2612:	08 95       	ret

00002614 <prvSampleTimeNow>:
	return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    2614:	af 92       	push	r10
    2616:	bf 92       	push	r11
    2618:	cf 92       	push	r12
    261a:	df 92       	push	r13
    261c:	ef 92       	push	r14
    261e:	ff 92       	push	r15
    2620:	0f 93       	push	r16
    2622:	1f 93       	push	r17
    2624:	cf 93       	push	r28
    2626:	df 93       	push	r29
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
    2628:	6c 01       	movw	r12, r24
    262a:	53 dc       	rcall	.-1882   	; 0x1ed2 <xTaskGetTickCount>

	if( xTimeNow < xLastTime )
    262c:	7c 01       	movw	r14, r24
    262e:	80 91 90 22 	lds	r24, 0x2290	; 0x802290 <xLastTime.4400>
    2632:	90 91 91 22 	lds	r25, 0x2291	; 0x802291 <xLastTime.4400+0x1>
    2636:	e8 16       	cp	r14, r24
    2638:	f9 06       	cpc	r15, r25
    263a:	08 f0       	brcs	.+2      	; 0x263e <prvSampleTimeNow+0x2a>
    263c:	47 c0       	rjmp	.+142    	; 0x26cc <prvSampleTimeNow+0xb8>
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    263e:	2f c0       	rjmp	.+94     	; 0x269e <prvSampleTimeNow+0x8a>
    2640:	05 80       	ldd	r0, Z+5	; 0x05
    2642:	f6 81       	ldd	r31, Z+6	; 0x06
    2644:	e0 2d       	mov	r30, r0
    2646:	a0 80       	ld	r10, Z

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    2648:	b1 80       	ldd	r11, Z+1	; 0x01
    264a:	c6 81       	ldd	r28, Z+6	; 0x06
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    264c:	d7 81       	ldd	r29, Z+7	; 0x07
    264e:	8e 01       	movw	r16, r28
    2650:	0e 5f       	subi	r16, 0xFE	; 254
    2652:	1f 4f       	sbci	r17, 0xFF	; 255
    2654:	c8 01       	movw	r24, r16
    2656:	0e 94 c1 09 	call	0x1382	; 0x1382 <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    265a:	e9 89       	ldd	r30, Y+17	; 0x11
    265c:	fa 89       	ldd	r31, Y+18	; 0x12
    265e:	ce 01       	movw	r24, r28

		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    2660:	19 95       	eicall
    2662:	8e 85       	ldd	r24, Y+14	; 0x0e
    2664:	81 30       	cpi	r24, 0x01	; 1
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    2666:	d9 f4       	brne	.+54     	; 0x269e <prvSampleTimeNow+0x8a>
    2668:	8c 85       	ldd	r24, Y+12	; 0x0c
    266a:	9d 85       	ldd	r25, Y+13	; 0x0d
    266c:	8a 0d       	add	r24, r10
			if( xReloadTime > xNextExpireTime )
    266e:	9b 1d       	adc	r25, r11
    2670:	a8 16       	cp	r10, r24
    2672:	b9 06       	cpc	r11, r25
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    2674:	60 f4       	brcc	.+24     	; 0x268e <prvSampleTimeNow+0x7a>
    2676:	8a 83       	std	Y+2, r24	; 0x02
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    2678:	9b 83       	std	Y+3, r25	; 0x03
    267a:	c8 87       	std	Y+8, r28	; 0x08
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    267c:	d9 87       	std	Y+9, r29	; 0x09
    267e:	b8 01       	movw	r22, r16
    2680:	80 91 96 22 	lds	r24, 0x2296	; 0x802296 <pxCurrentTimerList>
    2684:	90 91 97 22 	lds	r25, 0x2297	; 0x802297 <pxCurrentTimerList+0x1>
    2688:	0e 94 90 09 	call	0x1320	; 0x1320 <vListInsert>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    268c:	08 c0       	rjmp	.+16     	; 0x269e <prvSampleTimeNow+0x8a>
    268e:	00 e0       	ldi	r16, 0x00	; 0
    2690:	10 e0       	ldi	r17, 0x00	; 0
    2692:	20 e0       	ldi	r18, 0x00	; 0
    2694:	30 e0       	ldi	r19, 0x00	; 0
    2696:	a5 01       	movw	r20, r10
    2698:	60 e0       	ldi	r22, 0x00	; 0
    269a:	ce 01       	movw	r24, r28

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    269c:	79 df       	rcall	.-270    	; 0x2590 <xTimerGenericCommand>
    269e:	e0 91 96 22 	lds	r30, 0x2296	; 0x802296 <pxCurrentTimerList>
    26a2:	f0 91 97 22 	lds	r31, 0x2297	; 0x802297 <pxCurrentTimerList+0x1>
    26a6:	80 81       	ld	r24, Z
    26a8:	81 11       	cpse	r24, r1
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
    26aa:	ca cf       	rjmp	.-108    	; 0x2640 <prvSampleTimeNow+0x2c>
    26ac:	80 91 94 22 	lds	r24, 0x2294	; 0x802294 <pxOverflowTimerList>
    26b0:	90 91 95 22 	lds	r25, 0x2295	; 0x802295 <pxOverflowTimerList+0x1>
    26b4:	80 93 96 22 	sts	0x2296, r24	; 0x802296 <pxCurrentTimerList>
    26b8:	90 93 97 22 	sts	0x2297, r25	; 0x802297 <pxCurrentTimerList+0x1>
	pxOverflowTimerList = pxTemp;
    26bc:	e0 93 94 22 	sts	0x2294, r30	; 0x802294 <pxOverflowTimerList>
    26c0:	f0 93 95 22 	sts	0x2295, r31	; 0x802295 <pxOverflowTimerList+0x1>
	xTimeNow = xTaskGetTickCount();

	if( xTimeNow < xLastTime )
	{
		prvSwitchTimerLists();
		*pxTimerListsWereSwitched = pdTRUE;
    26c4:	81 e0       	ldi	r24, 0x01	; 1
    26c6:	f6 01       	movw	r30, r12
    26c8:	80 83       	st	Z, r24
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
    26ca:	02 c0       	rjmp	.+4      	; 0x26d0 <prvSampleTimeNow+0xbc>
    26cc:	f6 01       	movw	r30, r12
	}

	xLastTime = xTimeNow;
    26ce:	10 82       	st	Z, r1
    26d0:	e0 92 90 22 	sts	0x2290, r14	; 0x802290 <xLastTime.4400>
    26d4:	f0 92 91 22 	sts	0x2291, r15	; 0x802291 <xLastTime.4400+0x1>

	return xTimeNow;
}
    26d8:	c7 01       	movw	r24, r14
    26da:	df 91       	pop	r29
    26dc:	cf 91       	pop	r28
    26de:	1f 91       	pop	r17
    26e0:	0f 91       	pop	r16
    26e2:	ff 90       	pop	r15
    26e4:	ef 90       	pop	r14
    26e6:	df 90       	pop	r13
    26e8:	cf 90       	pop	r12
    26ea:	bf 90       	pop	r11
    26ec:	af 90       	pop	r10
    26ee:	08 95       	ret

000026f0 <prvTimerTask>:
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
    26f0:	cf 93       	push	r28
    26f2:	df 93       	push	r29
    26f4:	00 d0       	rcall	.+0      	; 0x26f6 <prvTimerTask+0x6>
    26f6:	00 d0       	rcall	.+0      	; 0x26f8 <prvTimerTask+0x8>
    26f8:	cd b7       	in	r28, 0x3d	; 61
    26fa:	de b7       	in	r29, 0x3e	; 62
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    26fc:	ce 01       	movw	r24, r28
    26fe:	01 96       	adiw	r24, 0x01	; 1
    2700:	5c 01       	movw	r10, r24
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    2702:	e8 2e       	mov	r14, r24
    2704:	fb 2c       	mov	r15, r11
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    2706:	e0 91 96 22 	lds	r30, 0x2296	; 0x802296 <pxCurrentTimerList>
    270a:	f0 91 97 22 	lds	r31, 0x2297	; 0x802297 <pxCurrentTimerList+0x1>
	if( *pxListWasEmpty == pdFALSE )
    270e:	80 81       	ld	r24, Z
    2710:	88 23       	and	r24, r24
    2712:	09 f4       	brne	.+2      	; 0x2716 <prvTimerTask+0x26>
    2714:	b6 c0       	rjmp	.+364    	; 0x2882 <prvTimerTask+0x192>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    2716:	05 80       	ldd	r0, Z+5	; 0x05
    2718:	f6 81       	ldd	r31, Z+6	; 0x06
    271a:	e0 2d       	mov	r30, r0
    271c:	c0 80       	ld	r12, Z
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    271e:	d1 80       	ldd	r13, Z+1	; 0x01
    2720:	d2 db       	rcall	.-2140   	; 0x1ec6 <vTaskSuspendAll>
    2722:	c5 01       	movw	r24, r10
		if( xTimerListsWereSwitched == pdFALSE )
    2724:	77 df       	rcall	.-274    	; 0x2614 <prvSampleTimeNow>
    2726:	8c 01       	movw	r16, r24
    2728:	89 81       	ldd	r24, Y+1	; 0x01
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    272a:	81 11       	cpse	r24, r1
    272c:	42 c0       	rjmp	.+132    	; 0x27b2 <prvTimerTask+0xc2>
			{
				( void ) xTaskResumeAll();
    272e:	0c 15       	cp	r16, r12
    2730:	1d 05       	cpc	r17, r13
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    2732:	80 f1       	brcs	.+96     	; 0x2794 <prvTimerTask+0xa4>
    2734:	ab dc       	rcall	.-1706   	; 0x208c <xTaskResumeAll>
    2736:	e0 91 96 22 	lds	r30, 0x2296	; 0x802296 <pxCurrentTimerList>
    273a:	f0 91 97 22 	lds	r31, 0x2297	; 0x802297 <pxCurrentTimerList+0x1>
    273e:	05 80       	ldd	r0, Z+5	; 0x05
    2740:	f6 81       	ldd	r31, Z+6	; 0x06
    2742:	e0 2d       	mov	r30, r0

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2744:	86 80       	ldd	r8, Z+6	; 0x06
    2746:	97 80       	ldd	r9, Z+7	; 0x07
    2748:	c4 01       	movw	r24, r8
    274a:	02 96       	adiw	r24, 0x02	; 2
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    274c:	0e 94 c1 09 	call	0x1382	; 0x1382 <uxListRemove>
    2750:	d4 01       	movw	r26, r8
    2752:	1e 96       	adiw	r26, 0x0e	; 14
    2754:	8c 91       	ld	r24, X
    2756:	1e 97       	sbiw	r26, 0x0e	; 14
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
    2758:	81 30       	cpi	r24, 0x01	; 1
    275a:	a1 f4       	brne	.+40     	; 0x2784 <prvTimerTask+0x94>
    275c:	1c 96       	adiw	r26, 0x0c	; 12
    275e:	6d 91       	ld	r22, X+
    2760:	7c 91       	ld	r23, X
    2762:	1d 97       	sbiw	r26, 0x0d	; 13
    2764:	6c 0d       	add	r22, r12
    2766:	7d 1d       	adc	r23, r13
    2768:	96 01       	movw	r18, r12
    276a:	a8 01       	movw	r20, r16
    276c:	c4 01       	movw	r24, r8
    276e:	5b de       	rcall	.-842    	; 0x2426 <prvInsertTimerInActiveList>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    2770:	81 30       	cpi	r24, 0x01	; 1
    2772:	41 f4       	brne	.+16     	; 0x2784 <prvTimerTask+0x94>
    2774:	00 e0       	ldi	r16, 0x00	; 0
    2776:	10 e0       	ldi	r17, 0x00	; 0
    2778:	20 e0       	ldi	r18, 0x00	; 0
    277a:	30 e0       	ldi	r19, 0x00	; 0
    277c:	a6 01       	movw	r20, r12
    277e:	60 e0       	ldi	r22, 0x00	; 0
	{
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2780:	c4 01       	movw	r24, r8
    2782:	06 df       	rcall	.-500    	; 0x2590 <xTimerGenericCommand>
    2784:	d4 01       	movw	r26, r8
    2786:	51 96       	adiw	r26, 0x11	; 17
    2788:	ed 91       	ld	r30, X+
    278a:	fc 91       	ld	r31, X
    278c:	52 97       	sbiw	r26, 0x12	; 18
    278e:	c4 01       	movw	r24, r8
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
		if( xTimerListsWereSwitched == pdFALSE )
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    2790:	19 95       	eicall
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
				}

				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    2792:	6a c0       	rjmp	.+212    	; 0x2868 <prvTimerTask+0x178>
    2794:	40 e0       	ldi	r20, 0x00	; 0
    2796:	b6 01       	movw	r22, r12
    2798:	60 1b       	sub	r22, r16
    279a:	71 0b       	sbc	r23, r17
    279c:	80 91 92 22 	lds	r24, 0x2292	; 0x802292 <xTimerQueue>

				if( xTaskResumeAll() == pdFALSE )
    27a0:	90 91 93 22 	lds	r25, 0x2293	; 0x802293 <xTimerQueue+0x1>
				{
					/* Yield to wait for either a command to arrive, or the
					block time to expire.  If a command arrived between the
					critical section being exited and this yield then the yield
					will not cause the task to block. */
					portYIELD_WITHIN_API();
    27a4:	05 da       	rcall	.-3062   	; 0x1bb0 <vQueueWaitForMessageRestricted>
    27a6:	72 dc       	rcall	.-1820   	; 0x208c <xTaskResumeAll>
    27a8:	81 11       	cpse	r24, r1
				}
			}
		}
		else
		{
			( void ) xTaskResumeAll();
    27aa:	5e c0       	rjmp	.+188    	; 0x2868 <prvTimerTask+0x178>
    27ac:	0e 94 a3 0a 	call	0x1546	; 0x1546 <vPortYield>
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    27b0:	5b c0       	rjmp	.+182    	; 0x2868 <prvTimerTask+0x178>
    27b2:	6c dc       	rcall	.-1832   	; 0x208c <xTaskResumeAll>
    27b4:	59 c0       	rjmp	.+178    	; 0x2868 <prvTimerTask+0x178>
    27b6:	89 81       	ldd	r24, Y+1	; 0x01
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    27b8:	88 23       	and	r24, r24
    27ba:	0c f4       	brge	.+2      	; 0x27be <prvTimerTask+0xce>

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
    27bc:	55 c0       	rjmp	.+170    	; 0x2868 <prvTimerTask+0x178>
    27be:	cc 80       	ldd	r12, Y+4	; 0x04
    27c0:	dd 80       	ldd	r13, Y+5	; 0x05
    27c2:	f6 01       	movw	r30, r12
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    27c4:	82 85       	ldd	r24, Z+10	; 0x0a
    27c6:	93 85       	ldd	r25, Z+11	; 0x0b
    27c8:	89 2b       	or	r24, r25
    27ca:	21 f0       	breq	.+8      	; 0x27d4 <prvTimerTask+0xe4>
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    27cc:	c6 01       	movw	r24, r12
    27ce:	02 96       	adiw	r24, 0x02	; 2
    27d0:	0e 94 c1 09 	call	0x1382	; 0x1382 <uxListRemove>
    27d4:	ce 01       	movw	r24, r28

			switch( xMessage.xMessageID )
    27d6:	06 96       	adiw	r24, 0x06	; 6
    27d8:	1d df       	rcall	.-454    	; 0x2614 <prvSampleTimeNow>
    27da:	ac 01       	movw	r20, r24
    27dc:	89 81       	ldd	r24, Y+1	; 0x01
    27de:	08 2e       	mov	r0, r24
    27e0:	00 0c       	add	r0, r0
    27e2:	99 0b       	sbc	r25, r25
    27e4:	aa 0b       	sbc	r26, r26
    27e6:	bb 0b       	sbc	r27, r27
    27e8:	8a 30       	cpi	r24, 0x0A	; 10
    27ea:	91 05       	cpc	r25, r1
    27ec:	08 f0       	brcs	.+2      	; 0x27f0 <prvTimerTask+0x100>
    27ee:	3c c0       	rjmp	.+120    	; 0x2868 <prvTimerTask+0x178>
    27f0:	fc 01       	movw	r30, r24
    27f2:	88 27       	eor	r24, r24
			    case tmrCOMMAND_START_FROM_ISR :
			    case tmrCOMMAND_RESET :
			    case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) == pdTRUE )
    27f4:	e2 50       	subi	r30, 0x02	; 2
    27f6:	ff 4f       	sbci	r31, 0xFF	; 255
    27f8:	8f 4f       	sbci	r24, 0xFF	; 255
    27fa:	1b c1       	rjmp	.+566    	; 0x2a32 <__tablejump2__>
    27fc:	2a 81       	ldd	r18, Y+2	; 0x02
    27fe:	3b 81       	ldd	r19, Y+3	; 0x03
    2800:	d6 01       	movw	r26, r12
    2802:	1c 96       	adiw	r26, 0x0c	; 12
    2804:	6d 91       	ld	r22, X+
    2806:	7c 91       	ld	r23, X
    2808:	1d 97       	sbiw	r26, 0x0d	; 13
    280a:	62 0f       	add	r22, r18
    280c:	73 1f       	adc	r23, r19
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    280e:	c6 01       	movw	r24, r12
    2810:	0a de       	rcall	.-1004   	; 0x2426 <prvInsertTimerInActiveList>
    2812:	81 30       	cpi	r24, 0x01	; 1
    2814:	49 f5       	brne	.+82     	; 0x2868 <prvTimerTask+0x178>
    2816:	d6 01       	movw	r26, r12
    2818:	51 96       	adiw	r26, 0x11	; 17
    281a:	ed 91       	ld	r30, X+
						traceTIMER_EXPIRED( pxTimer );

						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    281c:	fc 91       	ld	r31, X
    281e:	52 97       	sbiw	r26, 0x12	; 18
    2820:	c6 01       	movw	r24, r12
    2822:	19 95       	eicall
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    2824:	f6 01       	movw	r30, r12
    2826:	86 85       	ldd	r24, Z+14	; 0x0e
    2828:	81 30       	cpi	r24, 0x01	; 1
    282a:	f1 f4       	brne	.+60     	; 0x2868 <prvTimerTask+0x178>
    282c:	4a 81       	ldd	r20, Y+2	; 0x02
    282e:	5b 81       	ldd	r21, Y+3	; 0x03
    2830:	84 85       	ldd	r24, Z+12	; 0x0c
    2832:	95 85       	ldd	r25, Z+13	; 0x0d
    2834:	48 0f       	add	r20, r24
    2836:	59 1f       	adc	r21, r25
    2838:	00 e0       	ldi	r16, 0x00	; 0
    283a:	10 e0       	ldi	r17, 0x00	; 0
    283c:	20 e0       	ldi	r18, 0x00	; 0
					There is nothing to do here. */
					break;

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    283e:	30 e0       	ldi	r19, 0x00	; 0
    2840:	60 e0       	ldi	r22, 0x00	; 0
    2842:	c6 01       	movw	r24, r12
    2844:	a5 de       	rcall	.-694    	; 0x2590 <xTimerGenericCommand>
    2846:	10 c0       	rjmp	.+32     	; 0x2868 <prvTimerTask+0x178>
    2848:	6a 81       	ldd	r22, Y+2	; 0x02
    284a:	7b 81       	ldd	r23, Y+3	; 0x03
					longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot be
					zero the next expiry time can only be in the future, meaning
					(unlike for the xTimerStart() case above) there is no fail case
					that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    284c:	d6 01       	movw	r26, r12
    284e:	1c 96       	adiw	r26, 0x0c	; 12
    2850:	6d 93       	st	X+, r22
    2852:	7c 93       	st	X, r23
    2854:	1d 97       	sbiw	r26, 0x0d	; 13
    2856:	64 0f       	add	r22, r20
					break;

				case tmrCOMMAND_DELETE :
					/* The timer has already been removed from the active list,
					just free up the memory. */
					vPortFree( pxTimer );
    2858:	75 1f       	adc	r23, r21
    285a:	9a 01       	movw	r18, r20
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    285c:	c6 01       	movw	r24, r12
    285e:	e3 dd       	rcall	.-1082   	; 0x2426 <prvInsertTimerInActiveList>
    2860:	03 c0       	rjmp	.+6      	; 0x2868 <prvTimerTask+0x178>
    2862:	c6 01       	movw	r24, r12
    2864:	0e 94 62 0b 	call	0x16c4	; 0x16c4 <vPortFree>
    2868:	20 e0       	ldi	r18, 0x00	; 0
    286a:	40 e0       	ldi	r20, 0x00	; 0
    286c:	50 e0       	ldi	r21, 0x00	; 0
    286e:	6e 2d       	mov	r22, r14
    2870:	7f 2d       	mov	r23, r15
    2872:	80 91 92 22 	lds	r24, 0x2292	; 0x802292 <xTimerQueue>
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    2876:	90 91 93 22 	lds	r25, 0x2293	; 0x802293 <xTimerQueue+0x1>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    287a:	03 d9       	rcall	.-3578   	; 0x1a82 <xQueueGenericReceive>
    287c:	81 11       	cpse	r24, r1
    287e:	9b cf       	rjmp	.-202    	; 0x27b6 <prvTimerTask+0xc6>
		if( xTimerListsWereSwitched == pdFALSE )
    2880:	42 cf       	rjmp	.-380    	; 0x2706 <prvTimerTask+0x16>
    2882:	21 db       	rcall	.-2494   	; 0x1ec6 <vTaskSuspendAll>
    2884:	c5 01       	movw	r24, r10
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    2886:	c6 de       	rcall	.-628    	; 0x2614 <prvSampleTimeNow>
    2888:	8c 01       	movw	r16, r24
    288a:	89 81       	ldd	r24, Y+1	; 0x01
    288c:	81 11       	cpse	r24, r1
    288e:	91 cf       	rjmp	.-222    	; 0x27b2 <prvTimerTask+0xc2>
    2890:	e0 91 94 22 	lds	r30, 0x2294	; 0x802294 <pxOverflowTimerList>
    2894:	f0 91 95 22 	lds	r31, 0x2295	; 0x802295 <pxOverflowTimerList+0x1>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
    2898:	41 e0       	ldi	r20, 0x01	; 1
    289a:	80 81       	ld	r24, Z
    289c:	81 11       	cpse	r24, r1
    289e:	40 e0       	ldi	r20, 0x00	; 0
    28a0:	c1 2c       	mov	r12, r1
    28a2:	d1 2c       	mov	r13, r1
    28a4:	78 cf       	rjmp	.-272    	; 0x2796 <prvTimerTask+0xa6>

000028a6 <vTimerCallback>:
	}else if(strcmp(str2,reads) == 0){
		gpio_set_pin_high(J2_PIN0);
	}else{
		gpio_set_pin_low(J2_PIN0);
	}
}
    28a6:	80 91 aa 22 	lds	r24, 0x22AA	; 0x8022aa <increment>
    28aa:	90 91 ab 22 	lds	r25, 0x22AB	; 0x8022ab <increment+0x1>
    28ae:	a0 91 ac 22 	lds	r26, 0x22AC	; 0x8022ac <increment+0x2>
    28b2:	b0 91 ad 22 	lds	r27, 0x22AD	; 0x8022ad <increment+0x3>
    28b6:	01 96       	adiw	r24, 0x01	; 1
    28b8:	a1 1d       	adc	r26, r1
    28ba:	b1 1d       	adc	r27, r1
    28bc:	80 93 aa 22 	sts	0x22AA, r24	; 0x8022aa <increment>
    28c0:	90 93 ab 22 	sts	0x22AB, r25	; 0x8022ab <increment+0x1>
    28c4:	a0 93 ac 22 	sts	0x22AC, r26	; 0x8022ac <increment+0x2>
    28c8:	b0 93 ad 22 	sts	0x22AD, r27	; 0x8022ad <increment+0x3>
    28cc:	08 95       	ret

000028ce <freeHeap>:
    28ce:	81 e0       	ldi	r24, 0x01	; 1
    28d0:	80 93 e5 07 	sts	0x07E5, r24	; 0x8007e5 <__TEXT_REGION_LENGTH__+0x7007e5>
    28d4:	82 e3       	ldi	r24, 0x32	; 50
    28d6:	90 e0       	ldi	r25, 0x00	; 0
    28d8:	56 cc       	rjmp	.-1876   	; 0x2186 <vTaskDelay>
    28da:	08 95       	ret

000028dc <setUpSerial>:
    28dc:	10 92 a7 08 	sts	0x08A7, r1	; 0x8008a7 <__TEXT_REGION_LENGTH__+0x7008a7>
    28e0:	8c e0       	ldi	r24, 0x0C	; 12
    28e2:	80 93 a6 08 	sts	0x08A6, r24	; 0x8008a6 <__TEXT_REGION_LENGTH__+0x7008a6>
    28e6:	10 92 a3 08 	sts	0x08A3, r1	; 0x8008a3 <__TEXT_REGION_LENGTH__+0x7008a3>
    28ea:	83 e0       	ldi	r24, 0x03	; 3
    28ec:	80 93 a5 08 	sts	0x08A5, r24	; 0x8008a5 <__TEXT_REGION_LENGTH__+0x7008a5>
    28f0:	88 e1       	ldi	r24, 0x18	; 24
    28f2:	80 93 a4 08 	sts	0x08A4, r24	; 0x8008a4 <__TEXT_REGION_LENGTH__+0x7008a4>
    28f6:	08 95       	ret

000028f8 <sendString>:
    28f8:	cf 93       	push	r28
    28fa:	df 93       	push	r29
    28fc:	fc 01       	movw	r30, r24
    28fe:	60 81       	ld	r22, Z
    2900:	66 23       	and	r22, r22
    2902:	49 f0       	breq	.+18     	; 0x2916 <sendString+0x1e>
    2904:	ec 01       	movw	r28, r24
    2906:	21 96       	adiw	r28, 0x01	; 1
    2908:	80 ea       	ldi	r24, 0xA0	; 160
    290a:	98 e0       	ldi	r25, 0x08	; 8
    290c:	0e 94 dd 03 	call	0x7ba	; 0x7ba <usart_putchar>
    2910:	69 91       	ld	r22, Y+
    2912:	61 11       	cpse	r22, r1
    2914:	f9 cf       	rjmp	.-14     	; 0x2908 <sendString+0x10>
    2916:	df 91       	pop	r29
    2918:	cf 91       	pop	r28
    291a:	08 95       	ret

0000291c <ACK>:
    291c:	8a e1       	ldi	r24, 0x1A	; 26
    291e:	90 e2       	ldi	r25, 0x20	; 32
    2920:	eb df       	rcall	.-42     	; 0x28f8 <sendString>
    2922:	82 e3       	ldi	r24, 0x32	; 50
    2924:	90 e0       	ldi	r25, 0x00	; 0
    2926:	2f cc       	rjmp	.-1954   	; 0x2186 <vTaskDelay>
    2928:	08 95       	ret

0000292a <main>:
	sendString("atas \n");
	vTaskDelay(100/portTICK_PERIOD_MS);
}

int main (void)
{
    292a:	af 92       	push	r10
    292c:	bf 92       	push	r11
    292e:	cf 92       	push	r12
    2930:	df 92       	push	r13
    2932:	ef 92       	push	r14
    2934:	ff 92       	push	r15
    2936:	0f 93       	push	r16
    2938:	1f 93       	push	r17
    293a:	cf 93       	push	r28
    293c:	df 93       	push	r29
    // Insert system clock initialization code here (sysclk_init()).

    board_init();
    293e:	0e 94 c0 08 	call	0x1180	; 0x1180 <board_init>
	sysclk_init();
    2942:	0e 94 60 08 	call	0x10c0	; 0x10c0 <sysclk_init>
    gfx_mono_init();
    2946:	0e 94 9b 03 	call	0x736	; 0x736 <gfx_mono_st7565r_init>
    294a:	80 e1       	ldi	r24, 0x10	; 16
    294c:	80 93 85 06 	sts	0x0685, r24	; 0x800685 <__TEXT_REGION_LENGTH__+0x700685>
   
    gpio_set_pin_high(LCD_BACKLIGHT_ENABLE_PIN);
   
    PORTC_OUTSET = PIN3_bm; // PC3 as TX
    2950:	88 e0       	ldi	r24, 0x08	; 8
    2952:	80 93 45 06 	sts	0x0645, r24	; 0x800645 <__TEXT_REGION_LENGTH__+0x700645>
    PORTC_DIRSET = PIN3_bm; //TX pin as output
    2956:	80 93 41 06 	sts	0x0641, r24	; 0x800641 <__TEXT_REGION_LENGTH__+0x700641>
   
    PORTC_OUTCLR = PIN2_bm; //PC2 as RX
    295a:	84 e0       	ldi	r24, 0x04	; 4
    295c:	80 93 46 06 	sts	0x0646, r24	; 0x800646 <__TEXT_REGION_LENGTH__+0x700646>
    PORTC_DIRCLR = PIN2_bm; //RX pin as input
    2960:	80 93 42 06 	sts	0x0642, r24	; 0x800642 <__TEXT_REGION_LENGTH__+0x700642>
		.charlength = USART_SERIAL_CHAR_LENGTH,
		.paritytype = USART_SERIAL_PARITY,
		.stopbits = USART_SERIAL_STOP_BIT
	};
	
	usart_init_rs232(USART_SERIAL_EXAMPLE, &USART_SERIAL_OPTIONS);
    2964:	bb df       	rcall	.-138    	; 0x28dc <setUpSerial>
    2966:	66 e0       	ldi	r22, 0x06	; 6
    2968:	70 e2       	ldi	r23, 0x20	; 32
    296a:	80 ea       	ldi	r24, 0xA0	; 160
    296c:	98 e0       	ldi	r25, 0x08	; 8
    296e:	0e 94 f8 04 	call	0x9f0	; 0x9f0 <usart_init_rs232>
		enum ioport_direction dir)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (dir == IOPORT_DIR_OUTPUT) {
		base->DIRSET = arch_ioport_pin_to_mask(pin);
    2972:	81 e0       	ldi	r24, 0x01	; 1
    2974:	80 93 21 06 	sts	0x0621, r24	; 0x800621 <__TEXT_REGION_LENGTH__+0x700621>
	
	ioport_set_pin_dir(J2_PIN0, IOPORT_DIR_OUTPUT);
	
	TimerHandle_t timerPing = xTimerCreate("tPing", 2/portTICK_PERIOD_MS, pdTRUE, (void *) 0, vTimerCallback);
    2978:	03 e5       	ldi	r16, 0x53	; 83
    297a:	14 e1       	ldi	r17, 0x14	; 20
    297c:	20 e0       	ldi	r18, 0x00	; 0
    297e:	30 e0       	ldi	r19, 0x00	; 0
    2980:	41 e0       	ldi	r20, 0x01	; 1
    2982:	61 e0       	ldi	r22, 0x01	; 1
    2984:	70 e0       	ldi	r23, 0x00	; 0
    2986:	81 e2       	ldi	r24, 0x21	; 33
    2988:	90 e2       	ldi	r25, 0x20	; 32
    298a:	cc dd       	rcall	.-1128   	; 0x2524 <xTimerCreate>
	
	xTaskCreate(freeHeap,"",500,NULL,1,NULL);
    298c:	ec 01       	movw	r28, r24
    298e:	a1 2c       	mov	r10, r1
    2990:	b1 2c       	mov	r11, r1
    2992:	c1 2c       	mov	r12, r1
    2994:	d1 2c       	mov	r13, r1
    2996:	e1 2c       	mov	r14, r1
    2998:	f1 2c       	mov	r15, r1
    299a:	01 e0       	ldi	r16, 0x01	; 1
    299c:	20 e0       	ldi	r18, 0x00	; 0
    299e:	30 e0       	ldi	r19, 0x00	; 0
    29a0:	44 ef       	ldi	r20, 0xF4	; 244
    29a2:	51 e0       	ldi	r21, 0x01	; 1
    29a4:	60 e2       	ldi	r22, 0x20	; 32
    29a6:	70 e2       	ldi	r23, 0x20	; 32
    29a8:	87 e6       	ldi	r24, 0x67	; 103
    29aa:	94 e1       	ldi	r25, 0x14	; 20
	
	xTaskCreate(ACK,"",500,NULL,1,NULL);
    29ac:	58 d9       	rcall	.-3408   	; 0x1c5e <xTaskGenericCreate>
    29ae:	20 e0       	ldi	r18, 0x00	; 0
    29b0:	30 e0       	ldi	r19, 0x00	; 0
    29b2:	44 ef       	ldi	r20, 0xF4	; 244
    29b4:	51 e0       	ldi	r21, 0x01	; 1
    29b6:	60 e2       	ldi	r22, 0x20	; 32
    29b8:	70 e2       	ldi	r23, 0x20	; 32
    29ba:	8e e8       	ldi	r24, 0x8E	; 142
	
	xTimerStart(timerPing, 0);
    29bc:	94 e1       	ldi	r25, 0x14	; 20
    29be:	4f d9       	rcall	.-3426   	; 0x1c5e <xTaskGenericCreate>
    29c0:	88 da       	rcall	.-2800   	; 0x1ed2 <xTaskGetTickCount>
    29c2:	00 e0       	ldi	r16, 0x00	; 0
    29c4:	10 e0       	ldi	r17, 0x00	; 0
    29c6:	20 e0       	ldi	r18, 0x00	; 0
    29c8:	30 e0       	ldi	r19, 0x00	; 0
    29ca:	ac 01       	movw	r20, r24
    29cc:	61 e0       	ldi	r22, 0x01	; 1
	
	vTaskStartScheduler();
    29ce:	ce 01       	movw	r24, r28
    29d0:	df dd       	rcall	.-1090   	; 0x2590 <xTimerGenericCommand>
        //snprintf(strbuf, sizeof(strbuf), "Read USART : %3d",in);
        gfx_mono_draw_string(reads,0, 0, &sysfont);
        delay_ms(50);
    }*/

}
    29d2:	46 da       	rcall	.-2932   	; 0x1e60 <vTaskStartScheduler>
    29d4:	80 e0       	ldi	r24, 0x00	; 0
    29d6:	90 e0       	ldi	r25, 0x00	; 0
    29d8:	df 91       	pop	r29
    29da:	cf 91       	pop	r28
    29dc:	1f 91       	pop	r17
    29de:	0f 91       	pop	r16
    29e0:	ff 90       	pop	r15
    29e2:	ef 90       	pop	r14
    29e4:	df 90       	pop	r13
    29e6:	cf 90       	pop	r12
    29e8:	bf 90       	pop	r11
    29ea:	af 90       	pop	r10
    29ec:	08 95       	ret

000029ee <__udivmodsi4>:
    29ee:	a1 e2       	ldi	r26, 0x21	; 33
    29f0:	1a 2e       	mov	r1, r26
    29f2:	aa 1b       	sub	r26, r26
    29f4:	bb 1b       	sub	r27, r27
    29f6:	fd 01       	movw	r30, r26
    29f8:	0d c0       	rjmp	.+26     	; 0x2a14 <__udivmodsi4_ep>

000029fa <__udivmodsi4_loop>:
    29fa:	aa 1f       	adc	r26, r26
    29fc:	bb 1f       	adc	r27, r27
    29fe:	ee 1f       	adc	r30, r30
    2a00:	ff 1f       	adc	r31, r31
    2a02:	a2 17       	cp	r26, r18
    2a04:	b3 07       	cpc	r27, r19
    2a06:	e4 07       	cpc	r30, r20
    2a08:	f5 07       	cpc	r31, r21
    2a0a:	20 f0       	brcs	.+8      	; 0x2a14 <__udivmodsi4_ep>
    2a0c:	a2 1b       	sub	r26, r18
    2a0e:	b3 0b       	sbc	r27, r19
    2a10:	e4 0b       	sbc	r30, r20
    2a12:	f5 0b       	sbc	r31, r21

00002a14 <__udivmodsi4_ep>:
    2a14:	66 1f       	adc	r22, r22
    2a16:	77 1f       	adc	r23, r23
    2a18:	88 1f       	adc	r24, r24
    2a1a:	99 1f       	adc	r25, r25
    2a1c:	1a 94       	dec	r1
    2a1e:	69 f7       	brne	.-38     	; 0x29fa <__udivmodsi4_loop>
    2a20:	60 95       	com	r22
    2a22:	70 95       	com	r23
    2a24:	80 95       	com	r24
    2a26:	90 95       	com	r25
    2a28:	9b 01       	movw	r18, r22
    2a2a:	ac 01       	movw	r20, r24
    2a2c:	bd 01       	movw	r22, r26
    2a2e:	cf 01       	movw	r24, r30
    2a30:	08 95       	ret

00002a32 <__tablejump2__>:
    2a32:	ee 0f       	add	r30, r30
    2a34:	ff 1f       	adc	r31, r31
    2a36:	88 1f       	adc	r24, r24
    2a38:	8b bf       	out	0x3b, r24	; 59
    2a3a:	07 90       	elpm	r0, Z+
    2a3c:	f6 91       	elpm	r31, Z
    2a3e:	e0 2d       	mov	r30, r0
    2a40:	19 94       	eijmp

00002a42 <malloc>:
    2a42:	0f 93       	push	r16
    2a44:	1f 93       	push	r17
    2a46:	cf 93       	push	r28
    2a48:	df 93       	push	r29
    2a4a:	82 30       	cpi	r24, 0x02	; 2
    2a4c:	91 05       	cpc	r25, r1
    2a4e:	10 f4       	brcc	.+4      	; 0x2a54 <malloc+0x12>
    2a50:	82 e0       	ldi	r24, 0x02	; 2
    2a52:	90 e0       	ldi	r25, 0x00	; 0
    2a54:	e0 91 b0 22 	lds	r30, 0x22B0	; 0x8022b0 <__flp>
    2a58:	f0 91 b1 22 	lds	r31, 0x22B1	; 0x8022b1 <__flp+0x1>
    2a5c:	20 e0       	ldi	r18, 0x00	; 0
    2a5e:	30 e0       	ldi	r19, 0x00	; 0
    2a60:	a0 e0       	ldi	r26, 0x00	; 0
    2a62:	b0 e0       	ldi	r27, 0x00	; 0
    2a64:	30 97       	sbiw	r30, 0x00	; 0
    2a66:	19 f1       	breq	.+70     	; 0x2aae <malloc+0x6c>
    2a68:	40 81       	ld	r20, Z
    2a6a:	51 81       	ldd	r21, Z+1	; 0x01
    2a6c:	02 81       	ldd	r16, Z+2	; 0x02
    2a6e:	13 81       	ldd	r17, Z+3	; 0x03
    2a70:	48 17       	cp	r20, r24
    2a72:	59 07       	cpc	r21, r25
    2a74:	c8 f0       	brcs	.+50     	; 0x2aa8 <malloc+0x66>
    2a76:	84 17       	cp	r24, r20
    2a78:	95 07       	cpc	r25, r21
    2a7a:	69 f4       	brne	.+26     	; 0x2a96 <malloc+0x54>
    2a7c:	10 97       	sbiw	r26, 0x00	; 0
    2a7e:	31 f0       	breq	.+12     	; 0x2a8c <malloc+0x4a>
    2a80:	12 96       	adiw	r26, 0x02	; 2
    2a82:	0c 93       	st	X, r16
    2a84:	12 97       	sbiw	r26, 0x02	; 2
    2a86:	13 96       	adiw	r26, 0x03	; 3
    2a88:	1c 93       	st	X, r17
    2a8a:	27 c0       	rjmp	.+78     	; 0x2ada <malloc+0x98>
    2a8c:	00 93 b0 22 	sts	0x22B0, r16	; 0x8022b0 <__flp>
    2a90:	10 93 b1 22 	sts	0x22B1, r17	; 0x8022b1 <__flp+0x1>
    2a94:	22 c0       	rjmp	.+68     	; 0x2ada <malloc+0x98>
    2a96:	21 15       	cp	r18, r1
    2a98:	31 05       	cpc	r19, r1
    2a9a:	19 f0       	breq	.+6      	; 0x2aa2 <malloc+0x60>
    2a9c:	42 17       	cp	r20, r18
    2a9e:	53 07       	cpc	r21, r19
    2aa0:	18 f4       	brcc	.+6      	; 0x2aa8 <malloc+0x66>
    2aa2:	9a 01       	movw	r18, r20
    2aa4:	bd 01       	movw	r22, r26
    2aa6:	ef 01       	movw	r28, r30
    2aa8:	df 01       	movw	r26, r30
    2aaa:	f8 01       	movw	r30, r16
    2aac:	db cf       	rjmp	.-74     	; 0x2a64 <malloc+0x22>
    2aae:	21 15       	cp	r18, r1
    2ab0:	31 05       	cpc	r19, r1
    2ab2:	f9 f0       	breq	.+62     	; 0x2af2 <malloc+0xb0>
    2ab4:	28 1b       	sub	r18, r24
    2ab6:	39 0b       	sbc	r19, r25
    2ab8:	24 30       	cpi	r18, 0x04	; 4
    2aba:	31 05       	cpc	r19, r1
    2abc:	80 f4       	brcc	.+32     	; 0x2ade <malloc+0x9c>
    2abe:	8a 81       	ldd	r24, Y+2	; 0x02
    2ac0:	9b 81       	ldd	r25, Y+3	; 0x03
    2ac2:	61 15       	cp	r22, r1
    2ac4:	71 05       	cpc	r23, r1
    2ac6:	21 f0       	breq	.+8      	; 0x2ad0 <malloc+0x8e>
    2ac8:	fb 01       	movw	r30, r22
    2aca:	82 83       	std	Z+2, r24	; 0x02
    2acc:	93 83       	std	Z+3, r25	; 0x03
    2ace:	04 c0       	rjmp	.+8      	; 0x2ad8 <malloc+0x96>
    2ad0:	80 93 b0 22 	sts	0x22B0, r24	; 0x8022b0 <__flp>
    2ad4:	90 93 b1 22 	sts	0x22B1, r25	; 0x8022b1 <__flp+0x1>
    2ad8:	fe 01       	movw	r30, r28
    2ada:	32 96       	adiw	r30, 0x02	; 2
    2adc:	44 c0       	rjmp	.+136    	; 0x2b66 <malloc+0x124>
    2ade:	fe 01       	movw	r30, r28
    2ae0:	e2 0f       	add	r30, r18
    2ae2:	f3 1f       	adc	r31, r19
    2ae4:	81 93       	st	Z+, r24
    2ae6:	91 93       	st	Z+, r25
    2ae8:	22 50       	subi	r18, 0x02	; 2
    2aea:	31 09       	sbc	r19, r1
    2aec:	28 83       	st	Y, r18
    2aee:	39 83       	std	Y+1, r19	; 0x01
    2af0:	3a c0       	rjmp	.+116    	; 0x2b66 <malloc+0x124>
    2af2:	20 91 ae 22 	lds	r18, 0x22AE	; 0x8022ae <__brkval>
    2af6:	30 91 af 22 	lds	r19, 0x22AF	; 0x8022af <__brkval+0x1>
    2afa:	23 2b       	or	r18, r19
    2afc:	41 f4       	brne	.+16     	; 0x2b0e <malloc+0xcc>
    2afe:	20 91 02 20 	lds	r18, 0x2002	; 0x802002 <__malloc_heap_start>
    2b02:	30 91 03 20 	lds	r19, 0x2003	; 0x802003 <__malloc_heap_start+0x1>
    2b06:	20 93 ae 22 	sts	0x22AE, r18	; 0x8022ae <__brkval>
    2b0a:	30 93 af 22 	sts	0x22AF, r19	; 0x8022af <__brkval+0x1>
    2b0e:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
    2b12:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
    2b16:	21 15       	cp	r18, r1
    2b18:	31 05       	cpc	r19, r1
    2b1a:	41 f4       	brne	.+16     	; 0x2b2c <malloc+0xea>
    2b1c:	2d b7       	in	r18, 0x3d	; 61
    2b1e:	3e b7       	in	r19, 0x3e	; 62
    2b20:	40 91 04 20 	lds	r20, 0x2004	; 0x802004 <__malloc_margin>
    2b24:	50 91 05 20 	lds	r21, 0x2005	; 0x802005 <__malloc_margin+0x1>
    2b28:	24 1b       	sub	r18, r20
    2b2a:	35 0b       	sbc	r19, r21
    2b2c:	e0 91 ae 22 	lds	r30, 0x22AE	; 0x8022ae <__brkval>
    2b30:	f0 91 af 22 	lds	r31, 0x22AF	; 0x8022af <__brkval+0x1>
    2b34:	e2 17       	cp	r30, r18
    2b36:	f3 07       	cpc	r31, r19
    2b38:	a0 f4       	brcc	.+40     	; 0x2b62 <malloc+0x120>
    2b3a:	2e 1b       	sub	r18, r30
    2b3c:	3f 0b       	sbc	r19, r31
    2b3e:	28 17       	cp	r18, r24
    2b40:	39 07       	cpc	r19, r25
    2b42:	78 f0       	brcs	.+30     	; 0x2b62 <malloc+0x120>
    2b44:	ac 01       	movw	r20, r24
    2b46:	4e 5f       	subi	r20, 0xFE	; 254
    2b48:	5f 4f       	sbci	r21, 0xFF	; 255
    2b4a:	24 17       	cp	r18, r20
    2b4c:	35 07       	cpc	r19, r21
    2b4e:	48 f0       	brcs	.+18     	; 0x2b62 <malloc+0x120>
    2b50:	4e 0f       	add	r20, r30
    2b52:	5f 1f       	adc	r21, r31
    2b54:	40 93 ae 22 	sts	0x22AE, r20	; 0x8022ae <__brkval>
    2b58:	50 93 af 22 	sts	0x22AF, r21	; 0x8022af <__brkval+0x1>
    2b5c:	81 93       	st	Z+, r24
    2b5e:	91 93       	st	Z+, r25
    2b60:	02 c0       	rjmp	.+4      	; 0x2b66 <malloc+0x124>
    2b62:	e0 e0       	ldi	r30, 0x00	; 0
    2b64:	f0 e0       	ldi	r31, 0x00	; 0
    2b66:	cf 01       	movw	r24, r30
    2b68:	df 91       	pop	r29
    2b6a:	cf 91       	pop	r28
    2b6c:	1f 91       	pop	r17
    2b6e:	0f 91       	pop	r16
    2b70:	08 95       	ret

00002b72 <free>:
    2b72:	cf 93       	push	r28
    2b74:	df 93       	push	r29
    2b76:	00 97       	sbiw	r24, 0x00	; 0
    2b78:	09 f4       	brne	.+2      	; 0x2b7c <free+0xa>
    2b7a:	81 c0       	rjmp	.+258    	; 0x2c7e <free+0x10c>
    2b7c:	fc 01       	movw	r30, r24
    2b7e:	32 97       	sbiw	r30, 0x02	; 2
    2b80:	12 82       	std	Z+2, r1	; 0x02
    2b82:	13 82       	std	Z+3, r1	; 0x03
    2b84:	a0 91 b0 22 	lds	r26, 0x22B0	; 0x8022b0 <__flp>
    2b88:	b0 91 b1 22 	lds	r27, 0x22B1	; 0x8022b1 <__flp+0x1>
    2b8c:	10 97       	sbiw	r26, 0x00	; 0
    2b8e:	81 f4       	brne	.+32     	; 0x2bb0 <free+0x3e>
    2b90:	20 81       	ld	r18, Z
    2b92:	31 81       	ldd	r19, Z+1	; 0x01
    2b94:	82 0f       	add	r24, r18
    2b96:	93 1f       	adc	r25, r19
    2b98:	20 91 ae 22 	lds	r18, 0x22AE	; 0x8022ae <__brkval>
    2b9c:	30 91 af 22 	lds	r19, 0x22AF	; 0x8022af <__brkval+0x1>
    2ba0:	28 17       	cp	r18, r24
    2ba2:	39 07       	cpc	r19, r25
    2ba4:	51 f5       	brne	.+84     	; 0x2bfa <free+0x88>
    2ba6:	e0 93 ae 22 	sts	0x22AE, r30	; 0x8022ae <__brkval>
    2baa:	f0 93 af 22 	sts	0x22AF, r31	; 0x8022af <__brkval+0x1>
    2bae:	67 c0       	rjmp	.+206    	; 0x2c7e <free+0x10c>
    2bb0:	ed 01       	movw	r28, r26
    2bb2:	20 e0       	ldi	r18, 0x00	; 0
    2bb4:	30 e0       	ldi	r19, 0x00	; 0
    2bb6:	ce 17       	cp	r28, r30
    2bb8:	df 07       	cpc	r29, r31
    2bba:	40 f4       	brcc	.+16     	; 0x2bcc <free+0x5a>
    2bbc:	4a 81       	ldd	r20, Y+2	; 0x02
    2bbe:	5b 81       	ldd	r21, Y+3	; 0x03
    2bc0:	9e 01       	movw	r18, r28
    2bc2:	41 15       	cp	r20, r1
    2bc4:	51 05       	cpc	r21, r1
    2bc6:	f1 f0       	breq	.+60     	; 0x2c04 <free+0x92>
    2bc8:	ea 01       	movw	r28, r20
    2bca:	f5 cf       	rjmp	.-22     	; 0x2bb6 <free+0x44>
    2bcc:	c2 83       	std	Z+2, r28	; 0x02
    2bce:	d3 83       	std	Z+3, r29	; 0x03
    2bd0:	40 81       	ld	r20, Z
    2bd2:	51 81       	ldd	r21, Z+1	; 0x01
    2bd4:	84 0f       	add	r24, r20
    2bd6:	95 1f       	adc	r25, r21
    2bd8:	c8 17       	cp	r28, r24
    2bda:	d9 07       	cpc	r29, r25
    2bdc:	59 f4       	brne	.+22     	; 0x2bf4 <free+0x82>
    2bde:	88 81       	ld	r24, Y
    2be0:	99 81       	ldd	r25, Y+1	; 0x01
    2be2:	84 0f       	add	r24, r20
    2be4:	95 1f       	adc	r25, r21
    2be6:	02 96       	adiw	r24, 0x02	; 2
    2be8:	80 83       	st	Z, r24
    2bea:	91 83       	std	Z+1, r25	; 0x01
    2bec:	8a 81       	ldd	r24, Y+2	; 0x02
    2bee:	9b 81       	ldd	r25, Y+3	; 0x03
    2bf0:	82 83       	std	Z+2, r24	; 0x02
    2bf2:	93 83       	std	Z+3, r25	; 0x03
    2bf4:	21 15       	cp	r18, r1
    2bf6:	31 05       	cpc	r19, r1
    2bf8:	29 f4       	brne	.+10     	; 0x2c04 <free+0x92>
    2bfa:	e0 93 b0 22 	sts	0x22B0, r30	; 0x8022b0 <__flp>
    2bfe:	f0 93 b1 22 	sts	0x22B1, r31	; 0x8022b1 <__flp+0x1>
    2c02:	3d c0       	rjmp	.+122    	; 0x2c7e <free+0x10c>
    2c04:	e9 01       	movw	r28, r18
    2c06:	ea 83       	std	Y+2, r30	; 0x02
    2c08:	fb 83       	std	Y+3, r31	; 0x03
    2c0a:	49 91       	ld	r20, Y+
    2c0c:	59 91       	ld	r21, Y+
    2c0e:	c4 0f       	add	r28, r20
    2c10:	d5 1f       	adc	r29, r21
    2c12:	ec 17       	cp	r30, r28
    2c14:	fd 07       	cpc	r31, r29
    2c16:	61 f4       	brne	.+24     	; 0x2c30 <free+0xbe>
    2c18:	80 81       	ld	r24, Z
    2c1a:	91 81       	ldd	r25, Z+1	; 0x01
    2c1c:	84 0f       	add	r24, r20
    2c1e:	95 1f       	adc	r25, r21
    2c20:	02 96       	adiw	r24, 0x02	; 2
    2c22:	e9 01       	movw	r28, r18
    2c24:	88 83       	st	Y, r24
    2c26:	99 83       	std	Y+1, r25	; 0x01
    2c28:	82 81       	ldd	r24, Z+2	; 0x02
    2c2a:	93 81       	ldd	r25, Z+3	; 0x03
    2c2c:	8a 83       	std	Y+2, r24	; 0x02
    2c2e:	9b 83       	std	Y+3, r25	; 0x03
    2c30:	e0 e0       	ldi	r30, 0x00	; 0
    2c32:	f0 e0       	ldi	r31, 0x00	; 0
    2c34:	12 96       	adiw	r26, 0x02	; 2
    2c36:	8d 91       	ld	r24, X+
    2c38:	9c 91       	ld	r25, X
    2c3a:	13 97       	sbiw	r26, 0x03	; 3
    2c3c:	00 97       	sbiw	r24, 0x00	; 0
    2c3e:	19 f0       	breq	.+6      	; 0x2c46 <free+0xd4>
    2c40:	fd 01       	movw	r30, r26
    2c42:	dc 01       	movw	r26, r24
    2c44:	f7 cf       	rjmp	.-18     	; 0x2c34 <free+0xc2>
    2c46:	8d 91       	ld	r24, X+
    2c48:	9c 91       	ld	r25, X
    2c4a:	11 97       	sbiw	r26, 0x01	; 1
    2c4c:	9d 01       	movw	r18, r26
    2c4e:	2e 5f       	subi	r18, 0xFE	; 254
    2c50:	3f 4f       	sbci	r19, 0xFF	; 255
    2c52:	82 0f       	add	r24, r18
    2c54:	93 1f       	adc	r25, r19
    2c56:	20 91 ae 22 	lds	r18, 0x22AE	; 0x8022ae <__brkval>
    2c5a:	30 91 af 22 	lds	r19, 0x22AF	; 0x8022af <__brkval+0x1>
    2c5e:	28 17       	cp	r18, r24
    2c60:	39 07       	cpc	r19, r25
    2c62:	69 f4       	brne	.+26     	; 0x2c7e <free+0x10c>
    2c64:	30 97       	sbiw	r30, 0x00	; 0
    2c66:	29 f4       	brne	.+10     	; 0x2c72 <free+0x100>
    2c68:	10 92 b0 22 	sts	0x22B0, r1	; 0x8022b0 <__flp>
    2c6c:	10 92 b1 22 	sts	0x22B1, r1	; 0x8022b1 <__flp+0x1>
    2c70:	02 c0       	rjmp	.+4      	; 0x2c76 <free+0x104>
    2c72:	12 82       	std	Z+2, r1	; 0x02
    2c74:	13 82       	std	Z+3, r1	; 0x03
    2c76:	a0 93 ae 22 	sts	0x22AE, r26	; 0x8022ae <__brkval>
    2c7a:	b0 93 af 22 	sts	0x22AF, r27	; 0x8022af <__brkval+0x1>
    2c7e:	df 91       	pop	r29
    2c80:	cf 91       	pop	r28
    2c82:	08 95       	ret

00002c84 <memcpy>:
    2c84:	fb 01       	movw	r30, r22
    2c86:	dc 01       	movw	r26, r24
    2c88:	02 c0       	rjmp	.+4      	; 0x2c8e <memcpy+0xa>
    2c8a:	01 90       	ld	r0, Z+
    2c8c:	0d 92       	st	X+, r0
    2c8e:	41 50       	subi	r20, 0x01	; 1
    2c90:	50 40       	sbci	r21, 0x00	; 0
    2c92:	d8 f7       	brcc	.-10     	; 0x2c8a <memcpy+0x6>
    2c94:	08 95       	ret

00002c96 <_exit>:
    2c96:	f8 94       	cli

00002c98 <__stop_program>:
    2c98:	ff cf       	rjmp	.-2      	; 0x2c98 <__stop_program>
